<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2024-02-01" />
  <title>STRESS-NG</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">STRESS-NG</h1>
<p class="date">1 February 2024</p>
</header>
<h1>NAME</h1>
<p>stress-ng - stress "next generation", a tool to load and stress a
computer system</p>
<h1>SYNOPSIS</h1>
<p><strong>stress-ng</strong> [<em>OPTION </em>[<em>ARG</em>]] ...</p>
<h1>DESCRIPTION</h1>
<p>stress-ng will stress test a computer system in various selectable
ways. It was designed to exercise various physical subsystems of a
computer as well as the various operating system kernel interfaces.
stress-ng also has a wide range of CPU specific stress tests that
exercise floating point, integer, bit manipulation and control flow.</p>
<p>stress-ng was originally intended to make a machine work hard and
trip hardware issues such as thermal overruns as well as operating
system bugs that only occur when a system is being thrashed hard. Use
stress-ng with caution as some of the tests can make a system run hot on
poorly designed hardware and also can cause excessive system thrashing
which may be difficult to stop.</p>
<p>stress-ng can also measure test throughput rates; this can be useful
to observe performance changes across different operating system
releases or types of hardware. However, it has never been intended to be
used as a precise benchmark test suite, so do NOT use it in this
manner.</p>
<p>Running stress-ng with root privileges will adjust out of memory
settings on Linux systems to make the stressors unkillable in low memory
situations, so use this judiciously. With the appropriate privilege,
stress-ng can allow the ionice class and ionice levels to be adjusted,
again, this should be used with care.</p>
<p>One can specify the number of processes to invoke per type of stress
test; specifying a zero value will select the number of processors
available as defined by sysconf(_SC_NPROCESSORS_CONF), if that can't be
determined then the number of online CPUs is used. If the value is less
than zero then the number of online CPUs is used.</p>
<h1>OPTIONS</h1>
<p><strong>General stress-ng control options:</strong></p>
<dl>
<dt><strong>--abort</strong></dt>
<dd>
<p>this option will force all running stressors to abort (terminate) if
any other stressor terminates prematurely because of a failure.</p>
</dd>
<dt><strong>--aggressive</strong></dt>
<dd>
<p>enables more file, cache and memory aggressive options. This may slow
tests down, increase latencies and reduce the number of bogo ops as well
as changing the balance of user time vs system time used depending on
the type of stressor being used.</p>
</dd>
<dt><strong>-a N, --all N, --parallel N</strong></dt>
<dd>
<p>start N instances of all stressors in parallel. If N is less than
zero, then the number of CPUs online is used for the number of
instances. If N is zero, then the number of configured CPUs in the
system is used.</p>
</dd>
<dt><strong>-b N, --backoff N</strong></dt>
<dd>
<p>wait N microseconds between the start of each stress worker process.
This allows one to ramp up the stress tests over time.</p>
</dd>
<dt><strong>--change-cpu</strong></dt>
<dd>
<p>this forces child processes of some stressors to change to a
different CPU from the parent on startup. Note that during the execution
of the stressor the scheduler may choose move the parent onto the same
CPU as the child. The stressors affected by this option are
client/server style stressors, such as the network stresors (sock,
sockmany, udp, etc) or context switching stressors (switch, pipe,
etc).</p>
</dd>
<dt><strong>--class name</strong></dt>
<dd>
<p>specify the class of stressors to run. Stressors are classified into
one or more of the following classes: cpu, cpu-cache, device, gpu, io,
interrupt, filesystem, memory, network, os, pipe, scheduler, signal and
vm. Some stressors fall into just one class. For example the 'get'
stressor is just in the 'os' class. Other stressors fall into more than
one class, for example, the 'lsearch' stressor falls into the 'cpu',
'cpu-cache' and 'memory' classes as it exercises all these three.
Selecting a specific class will run all the stressors that fall into
that class only when run with the --sequential option.</p>
</dd>
</dl>
<p>Specifying a name followed by a question mark (for example --class
vm?) will print out all the stressors in that specific class.</p>
<dl>
<dt><strong>--config</strong></dt>
<dd>
<p>print out the configuration used to build stress-ng.</p>
</dd>
<dt><strong>-n, --dry-run</strong></dt>
<dd>
<p>parse options, but do not run stress tests. A no-op.</p>
</dd>
<dt><strong>--ftrace</strong></dt>
<dd>
<p>enable kernel function call tracing (Linux only). This will use the
kernel debugfs ftrace mechanism to record all the kernel functions used
on the system while stress-ng is running. This is only as accurate as
the kernel ftrace output, so there may be some variability on the data
reported.</p>
</dd>
<dt><strong>-h, --help</strong></dt>
<dd>
<p>show help.</p>
</dd>
<dt><strong>--ignite-cpu</strong></dt>
<dd>
<p>alter kernel controls to try and maximize the CPU. This requires root
privilege to alter various /sys interface controls. Currently this only
works for Intel P-State enabled x86 systems on Linux.</p>
</dd>
<dt><strong>--interrupts</strong></dt>
<dd>
<p>check for any system management interrupts or error interrupts that
occur, for example thermal overruns, machine check exceptions, etc. Note
that the interrupts are accounted to all the concurrently running
stressors, so total count for all stressors is over accounted.</p>
</dd>
<dt><strong>--ionice-class class</strong></dt>
<dd>
<p>specify ionice class (only on Linux). Can be idle (default),
besteffort, be, realtime, rt.</p>
</dd>
<dt><strong>--ionice-level level</strong></dt>
<dd>
<p>specify ionice level (only on Linux). For idle, 0 is the only
possible option. For besteffort or realtime values 0 (highest priority)
to 7 (lowest priority). See ionice(1) for more details.</p>
</dd>
<dt><strong>--iostat S</strong></dt>
<dd>
<p>every S seconds show I/O statistics on the device that stores the
stress-ng temporary files. This is either the device of the current
working directory or the --temp-path specified path. Currently a Linux
only option. The fields output are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Column Heading</td>
<td style="text-align: left;">Explanation</td>
</tr>
<tr class="even">
<td style="text-align: left;">Inflight</td>
<td style="text-align: left;">number of I/O requests that have been
issued to the device driver but have not yet completed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Rd K/s</td>
<td style="text-align: left;">read rate in 1024 bytes per second</td>
</tr>
<tr class="even">
<td style="text-align: left;">Wr K/s</td>
<td style="text-align: left;">write rate in 1024 bytes per second</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dscd K/s</td>
<td style="text-align: left;">discard rate in 1024 bytes per second</td>
</tr>
<tr class="even">
<td style="text-align: left;">Rd/s</td>
<td style="text-align: left;">reads per second</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Wr/s</td>
<td style="text-align: left;">writes per second</td>
</tr>
<tr class="even">
<td style="text-align: left;">Dscd/s</td>
<td style="text-align: left;">discards per second</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--job jobfile</strong></dt>
<dd>
<p>run stressors using a jobfile. The jobfile is essentially a file
containing stress-ng options (without the leading --) with one option
per line. Lines may have comments with comment text proceeded by the #
character. A simple example is as follows:</p>
</dd>
</dl>
<blockquote>
<pre><code>run sequential   # run stressors sequentially
verbose          # verbose output
metrics-brief    # show metrics at end of run
timeout 60s      # stop each stressor after 60 seconds
#
# vm stressor options:
#
vm 2             # 2 vm stressors
vm-bytes 128M    # 128MB available memory
vm-keep          # keep vm mapping
vm-populate      # populate memory
#
# memcpy stressor options:
#
memcpy 5         # 5 memcpy stressors</code></pre>
</blockquote>
<blockquote>
<p>The job file introduces the run command that specifies how to run the
stressors:</p>
<p>run sequential - run stressors sequentially<br />
run parallel - run stressors together in parallel</p>
<p>Note that 'run parallel' is the default.</p>
</blockquote>
<dl>
<dt><strong>--keep-files</strong></dt>
<dd>
<p>do not remove files and directories created by the stressors. This
can be useful for debugging purposes. Not generally recommended as it
can fill up a file system.</p>
</dd>
<dt><strong>-k, --keep-name</strong></dt>
<dd>
<p>by default, stress-ng will attempt to change the name of the stress
processes according to their functionality; this option disables this
and keeps the process names to be the name of the parent process, that
is, stress-ng.</p>
</dd>
<dt><strong>--klog-check</strong></dt>
<dd>
<p>check the kernel log for kernel error and warning messages and report
these as soon as they are detected. Linux only and requires root
capability to read the kernel log.</p>
</dd>
<dt><strong>--ksm</strong></dt>
<dd>
<p>enable kernel samepage merging (Linux only). This is a memory-saving
de-duplication feature for merging anonymous (private) pages.</p>
</dd>
<dt><strong>--log-brief</strong></dt>
<dd>
<p>by default stress-ng will report the name of the program, the message
type and the process id as a prefix to all output. The --log-brief
option will output messages without these fields to produce a less
verbose output.</p>
</dd>
<dt><strong>--log-file filename</strong></dt>
<dd>
<p>write messages to the specified log file.</p>
</dd>
<dt><strong>--log-lockless</strong></dt>
<dd>
<p>log messages use a lock to avoid intermingling of blocks of stressor
messages, however this may cause contention when emitting a high rate of
logging messages in verbose mode and many stressors are running, for
example when testing CPU scaling with many processes on many CPUs. This
option disables log message locking.</p>
</dd>
<dt><strong>--maximize</strong></dt>
<dd>
<p>overrides the default stressor settings and instead sets these to the
maximum settings allowed. These defaults can always be overridden by the
per stressor settings options if required.</p>
</dd>
<dt><strong>--max-fd N</strong></dt>
<dd>
<p>set the maximum limit on file descriptors (value or a % of system
allowed maximum). By default, stress-ng can use all the available file
descriptors; this option sets the limit in the range from 10 up to the
maximum limit of RLIMIT_NOFILE. One can use a % setting too, e.g. 50% is
half the maximum allowed file descriptors. Note that stress-ng will use
about 5 of the available file descriptors so take this into
consideration when using this setting.</p>
</dd>
<dt><strong>--mbind list</strong></dt>
<dd>
<p>set strict NUMA memory allocation based on the list of NUMA nodes
provided; page allocations will come from the node with sufficient free
memory closest to the specified node(s) where the allocation takes
place. This uses the Linux set_mempolicy(2) call using the MPOL_BIND
mode. The NUMA nodes to be used are specified by a comma separated list
of node (0 to N-1). One can specify a range of NUMA nodes using '-', for
example: --mbind 0,2-3,6,7-11</p>
</dd>
<dt><strong>--metrics</strong></dt>
<dd>
<p>output number of bogo operations in total performed by the stress
processes. Note that these are <strong>not a reliable metric of
performance or throughput</strong> and <strong>have not been designed to
be used for benchmarking whatsoever.</strong> Some stressors have
additional metrics that are more useful than bogo-ops, and these are
generally more useful for observing how a system behaves when under
various kinds of load.</p>
<p>The following columns of information are output:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Column Heading</td>
<td style="text-align: left;">Explanation</td>
</tr>
<tr class="even">
<td style="text-align: left;">bogo ops</td>
<td style="text-align: left;">number of iterations of the stressor
during the run. This is metric of how much overall "work" has been
achieved in bogo operations. <strong>Do not use this as a reliable
measure of throughput for benchmarking.</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">real time (secs)</td>
<td style="text-align: left;">average wall clock duration (in seconds)
of the stressor. This is the total wall clock time of all the instances
of that particular stressor divided by the number of these stressors
being run.</td>
</tr>
<tr class="even">
<td style="text-align: left;">usr time (secs)</td>
<td style="text-align: left;">total user time (in seconds) consumed
running all the instances of the stressor.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sys time (secs)</td>
<td style="text-align: left;">total system time (in seconds) consumed
running all the instances of the stressor.</td>
</tr>
<tr class="even">
<td style="text-align: left;">bogo ops/s (real time)</td>
<td style="text-align: left;">total bogo operations per second based on
wall clock run time. The wall clock time reflects the apparent run time.
The more processors one has on a system the more the work load can be
distributed onto these and hence the wall clock time will reduce and the
bogo ops rate will increase. This is essentially the "apparent" bogo ops
rate of the system.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bogo ops/s (usr+sys time)</td>
<td style="text-align: left;">total bogo operations per second based on
cumulative user and system time. This is the real bogo ops rate of the
system taking into consideration the actual time execution time of the
stressor across all the processors. Generally this will decrease as one
adds more concurrent stressors due to contention on cache, memory,
execution units, buses and I/O devices.</td>
</tr>
<tr class="even">
<td style="text-align: left;">CPU used per instance (%)</td>
<td style="text-align: left;">total percentage of CPU used divided by
number of stressor instances. 100% is 1 full CPU. Some stressors run
multiple threads so it is possible to have a figure greater than
100%.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RSS Max (KB)</td>
<td style="text-align: left;">resident set size (RSS), the portion of
memory (measured in Kilobytes) occupied by a process in main
memory.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>--metrics-brief</strong></dt>
<dd>
<p>show shorter list of stressor metrics (no CPU used per instance).</p>
</dd>
<dt><strong>--minimize</strong></dt>
<dd>
<p>overrides the default stressor settings and instead sets these to the
minimum settings allowed. These defaults can always be overridden by the
per stressor settings options if required.</p>
</dd>
<dt><strong>--no-madvise</strong></dt>
<dd>
<p>from version 0.02.26 stress-ng automatically calls madvise(2) with
random advise options before each mmap and munmap to stress the vm
subsystem a little harder. The --no-advise option turns this default
off.</p>
</dd>
<dt><strong>--no-oom-adjust</strong></dt>
<dd>
<p>disable any form of out-of-memory score adjustments, keep the system
defaults. Normally stress-ng will adjust the out-of-memory scores on
stressors to try to create more memory pressure. This option disables
the adjustments.</p>
</dd>
<dt><strong>--no-rand-seed</strong></dt>
<dd>
<p>Do not seed the stress-ng pseudo-random number generator with a quasi
random start seed, but instead seed it with constant values. This forces
tests to run each time using the same start conditions which can be
useful when one requires reproducible stress tests.</p>
</dd>
<dt><strong>--oom-avoid</strong></dt>
<dd>
<p>Attempt to avoid out-of-memory conditions that can lead to the
Out-of-Memory (OOM) killer terminating stressors. This checks for low
memory scenarios and swapping before making memory allocations and hence
adds some overhead to the stressors and will slow down stressor
allocation speeds.</p>
</dd>
<dt><strong>--oom-avoid-bytes N</strong></dt>
<dd>
<p>Specify a low memory threshold to avoid making any further memory
allocations. The parameter can be specified as an absolute number of
bytes (e.g. 2M for 2MB) or a percentage of the current free memory, e.g.
5% (the default is 2.5%). This option implicitly enables --oom-avoid.
The option allows the system to have enough free memory to try to avoid
the out-of-memory killer terminating processes.</p>
</dd>
<dt><strong>--oomable</strong></dt>
<dd>
<p>Do not respawn a stressor if it gets killed by the Out-of-Memory
(OOM) killer. The default behaviour is to restart a new instance of a
stressor if the kernel OOM killer terminates the process. This option
disables this default behaviour.</p>
</dd>
<dt><strong>--page-in</strong></dt>
<dd>
<p>touch allocated pages that are not in core, forcing them to be paged
back in. This is a useful option to force all the allocated pages to be
paged in when using the bigheap, mmap and vm stressors. It will severely
degrade performance when the memory in the system is less than the
allocated buffer sizes. This uses mincore(2) to determine the pages that
are not in core and hence need touching to page them back in.</p>
</dd>
<dt><strong>--pathological</strong></dt>
<dd>
<p>enable stressors that are known to hang systems. Some stressors can
rapidly consume resources that may hang a system, or perform actions
that can lock a system up or cause it to reboot. These stressors are not
enabled by default, this option enables them, but you probably don't
want to do this. You have been warned. This option applies to the
stressors: bad-ioctl, bind-mount, cpu-online, mlockmany, oom-pipe, smi,
sysinval and watchdog.</p>
</dd>
<dt><strong>--perf</strong></dt>
<dd>
<p>measure processor and system activity using perf events. Linux only
and caveat emptor, according to perf_event_open(2): "Always double-check
your results! Various generalized events have had wrong values.". Note
that with Linux 4.7 one needs to have CAP_SYS_ADMIN capabilities for
this option to work, or adjust /proc/sys/kernel/perf_event_paranoid to
below 2 to use this without CAP_SYS_ADMIN.</p>
</dd>
<dt><strong>--permute N</strong></dt>
<dd>
<p>run all permutations of the selected stressors with N instances of
the permutated stressors per run. If N is less than zero, then the
number of CPUs online is used for the number of instances. If N is zero,
then the number of configured CPUs in the system is used. This will
perform multiple runs with all the permutations of the stressors. Use
this in conjunction with the --with or --class option to specify the
stressors to permute.</p>
</dd>
<dt><strong>-q, --quiet</strong></dt>
<dd>
<p>do not show any output.</p>
</dd>
<dt><strong>-r N, --random N</strong></dt>
<dd>
<p>start N random stress workers. If N is 0, then the number of
configured processors is used for N.</p>
</dd>
<dt><strong>--sched scheduler</strong></dt>
<dd>
<p>select the named scheduler (only on Linux). To see the list of
available schedulers use: stress-ng --sched which</p>
</dd>
<dt><strong>--sched-prio prio</strong></dt>
<dd>
<p>select the scheduler priority level (only on Linux). If the scheduler
does not support this then the default priority level of 0 is
chosen.</p>
</dd>
<dt><strong>--sched-period period</strong></dt>
<dd>
<p>select the period parameter for deadline scheduler (only on Linux).
Default value is 0 (in nanoseconds).</p>
</dd>
<dt><strong>--sched-runtime runtime</strong></dt>
<dd>
<p>select the runtime parameter for deadline scheduler (only on Linux).
Default value is 99999 (in nanoseconds).</p>
</dd>
<dt><strong>--sched-deadline deadline</strong></dt>
<dd>
<p>select the deadline parameter for deadline scheduler (only on Linux).
Default value is 100000 (in nanoseconds).</p>
</dd>
<dt><strong>--sched-reclaim</strong></dt>
<dd>
<p>use cpu bandwidth reclaim feature for deadline scheduler (only on
Linux).</p>
</dd>
<dt><strong>--seed N</strong></dt>
<dd>
<p>set the random number generate seed with a 64 bit value. Allows
stressors to use the same random number generator sequences on each
invocation.</p>
</dd>
<dt><strong>--settings</strong></dt>
<dd>
<p>show the various option settings.</p>
</dd>
<dt><strong>--sequential N</strong></dt>
<dd>
<p>sequentially run all the stressors one by one for a default of 60
seconds. The number of instances of each of the individual stressors to
be started is N. If N is less than zero, then the number of CPUs online
is used for the number of instances. If N is zero, then the number of
CPUs in the system is used. Use the --timeout option to specify the
duration to run each stressor.</p>
</dd>
<dt><strong>--skip-silent</strong></dt>
<dd>
<p>silence messages that report that a stressor has been skipped because
it requires features not supported by the system, such as unimplemented
system calls, missing resources or processor specific features.</p>
</dd>
<dt><strong>--smart</strong></dt>
<dd>
<p>scan the block devices for changes S.M.A.R.T. statistics (Linux
only). This requires root privileges to read the Self-Monitoring,
Analysis and Reporting Technology data from all block devies and will
report any changes in the statistics. One caveat is that device
manufacturers provide different sets of data, the exact meaning of the
data can be vague and the data may be inaccurate.</p>
</dd>
<dt><strong>--sn</strong></dt>
<dd>
<p>use scientific notation (e.g. 2.412e+01) for metrics.</p>
</dd>
<dt><strong>--status N</strong></dt>
<dd>
<p>report every N seconds the number of running, exiting, reaped and
failed stressors, number of stressors that received SIGARLM termination
signal as well as the current run duration.</p>
</dd>
<dt><strong>--stderr</strong></dt>
<dd>
<p>write messages to stderr. With version 0.15.08 output is written to
stdout, previously due to a historical oversight output went to stderr.
This option allows one to revert to the pre-0.15.08 behaviour.</p>
</dd>
<dt><strong>--stdout</strong></dt>
<dd>
<p>all output goes to stdout. This is the new default for version
0.15.08. Use the --stderr option for the original behaviour.</p>
</dd>
<dt><strong>--stressors</strong></dt>
<dd>
<p>output the names of the available stressors.</p>
</dd>
<dt><strong>--syslog</strong></dt>
<dd>
<p>log output (except for verbose -v messages) to the syslog.</p>
</dd>
<dt><strong>--taskset list</strong></dt>
<dd>
<p>set CPU affinity based on the list of CPUs provided; stress-ng is
bound to just use these CPUs (Linux only). The CPUs to be used are
specified by a comma separated list of CPU (0 to N-1). One can specify a
range of CPUs using '-', for example: --taskset 0,2-3,6,7-11</p>
</dd>
<dt><strong>--temp-path path</strong></dt>
<dd>
<p>specify a path for stress-ng temporary directories and temporary
files; the default path is the current working directory. This path must
have read and write access for the stress-ng stress processes.</p>
</dd>
<dt><strong>--thermalstat S</strong></dt>
<dd>
<p>every S seconds show CPU and thermal load statistics. This option
shows average CPU frequency in GHz (average of online-CPUs), the minimum
CPU frequency, the maximum CPU frequency, load averages (1 minute, 5
minute and 15 minutes) and available thermal zone temperatures in
degrees Centigrade.</p>
</dd>
<dt><strong>--thrash</strong></dt>
<dd>
<p>This can only be used when running on Linux and with root privilege.
This option starts a background thrasher process that works through all
the processes on a system and tries to page as many pages in the
processes as possible. It also periodically drops the page cache, frees
reclaimable slab objects and pagecache. This will cause considerable
amount of thrashing of swap on an over-committed system.</p>
</dd>
<dt><strong>-t N, --timeout T</strong></dt>
<dd>
<p>run each stress test for at least T seconds. One can also specify the
units of time in seconds, minutes, hours, days or years with the suffix
s, m, h, d or y. Each stressor will be sent a SIGALRM signal at the
timeout time, however if the stress test is swapped out, in an
uninterruptible system call or performing clean up (such as removing
hundreds of test file) it may take a while to finally terminate. A 0
timeout will run stress-ng for ever with no timeout. The default timeout
is 24 hours.</p>
</dd>
<dt><strong>--times</strong></dt>
<dd>
<p>show the cumulative user and system times of all the child processes
at the end of the stress run. The percentage of utilisation of available
CPU time is also calculated from the number of on-line CPUs in the
system.</p>
</dd>
<dt><strong>--timestamp</strong></dt>
<dd>
<p>add a timestamp in hours, minutes, seconds and hundredths of a second
to the log output.</p>
</dd>
<dt><strong>--timer-slack N</strong></dt>
<dd>
<p>adjust the per process timer slack to N nanoseconds (Linux only).
Increasing the timer slack allows the kernel to coalesce timer events by
adding some fuzziness to timer expiration times and hence reduce
wakeups. Conversely, decreasing the timer slack will increase wakeups. A
value of 0 for the timer-slack will set the system default of 50,000
nanoseconds.</p>
</dd>
<dt><strong>--tz</strong></dt>
<dd>
<p>collect temperatures from the available thermal zones on the machine
(Linux only). Some devices may have one or more thermal zones, where as
others may have none.</p>
</dd>
<dt><strong>-v, --verbose</strong></dt>
<dd>
<p>show all debug, warnings and normal information output.</p>
</dd>
<dt><strong>--verify</strong></dt>
<dd>
<p>verify results when a test is run. This is not available on all
tests. This will sanity check the computations or memory contents from a
test run and report to stderr any unexpected failures.</p>
</dd>
<dt><strong>--verifiable</strong></dt>
<dd>
<p>print the names of stressors that can be verified with the --verify
option.</p>
</dd>
<dt><strong>-V, --version</strong></dt>
<dd>
<p>show version of stress-ng, version of toolchain used to build
stress-ng and system information.</p>
</dd>
<dt><strong>--vmstat S</strong></dt>
<dd>
<p>every S seconds show statistics about processes, memory, paging,
block I/O, interrupts, context switches, disks and cpu activity. The
output is similar that to the output from the vmstat(8) utility. Not
fully supported on various UNIX systems.</p>
</dd>
<dt><strong>--with list</strong></dt>
<dd>
<p>specify stressors to run when using the --all, --seq or --permute
options. For example to run 5 instances of the cpu, hash, nop and vm
stressors one after another (sequentially) for 1 minute per stressor
use:</p>
</dd>
</dl>
<pre><code>stress-ng --seq 5 --with cpu,hash,nop,vm --timeout 1m</code></pre>
<dl>
<dt><strong>-x, --exclude list</strong></dt>
<dd>
<p>specify a list of one or more stressors to exclude (that is, do not
run them). This is useful to exclude specific stressors when one selects
many stressors to run using the --class option, --sequential, --all and
--random options. Example, run the cpu class stressors concurrently and
exclude the numa and search stressors:</p>
<p>stress-ng --class cpu --all 1 -x numa,bsearch,hsearch,lsearch</p>
</dd>
<dt><strong>-Y, --yaml filename</strong></dt>
<dd>
<p>output gathered statistics to a YAML formatted file named
'filename'.<br />
</p>
</dd>
</dl>
<p><strong>Stressor specific options:</strong></p>
<dl>
<dt><strong>Access stressor</strong></dt>
<dd>
<p><strong>--access N</strong> start N workers that work through various
settings of file mode bits (read, write, execute) for the file owner and
checks if the user permissions of the file using access(2) and
faccessat(2) are sane.</p>
<dl>
<dt><strong>--access-ops N</strong></dt>
<dd>
<p>stop access workers after N bogo access sanity checks.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX Access Control List Stressor</strong></dt>
<dd>
<p><strong>--acl N</strong> start N workers that exercise permutations
of ACL access permission settings on user, group and other tags.</p>
<dl>
<dt><strong>--acl-rand</strong></dt>
<dd>
<p>randomize (by shuffling) the order of the ACL access permissions
before exercising ACLs.</p>
</dd>
<dt><strong>--acl-ops N</strong></dt>
<dd>
<p>stop acl workers after N bogo acl settings have been set.</p>
</dd>
</dl>
</dd>
<dt><strong>Affinity stressor</strong></dt>
<dd>
<p><strong>--affinity N</strong> start N workers that run 16 processes
that rapidly change CPU affinity (only on Linux). Rapidly switching CPU
affinity can contribute to poor cache behaviour and high context switch
rate.</p>
<dl>
<dt><strong>--affinity-delay N</strong></dt>
<dd>
<p>delay for N nanoseconds before changing affinity to the next CPU. The
delay will spin on CPU scheduling yield operations for N nanoseconds
before the process is moved to another CPU. The default is 0
nanosconds.</p>
</dd>
<dt><strong>--affinity-ops N</strong></dt>
<dd>
<p>stop affinity workers after N bogo affinity operations.</p>
</dd>
<dt><strong>--affinity-pin</strong></dt>
<dd>
<p>pin all the 16 per stressor processes to a CPU. All 16 processes
follow the CPU chosen by the main parent stressor, forcing heavy per CPU
loading.</p>
</dd>
<dt><strong>--affinity-rand</strong></dt>
<dd>
<p>switch CPU affinity randomly rather than the default of
sequentially.</p>
</dd>
<dt><strong>--affinity-sleep N</strong></dt>
<dd>
<p>sleep for N nanoseconds before changing affinity to the next CPU.</p>
</dd>
</dl>
</dd>
<dt><strong>Kernel crypto AF_ALG API stressor</strong></dt>
<dd>
<p><strong>--af-alg N</strong> start N workers that exercise the AF_ALG
socket domain by hashing and encrypting various sized random messages.
This exercises the available hashes, ciphers, rng and aead crypto
engines in the Linux kernel.</p>
<dl>
<dt><strong>--af-alg-dump</strong></dt>
<dd>
<p>dump the internal list representing cryptographic algorithms parsed
from the /proc/crypto file to standard output (stdout).</p>
</dd>
<dt><strong>--af-alg-ops N</strong></dt>
<dd>
<p>stop af-alg workers after N AF_ALG messages are hashed.</p>
</dd>
</dl>
</dd>
<dt><strong>Asynchronous I/O stressor (POSIX AIO)</strong></dt>
<dd>
<p><strong>--aio N</strong> start N workers that issue multiple small
asynchronous I/O writes and reads on a relatively small temporary file
using the POSIX aio interface. This will just hit the file system cache
and soak up a lot of user and kernel time in issuing and handling I/O
requests. By default, each worker process will handle 16 concurrent I/O
requests.</p>
<dl>
<dt><strong>--aio-ops N</strong></dt>
<dd>
<p>stop POSIX asynchronous I/O workers after N bogo asynchronous I/O
requests.</p>
</dd>
<dt><strong>--aio-requests N</strong></dt>
<dd>
<p>specify the number of POSIX asynchronous I/O requests each worker
should issue, the default is 16; 1 to 4096 are allowed.</p>
</dd>
</dl>
</dd>
<dt><strong>Asynchronous I/O stressor (Linux AIO)</strong></dt>
<dd>
<p><strong>--aiol N</strong> start N workers that issue multiple 4K
random asynchronous I/O writes using the Linux aio system calls
io_setup(2), io_submit(2), io_getevents(2) and io_destroy(2). By
default, each worker process will handle 16 concurrent I/O requests.</p>
<dl>
<dt><strong>--aiol-ops N</strong></dt>
<dd>
<p>stop Linux asynchronous I/O workers after N bogo asynchronous I/O
requests.</p>
</dd>
<dt><strong>--aiol-requests N</strong></dt>
<dd>
<p>specify the number of Linux asynchronous I/O requests each worker
should issue, the default is 16; 1 to 4096 are allowed.</p>
</dd>
</dl>
</dd>
<dt><strong>Alarm stressor</strong></dt>
<dd>
<p><strong>--alarm N</strong> start N workers that exercise alarm(2)
with MAXINT, 0 and random alarm and sleep delays that get prematurely
interrupted. Before each alarm is scheduled any previous pending alarms
are cancelled with zero second alarm calls.</p>
<dl>
<dt><strong>--alarm-ops N</strong></dt>
<dd>
<p>stop after N alarm bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>AppArmor stressor</strong></dt>
<dd>
<p><strong>--apparmor N</strong> start N workers that exercise various
parts of the AppArmor interface. Currently one needs root permission to
run this particular test. Only available on Linux systems with AppArmor
support and requires the CAP_MAC_ADMIN capability.</p>
<dl>
<dt><strong>--apparmor-ops</strong></dt>
<dd>
<p>stop the AppArmor workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Atomic stressor</strong></dt>
<dd>
<p><strong>--atomic N</strong> start N workers that exercise various GCC
__atomic_*() built in operations on 8, 16, 32 and 64 bit integers that
are shared among the N workers. This stressor is only available for
builds using GCC 4.7.4 or higher. The stressor forces many front end
cache stalls and cache references.</p>
<dl>
<dt><strong>--atomic-ops N</strong></dt>
<dd>
<p>stop the atomic workers after N bogo atomic operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Bad alternative stack stressor</strong></dt>
<dd>
<p><strong>--bad-altstack N</strong> start N workers that create broken
alternative signal stacks for SIGSEGV and SIGBUS handling that in turn
create secondary SIGSEGV/SIGBUS errors. A variety of randonly selected
nefarious methods are used to create the stacks:</p>
<blockquote>
<ul>
<li><p>Unmapping the alternative signal stack, before triggering the
signal handling.</p></li>
<li><p>Changing the alternative signal stack to just being read only,
write only, execute only.</p></li>
<li><p>Using a NULL alternative signal stack.</p></li>
<li><p>Using the signal handler object as the alternative signal
stack.</p></li>
<li><p>Unmapping the alternative signal stack during execution of the
signal handler.</p></li>
<li><p>Using a read-only text segment for the alternative signal
stack.</p></li>
<li><p>Using an undersized alternative signal stack.</p></li>
<li><p>Using the VDSO as an alternative signal stack.</p></li>
<li><p>Using an alternative stack mapped onto /dev/zero.</p></li>
<li><p>Using an alternative stack mapped to a zero sized temporary file
to generate a SIGBUS error.</p></li>
</ul>
</blockquote>
<dl>
<dt><strong>--bad-altstack-ops N</strong></dt>
<dd>
<p>stop the bad alternative stack stressors after N SIGSEGV bogo
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Bad ioctl stressor</strong></dt>
<dd>
<p><strong>--bad-ioctl N</strong> start N workers that perform a range
of illegal bad read ioctls (using _IOR) across the device drivers. This
exercises page size, 64 bit, 32 bit, 16 bit and 8 bit reads as well as
NULL addresses, non-readable pages and PROT_NONE mapped pages. Currently
only for Linux and requires the --pathological option.</p>
<dl>
<dt><strong>--bad-ioctl-method [ inc | random | random-inc | stride
]</strong></dt>
<dd>
<p>select the method of changing the ioctl command (number, type) tuple
per iteration, the default is random-inc. Available bad-ioctl methods
are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">inc</td>
<td style="text-align: left;">increment ioctl command by 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random</td>
<td style="text-align: left;">use a random ioctl command</td>
</tr>
<tr class="even">
<td style="text-align: left;">random-inc</td>
<td style="text-align: left;">increment ioctl command by a random
value</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random-stride</td>
<td style="text-align: left;">increment ioctl command number by 1 and
decrement command type by 3</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--bad-ioctl-ops N</strong></dt>
<dd>
<p>stop the bad ioctl stressors after N bogo ioctl operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Big heap stressor</strong></dt>
<dd>
<p><strong>-B N, --bigheap N</strong> start N workers that grow their
heaps by reallocating memory. If the out of memory killer (OOM) on Linux
kills the worker or the allocation fails then the allocating process
starts all over again. Note that the OOM adjustment for the worker is
set so that the OOM killer will treat these workers as the first
candidate processes to kill.</p>
<dl>
<dt><strong>--bigheap-bytes N</strong></dt>
<dd>
<p>maximum heap growth as N bytes per bigheap worker. One can specify
the size as % of total available memory or in units of Bytes, KBytes,
MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--bigheap-growth N</strong></dt>
<dd>
<p>specify amount of memory to grow heap by per iteration. Size can be
from 4K to 64MB. Default is 64K.</p>
</dd>
<dt><strong>--bigheap-mlock</strong></dt>
<dd>
<p>attempt to mlock future allocated pages into memory causing more
memory pressure. If mlock(MCL_FUTURE) is implemented then this will stop
newly allocated pages from being swapped out.</p>
</dd>
<dt><strong>--bigheap-ops N</strong></dt>
<dd>
<p>stop the big heap workers after N bogo allocation operations are
completed.</p>
</dd>
</dl>
</dd>
<dt><strong>Binderfs stressor</strong></dt>
<dd>
<p><strong>--binderfs N</strong> start N workers that mount, exercise
and unmount binderfs. The binder control device is exercised with 256
sequential BINDER_CTL_ADD ioctl calls per loop.</p>
<dl>
<dt><strong>--binderfs-ops N</strong></dt>
<dd>
<p>stop after N binderfs cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>Bind mount stressor</strong></dt>
<dd>
<p><strong>--bind-mount N</strong> start N workers that repeatedly bind
mount / to / inside a user namespace. This can consume resources
rapidly, forcing out of memory situations. Do not use this stressor
unless you want to risk hanging your machine.</p>
<dl>
<dt><strong>--bind-mount-ops N</strong></dt>
<dd>
<p>stop after N bind mount bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Branch stressor</strong></dt>
<dd>
<p><strong>--branch N</strong> start N workers that randomly branch to
1024 randomly selected locations and hence exercise the CPU branch
prediction logic.</p>
<dl>
<dt><strong>--branch-ops N</strong></dt>
<dd>
<p>stop the branch stressors after N × 1024 branches</p>
</dd>
</dl>
</dd>
<dt><strong>Brk stressor</strong></dt>
<dd>
<p><strong>--brk N</strong> start N workers that grow the data segment
by one page at a time using multiple brk(2) calls. Each successfully
allocated new page is touched to ensure it is resident in memory. If an
out of memory condition occurs then the test will reset the data segment
to the point before it started and repeat the data segment resizing over
again. The process adjusts the out of memory setting so that it may be
killed by the out of memory (OOM) killer before other processes. If it
is killed by the OOM killer then it will be automatically re-started by
a monitoring parent process.</p>
<dl>
<dt><strong>--brk-bytes N</strong></dt>
<dd>
<p>maximum brk growth as N bytes per brk worker. One can specify the
size as % of total available memory or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--brk-mlock</strong></dt>
<dd>
<p>attempt to mlock future brk pages into memory causing more memory
pressure. If mlock(MCL_FUTURE) is implemented then this will stop new
brk pages from being swapped out.</p>
</dd>
<dt><strong>--brk-notouch</strong></dt>
<dd>
<p>do not touch each newly allocated data segment page. This disables
the default of touching each newly allocated page and hence avoids the
kernel from necessarily backing the page with physical memory.</p>
</dd>
<dt><strong>--brk-ops N</strong></dt>
<dd>
<p>stop the brk workers after N bogo brk operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Binary search stressor</strong></dt>
<dd>
<p><strong>--bsearch N</strong> start N workers that binary search a
sorted array of 32 bit integers using bsearch(3). By default, there are
65536 elements in the array. This is a useful method to exercise random
access of memory and processor cache.</p>
<dl>
<dt><strong>--bsearch-method [ bsearch-libc | bsearch-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of bsearch or a slightly
optimized non-libc implementation of bsearch. The default is the libc
implementation if it exists, otherwise the non-libc version.</p>
</dd>
<dt><strong>--bsearch-ops N</strong></dt>
<dd>
<p>stop the bsearch worker after N bogo bsearch operations are
completed.</p>
</dd>
<dt><strong>--bsearch-size N</strong></dt>
<dd>
<p>specify the size (number of 32 bit integers) in the array to bsearch.
Size can be from 1K to 4M.</p>
</dd>
</dl>
</dd>
<dt><strong>Cache stressor</strong></dt>
<dd>
<p><strong>-C N, --cache N</strong> start N workers that perform random
wide spread memory read and writes to thrash the CPU cache. The code
does not intelligently determine the CPU cache configuration and so it
may be sub-optimal in producing hit-miss read/write activity for some
processors.</p>
<dl>
<dt><strong>--cache-cldemote</strong></dt>
<dd>
<p>cache line demote (x86 only). This is a no-op for non-x86
architectures and older x86 processors that do not support this
feature.</p>
</dd>
<dt><strong>--cache-clflushopt</strong></dt>
<dd>
<p>use optimized cache line flush (x86 only). This is a no-op for
non-x86 architectures and older x86 processors that do not support this
feature.</p>
</dd>
<dt><strong>--cache-clwb</strong></dt>
<dd>
<p>cache line writeback (x86 only). This is a no-op for non-x86
architectures and older x86 processors that do not support this
feature.</p>
</dd>
<dt><strong>--cache-enable-all</strong></dt>
<dd>
<p>where appropriate exercise the cache using cldemote, clflushopt,
fence, flush, sfence and prefetch.</p>
</dd>
<dt><strong>--cache-fence</strong></dt>
<dd>
<p>force write serialization on each store operation (x86 only). This is
a no-op for non-x86 architectures.</p>
</dd>
<dt><strong>--cache-flush</strong></dt>
<dd>
<p>force flush cache on each store operation (x86 only). This is a no-op
for non-x86 architectures.</p>
</dd>
<dt><strong>--cache-level N</strong></dt>
<dd>
<p>specify level of cache to exercise (1=L1 cache, 2=L2 cache, 3=L3/LLC
cache (the default)). If the cache hierarchy cannot be determined,
built-in defaults will apply.</p>
</dd>
<dt><strong>--cache-no-affinity</strong></dt>
<dd>
<p>do not change processor affinity when <strong>--cache</strong> is in
effect.</p>
</dd>
<dt><strong>--cache-ops N</strong></dt>
<dd>
<p>stop cache thrash workers after N bogo cache thrash operations.</p>
</dd>
<dt><strong>--cache-prefetch</strong></dt>
<dd>
<p>force read prefetch on next read address on architectures that
support prefetching.</p>
</dd>
<dt><strong>--cache-sfence</strong></dt>
<dd>
<p>force write serialization on each store operation using the sfence
instruction (x86 only). This is a no-op for non-x86 architectures.</p>
</dd>
<dt><strong>--cache-size N</strong></dt>
<dd>
<p>override the default cache size setting to N bytes. One can specify
the in units of Bytes, KBytes, MBytes and GBytes using the suffix b, k,
m or g.</p>
</dd>
<dt><strong>--cache-ways N</strong></dt>
<dd>
<p>specify the number of cache ways to exercise. This allows a subset of
the overall cache size to be exercised.</p>
</dd>
</dl>
</dd>
<dt><strong>Cache line stressor</strong></dt>
<dd>
<p><strong>--cacheline N</strong> start N workers that exercise reading
and writing individual bytes in a shared buffer that is the size of a
cache line. Each stressor has 2 running processes that exercise just two
bytes that are next to each other. The intent is to try and trigger
cacheline corruption, stalls and misses with shared memory accesses. For
an N byte sized cacheline, it is recommended to run N / 2 stressor
instances.</p>
<dl>
<dt><strong>--cacheline-affinity</strong></dt>
<dd>
<p>frequently change CPU affinity, spread cacheline processes evenly
across all online CPUs to try and maximize lower-level cache activity.
Attempts to keep adjacent cachelines being exercised by adjacent
CPUs.</p>
</dd>
<dt><strong>--cacheline-method method</strong></dt>
<dd>
<p>specify a cacheline stress method. By default, all the stress methods
are exercised sequentially, however one can specify just one method to
be used if required. Available cacheline stress methods are described as
follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the below cpu stress
methods.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">adjacent</td>
<td style="text-align: left;">increment a specific byte in a cacheline
and read the adjacent byte, check for corruption every 7
increments.</td>
</tr>
<tr class="even">
<td style="text-align: left;">atomicinc</td>
<td style="text-align: left;">atomically increment a specific byte in a
cacheline and check for corruption every 7 increments.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bits</td>
<td style="text-align: left;">write and read back shifted bit patterns
into specific byte in a cacheline and check for corruption.</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy</td>
<td style="text-align: left;">copy an adjacent byte to a specific byte
in a cacheline.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">inc</td>
<td style="text-align: left;">increment and read back a specific byte in
a cacheline and check for corruption every 7 increments.</td>
</tr>
<tr class="even">
<td style="text-align: left;">mix</td>
<td style="text-align: left;">perform a mix of increment, left and right
rotates a specific byte in a cacheline and check for corruption.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rdfwd64</td>
<td style="text-align: left;">increment a specific byte in a cacheline
and then read in forward direction an entire cacheline using 64 bit
reads.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rdints</td>
<td style="text-align: left;">increment a specific byte in a cacheline
and then read data at that byte location in naturally aligned locations
integer values of size 8, 16, 32, 64 and 128 bits.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rdrev64</td>
<td style="text-align: left;">increment a specific byte in a cacheline
and then read in reverse direction an entire cacheline using 64 bit
reads.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rdwr</td>
<td style="text-align: left;">read and write the same 8 bit value into a
specific byte in a cacheline and check for corruption.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--cacheline-ops N</strong></dt>
<dd>
<p>stop cacheline workers after N loops of the byte exercising in a
cacheline.</p>
</dd>
</dl>
</dd>
<dt><strong>Process capabilities stressor</strong></dt>
<dd>
<p><strong>--cap N</strong> start N workers that read per process
capabilities via calls to capget(2) (Linux only).</p>
<dl>
<dt><strong>--cap-ops N</strong></dt>
<dd>
<p>stop after N cap bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Cgroup stressor</strong></dt>
<dd>
<p><strong>--cgroup N</strong> start N workers that mount a cgroup, move
a child to the cgroup, read, write and remove the child from the cgroup
and umount the cgroup per bogo-op iteration. This uses cgroup v2 and is
only available for Linux systems.</p>
<dl>
<dt><strong>--cgroup-ops N</strong></dt>
<dd>
<p>stop after N cgroup bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Chattr stressor</strong></dt>
<dd>
<p><strong>--chattr N</strong> start N workers that attempt to exercise
file attributes via the EXT2_IOC_SETFLAGS ioctl. This is intended to be
intentionally racy and exercise a range of chattr attributes by enabling
and disabling them on a file shared amongst the N chattr stressor
processes. (Linux only).</p>
<dl>
<dt><strong>--chattr-ops N</strong></dt>
<dd>
<p>stop after N chattr bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Chdir stressor</strong></dt>
<dd>
<p><strong>--chdir N</strong> start N workers that change directory
between directories using chdir(2).</p>
<dl>
<dt><strong>--chdir-dirs N</strong></dt>
<dd>
<p>exercise chdir on N directories. The default is 8192 directories,
this allows 64 to 65536 directories to be used instead.</p>
</dd>
<dt><strong>--chdir-ops N</strong></dt>
<dd>
<p>stop after N chdir bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Chmod stressor</strong></dt>
<dd>
<p><strong>--chmod N</strong> start N workers that change the file mode
bits via chmod(2) and fchmod(2) on the same file. The greater the value
for N then the more contention on the single file. The stressor will
work through all the combination of mode bits.</p>
<dl>
<dt><strong>--chmod-ops N</strong></dt>
<dd>
<p>stop after N chmod bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Chown stressor</strong></dt>
<dd>
<p><strong>--chown N</strong> start N workers that exercise chown(2) on
the same file. The greater the value for N then the more contention on
the single file.</p>
<dl>
<dt><strong>--chown-ops N</strong></dt>
<dd>
<p>stop the chown workers after N bogo chown(2) operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Chroot stressor</strong></dt>
<dd>
<p><strong>--chroot N</strong> start N workers that exercise chroot(2)
on various valid and invalid chroot paths. Only available on Linux
systems and requires the CAP_SYS_ADMIN capability.</p>
<dl>
<dt><strong>--chroot-ops N</strong></dt>
<dd>
<p>stop the chroot workers after N bogo chroot(2) operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Clock stressor</strong></dt>
<dd>
<p><strong>--clock N</strong> start N workers exercising clocks and
POSIX timers. For all known clock types this will exercise
clock_getres(2), clock_gettime(2) and clock_nanosleep(2). For all known
timers it will create a random duration timer and busy poll this until
it expires. This stressor will cause frequent context switching.</p>
<dl>
<dt><strong>--clock-ops N</strong></dt>
<dd>
<p>stop clock stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Clone stressor</strong></dt>
<dd>
<p><strong>--clone N</strong> start N workers that create clones (via
the clone(2) and clone3() system calls). This will rapidly try to create
a default of 8192 clones that immediately die and wait in a zombie state
until they are reaped. Once the maximum number of clones is reached (or
clone fails because one has reached the maximum allowed) the oldest
clone thread is reaped and a new clone is then created in a first-in
first-out manner, and then repeated. A random clone flag is selected for
each clone to try to exercise different clone operations. The clone
stressor is a Linux only option.</p>
<dl>
<dt><strong>--clone-max N</strong></dt>
<dd>
<p>try to create as many as N clone threads. This may not be reached if
the system limit is less than N.</p>
</dd>
<dt><strong>--clone-ops N</strong></dt>
<dd>
<p>stop clone stress workers after N bogo clone operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Close stressor</strong></dt>
<dd>
<p><strong>--close N</strong> start N workers that try to force race
conditions on closing opened file descriptors. These file descriptors
have been opened in various ways to try and exercise different kernel
close handlers.</p>
<dl>
<dt><strong>--close-ops N</strong></dt>
<dd>
<p>stop close workers after N bogo close operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Swapcontext stressor</strong></dt>
<dd>
<p><strong>--context N</strong> start N workers that run three threads
that use swapcontext(3) to implement the thread-to-thread context
switching. This exercises rapid process context saving and restoring and
is bandwidth limited by register and memory save and restore rates.</p>
<dl>
<dt><strong>--context-ops N</strong></dt>
<dd>
<p>stop context workers after N bogo context switches. In this stressor,
1 bogo op is equivalent to 1000 swapcontext calls.</p>
</dd>
</dl>
</dd>
<dt><strong>Copy file stressor</strong></dt>
<dd>
<p><strong>--copy-file N</strong> start N stressors that copy a file
using the Linux copy_file_range(2) system call. 128 KB chunks of data
are copied from random locations from one file to random locations to a
destination file. By default, the files are 256 MB in size. Data is
sync'd to the filesystem after each copy_file_range(2) call.</p>
<dl>
<dt><strong>--copy-file-bytes N</strong></dt>
<dd>
<p>copy file size, the default is 256 MB. One can specify the size as %
of free space on the file system or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--copy-file-ops N</strong></dt>
<dd>
<p>stop after N copy_file_range() calls.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU stressor</strong></dt>
<dd>
<p><strong>-c N, --cpu N</strong> start N workers exercising the CPU by
sequentially working through all the different CPU stress methods.
Instead of exercising all the CPU stress methods, one can specify a
specific CPU stress method with the --cpu-method option.</p>
<dl>
<dt><strong>-l P, --cpu-load P</strong></dt>
<dd>
<p>load CPU with P percent loading for the CPU stress workers. 0 is
effectively a sleep (no load) and 100 is full loading. The loading loop
is broken into compute time (load%) and sleep time (100% - load%).
Accuracy depends on the overall load of the processor and the
responsiveness of the scheduler, so the actual load may be different
from the desired load. Note that the number of bogo CPU operations may
not be linearly scaled with the load as some systems employ CPU
frequency scaling and so heavier loads produce an increased CPU
frequency and greater CPU bogo operations.</p>
</dd>
</dl>
<p>Note: This option only applies to the --cpu stressor option and not
to all of the cpu class of stressors.</p>
<dl>
<dt><strong>--cpu-load-slice S</strong></dt>
<dd>
<p>note - this option is only useful when --cpu-load is less than 100%.
The CPU load is broken into multiple busy and idle cycles. Use this
option to specify the duration of a busy time slice. A negative value
for S specifies the number of iterations to run before idling the CPU
(e.g. -30 invokes 30 iterations of a CPU stress loop). A zero value
selects a random busy time between 0 and 0.5 seconds. A positive value
for S specifies the number of milliseconds to run before idling the CPU
(e.g. 100 keeps the CPU busy for 0.1 seconds). Specifying small values
for S lends to small time slices and smoother scheduling. Setting
--cpu-load as a relatively low value and --cpu-load-slice to be large
will cycle the CPU between long idle and busy cycles and exercise
different CPU frequencies. The thermal range of the CPU is also cycled,
so this is a good mechanism to exercise the scheduler, frequency scaling
and passive/active thermal cooling mechanisms.</p>
</dd>
</dl>
<p>Note: This option only applies to the --cpu stressor option and not
to all of the cpu class of stressors.</p>
<dl>
<dt><strong>--cpu-method method</strong></dt>
<dd>
<p>specify a cpu stress method. By default, all the stress methods are
exercised sequentially, however one can specify just one method to be
used if required. Available cpu stress methods are described as
follows:</p>
</dd>
</dl>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the below cpu stress
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ackermann</td>
<td style="text-align: left;">Ackermann function: compute A(3, 7),
where: A(m, n) = n + 1 if m = 0; A(m - 1, 1) if m &gt; 0 and n = 0; A(m
- 1, A(m, n - 1)) if m &gt; 0 and n &gt; 0</td>
</tr>
<tr class="even">
<td style="text-align: left;">apery</td>
<td style="text-align: left;">calculate Apery's constant ζ(3); the sum
of 1/(n ↑ 3) to a precision of 1.0x10↑14</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bitops</td>
<td style="text-align: left;">various bit operations from bithack,
namely: reverse bits, parity check, bit count, round to nearest power of
2</td>
</tr>
<tr class="even">
<td style="text-align: left;">callfunc</td>
<td style="text-align: left;">recursively call 8 argument C function to
a depth of 1024 calls and unwind</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cfloat</td>
<td style="text-align: left;">1000 iterations of a mix of floating point
complex operations</td>
</tr>
<tr class="even">
<td style="text-align: left;">cdouble</td>
<td style="text-align: left;">1000 iterations of a mix of double
floating point complex operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">clongdouble</td>
<td style="text-align: left;">1000 iterations of a mix of long double
floating point complex operations</td>
</tr>
<tr class="even">
<td style="text-align: left;">collatz</td>
<td style="text-align: left;">compute the 1348 steps in the collatz
sequence starting from number 989345275647. Where f(n) = n / 2 (for even
n) and f(n) = 3n + 1 (for odd n).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">correlate</td>
<td style="text-align: left;">perform a 8192 × 512 correlation of random
doubles</td>
</tr>
<tr class="even">
<td style="text-align: left;">crc16</td>
<td style="text-align: left;">compute 1024 rounds of CCITT CRC16 on
random data</td>
</tr>
<tr class="odd">
<td style="text-align: left;">decimal32</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit decimal
floating point operations (GCC only)</td>
</tr>
<tr class="even">
<td style="text-align: left;">decimal64</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit decimal
floating point operations (GCC only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">decimal128</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
decimal floating point operations (GCC only)</td>
</tr>
<tr class="even">
<td style="text-align: left;">dither</td>
<td style="text-align: left;">Floyd-Steinberg dithering of a 1024 × 768
random image from 8 bits down to 1 bit of depth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">div8</td>
<td style="text-align: left;">50,000 8 bit unsigned integer
divisions</td>
</tr>
<tr class="even">
<td style="text-align: left;">div16</td>
<td style="text-align: left;">50,000 16 bit unsigned integer
divisions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">div32</td>
<td style="text-align: left;">50,000 32 bit unsigned integer
divisions</td>
</tr>
<tr class="even">
<td style="text-align: left;">div64</td>
<td style="text-align: left;">50,000 64 bit unsigned integer
divisions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">div128</td>
<td style="text-align: left;">50,000 128 bit unsigned integer
divisions</td>
</tr>
<tr class="even">
<td style="text-align: left;">double</td>
<td style="text-align: left;">1000 iterations of a mix of double
precision floating point operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">euler</td>
<td style="text-align: left;">compute e using n = (1 + (1 ÷ n)) ↑ n</td>
</tr>
<tr class="even">
<td style="text-align: left;">explog</td>
<td style="text-align: left;">iterate on n = exp(log(n) ÷ 1.00002)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">factorial</td>
<td style="text-align: left;">find factorials from 1..150 using
Stirling's and Ramanujan's approximations</td>
</tr>
<tr class="even">
<td style="text-align: left;">fibonacci</td>
<td style="text-align: left;">compute Fibonacci sequence of 0, 1, 1, 2,
5, 8...</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fft</td>
<td style="text-align: left;">4096 sample Fast Fourier Transform</td>
</tr>
<tr class="even">
<td style="text-align: left;">fletcher16</td>
<td style="text-align: left;">1024 rounds of a naïve implementation of a
16 bit Fletcher's checksum</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">1000 iterations of a mix of floating point
operations</td>
</tr>
<tr class="even">
<td style="text-align: left;">float16</td>
<td style="text-align: left;">1000 iterations of a mix of 16 bit
floating point operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float32</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit
floating point operations</td>
</tr>
<tr class="even">
<td style="text-align: left;">float64</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit
floating point operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float80</td>
<td style="text-align: left;">1000 iterations of a mix of 80 bit
floating point operations</td>
</tr>
<tr class="even">
<td style="text-align: left;">float128</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
floating point operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatconversion</td>
<td style="text-align: left;">perform 65536 iterations of floating point
conversions between float, double and long double floating point
variables.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gamma</td>
<td style="text-align: left;">calculate the Euler-Mascheroni constant γ
using the limiting difference between the harmonic series (1 + 1/2 + 1/3
+ 1/4 + 1/5 ... + 1/n) and the natural logarithm ln(n), for n =
80000.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gcd</td>
<td style="text-align: left;">compute GCD of integers</td>
</tr>
<tr class="even">
<td style="text-align: left;">gray</td>
<td style="text-align: left;">calculate binary to gray code and gray
code back to binary for integers from 0 to 65535</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hamming</td>
<td style="text-align: left;">compute Hamming H(8,4) codes on 262144
lots of 4 bit data. This turns 4 bit data into 8 bit Hamming code
containing 4 parity bits. For data bits d1..d4, parity bits are computed
as: p1 = d2 + d3 + d4 p2 = d1 + d3 + d4 p3 = d1 + d2 + d4 p4 = d1 + d2 +
d3</td>
</tr>
<tr class="even">
<td style="text-align: left;">hanoi</td>
<td style="text-align: left;">solve a 21 disc Towers of Hanoi stack
using the recursive solution</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hyperbolic</td>
<td style="text-align: left;">compute sinh(θ) × cosh(θ) + sinh(2θ) +
cosh(3θ) for float, double and long double hyperbolic sine and cosine
functions where θ = 0 to 2π in 1500 steps</td>
</tr>
<tr class="even">
<td style="text-align: left;">idct</td>
<td style="text-align: left;">8 × 8 IDCT (Inverse Discrete Cosine
Transform).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int8</td>
<td style="text-align: left;">1000 iterations of a mix of 8 bit integer
operations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int16</td>
<td style="text-align: left;">1000 iterations of a mix of 16 bit integer
operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit integer
operations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit integer
operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer operations (GCC only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32float</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit integer
and floating point operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32double</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit integer
and double precision floating point operations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32longdouble</td>
<td style="text-align: left;">1000 iterations of a mix of 32 bit integer
and long double precision floating point operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int64float</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit integer
and floating point operations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64double</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit integer
and double precision floating point operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int64longdouble</td>
<td style="text-align: left;">1000 iterations of a mix of 64 bit integer
and long double precision floating point operations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int128float</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and floating point operations (GCC only).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128double</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and double precision floating point operations (GCC only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">int128longdouble</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and long double precision floating point operations (GCC
only).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128decimal32</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and 32 bit decimal floating point operations (GCC only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">int128decimal64</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and 64 bit decimal floating point operations (GCC only).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128decimal128</td>
<td style="text-align: left;">1000 iterations of a mix of 128 bit
integer and 128 bit decimal floating point operations (GCC only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">intconversion</td>
<td style="text-align: left;">perform 65536 iterations of integer
conversions between int16, int32 and int64 variables.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ipv4checksum</td>
<td style="text-align: left;">compute 1024 rounds of the 16 bit ones'
complement IPv4 checksum.</td>
</tr>
<tr class="even">
<td style="text-align: left;">jmp</td>
<td style="text-align: left;">Simple unoptimised compare &gt;, &lt;, ==
and jmp branching.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lfsr32</td>
<td style="text-align: left;">16384 iterations of a 32 bit Galois linear
feedback shift register using the polynomial x↑32 + x↑31 + x↑29 + x + 1.
This generates a ring of 2↑32 - 1 unique values (all 32 bit values
except for 0).</td>
</tr>
<tr class="even">
<td style="text-align: left;">ln2</td>
<td style="text-align: left;">compute ln(2) based on series: 1 - 1/2 +
1/3 - 1/4 + 1/5 - 1/6 ...</td>
</tr>
<tr class="odd">
<td style="text-align: left;">logmap</td>
<td style="text-align: left;">16384 iterations computing chaotic double
precision values using the logistic map Χn+1 = r × Χn × (1 - Χn) where r
&gt; ≈ 3.56994567</td>
</tr>
<tr class="even">
<td style="text-align: left;">longdouble</td>
<td style="text-align: left;">1000 iterations of a mix of long double
precision floating point operations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">loop</td>
<td style="text-align: left;">simple empty loop.</td>
</tr>
<tr class="even">
<td style="text-align: left;">matrixprod</td>
<td style="text-align: left;">matrix product of two 128 × 128 matrices
of double floats. Testing on 64 bit x86 hardware shows that this is
provides a good mix of memory, cache and floating point operations and
is probably the best CPU method to use to make a CPU run hot.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">nsqrt</td>
<td style="text-align: left;">compute sqrt() of long doubles using
Newton-Raphson.</td>
</tr>
<tr class="even">
<td style="text-align: left;">omega</td>
<td style="text-align: left;">compute the omega constant defined by Ωe↑Ω
= 1 using efficient iteration of Ωn+1 = (1 + Ωn) / (1 + e↑Ωn).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">parity</td>
<td style="text-align: left;">compute parity using various methods from
the Standford Bit Twiddling Hacks. Methods employed are: the naïve way,
the naïve way with the Brian Kernigan bit counting optimisation, the
multiply way, the parallel way, the lookup table ways (2 variations) and
using the __builtin_parity function.</td>
</tr>
<tr class="even">
<td style="text-align: left;">phi</td>
<td style="text-align: left;">compute the Golden Ratio ϕ using
series.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pi</td>
<td style="text-align: left;">compute π using the Srinivasa Ramanujan
fast convergence algorithm.</td>
</tr>
<tr class="even">
<td style="text-align: left;">prime</td>
<td style="text-align: left;">find the first 10000 prime numbers using a
slightly optimised brute force naïve trial division search.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">psi</td>
<td style="text-align: left;">compute ψ (the reciprocal Fibonacci
constant) using the sum of the reciprocals of the Fibonacci
numbers.</td>
</tr>
<tr class="even">
<td style="text-align: left;">queens</td>
<td style="text-align: left;">compute all the solutions of the classic 8
queens problem for board sizes 1..11.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rand</td>
<td style="text-align: left;"><p>16384 iterations of rand(), where rand
is the MWC pseudo random number generator. The MWC random function
concatenates two 16 bit multiply-with-carry generators: x(n) = 36969 ×
x(n - 1) + carry, y(n) = 18000 × y(n - 1) + carry mod 2 ↑ 16</p>
<p>and has period of around 2 ↑ 60.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">rand48</td>
<td style="text-align: left;">16384 iterations of drand48(3) and
lrand48(3).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rgb</td>
<td style="text-align: left;">convert RGB to YUV and back to RGB (CCIR
601).</td>
</tr>
<tr class="even">
<td style="text-align: left;">sieve</td>
<td style="text-align: left;">find the first 10000 prime numbers using
the sieve of Eratosthenes.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">stats</td>
<td style="text-align: left;">calculate minimum, maximum, arithmetic
mean, geometric mean, harmoninc mean and standard deviation on 250
randomly generated positive double precision values.</td>
</tr>
<tr class="even">
<td style="text-align: left;">sqrt</td>
<td style="text-align: left;">compute sqrt(rand()), where rand is the
MWC pseudo random number generator.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">trig</td>
<td style="text-align: left;">compute sin(θ) × cos(θ) + sin(2θ) +
cos(3θ) for float, double and long double sine and cosine functions
where θ = 0 to 2π in 1500 steps.</td>
</tr>
<tr class="even">
<td style="text-align: left;">union</td>
<td style="text-align: left;">perform integer arithmetic on a mix of bit
fields in a C union. This exercises how well the compiler and CPU can
perform integer bit field loads and stores.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">zeta</td>
<td style="text-align: left;">compute the Riemann Zeta function ζ(s) for
s = 2.0..10.0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note that some of these methods try to exercise the CPU with
computations found in some real world use cases. However, the code has
not been optimised on a per-architecture basis, so may be a sub-optimal
compared to hand-optimised code used in some applications. They do try
to represent the typical instruction mixes found in these use cases.</p>
</blockquote>
<dl>
<dt><strong>--cpu-old-metrics</strong></dt>
<dd>
<p>as of version V0.14.02 the cpu stressor now normalizes each of the
cpu stressor method bogo-op counters to try and ensure a similar bogo-op
rate for all the methods to avoid the shorter running (and faster)
methods from skewing the bogo-op rates when using the default "all"
method. This is based on a reference Intel i5-8350U processor and hence
the bogo-ops normalizing factors will be skew somewhat on different
CPUs, but so significantly as the original bogo-op counter rates. To
disable the normalization and fall back to the original metrics, use
this option.</p>
</dd>
<dt><strong>--cpu-ops N</strong></dt>
<dd>
<p>stop cpu stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU onlining stressor</strong></dt>
<dd>
<p><strong>--cpu-online N</strong> start N workers that put randomly
selected CPUs offline and online. This Linux only stressor requires root
privilege to perform this action. By default the first CPU (CPU 0) is
never offlined as this has been found to be problematic on some systems
and can result in a shutdown.</p>
<dl>
<dt><strong>--cpu-online-affinity</strong></dt>
<dd>
<p>move the stressor worker to the CPU that will be next offlined.</p>
</dd>
<dt><strong>--cpu-online-all</strong></dt>
<dd>
<p>The default is to never offline the first CPU. This option will
offline and online all the CPUs including CPU 0. This may cause some
systems to shutdown.</p>
</dd>
<dt><strong>--cpu-online-ops N</strong></dt>
<dd>
<p>stop after offline/online operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Crypt stressor</strong></dt>
<dd>
<p><strong>--crypt N</strong> start N workers that encrypt a 16
character random password using crypt(3). The password is encrypted
using MD5, SHA-256 and SHA-512 encryption methods.</p>
<dl>
<dt><strong>--crypt-ops N</strong></dt>
<dd>
<p>stop after N bogo encryption operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Cyclic stressor</strong></dt>
<dd>
<p><strong>--cyclic N</strong> start N workers that exercise the real
time FIFO or Round Robin schedulers with cyclic nanosecond sleeps.
Normally one would just use 1 worker instance with this stressor to get
reliable statistics. By default this stressor measures the first 10
thousand latencies and calculates the mean, mode, minimum, maximum
latencies along with various latency percentiles for the just the first
cyclic stressor instance. One has to run this stressor with CAP_SYS_NICE
capability to enable the real time scheduling policies. The FIFO
scheduling policy is the default.</p>
<dl>
<dt><strong>--cyclic-dist N</strong></dt>
<dd>
<p>calculate and print a latency distribution with the interval of N
nanoseconds. This is helpful to see where the latencies are
clustering.</p>
</dd>
<dt><strong>--cyclic-method [ clock_ns | itimer | poll | posix_ns |
pselect | usleep ]</strong></dt>
<dd>
<p>specify the cyclic method to be used, the default is clock_ns. The
available cyclic methods are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">clock_ns</td>
<td style="text-align: left;">sleep for the specified time using the
clock_nanosleep(2) high resolution nanosleep and the CLOCK_REALTIME real
time clock.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">itimer</td>
<td style="text-align: left;">wakeup a paused process with a
CLOCK_REALTIME itimer signal.</td>
</tr>
<tr class="even">
<td style="text-align: left;">poll</td>
<td style="text-align: left;">delay for the specified time using a poll
delay loop that checks for time changes using clock_gettime(2) on the
CLOCK_REALTIME clock.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">posix_ns</td>
<td style="text-align: left;">sleep for the specified time using the
POSIX nanosleep(2) high resolution nanosleep.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pselect</td>
<td style="text-align: left;">sleep for the specified time using
pselect(2) with null file descriptors.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">usleep</td>
<td style="text-align: left;">sleep to the nearest microsecond using
usleep(2).</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--cyclic-ops N</strong></dt>
<dd>
<p>stop after N sleeps.</p>
</dd>
<dt><strong>--cyclic-policy [ fifo | rr ]</strong></dt>
<dd>
<p>specify the desired real time scheduling policy, ff (first-in,
first-out) or rr (round-robin).</p>
</dd>
<dt><strong>--cyclic-prio P</strong></dt>
<dd>
<p>specify the scheduling priority P. Range from 1 (lowest) to 100
(highest).</p>
</dd>
<dt><strong>--cyclic-samples N</strong></dt>
<dd>
<p>measure N samples. Range from 1 to 100000000 samples.</p>
</dd>
<dt><strong>--cyclic-sleep N</strong></dt>
<dd>
<p>sleep for N nanoseconds per test cycle using clock_nanosleep(2) with
the CLOCK_REALTIME timer. Range from 1 to 1000000000 nanoseconds.</p>
</dd>
</dl>
</dd>
<dt><strong>Daemon stressor</strong></dt>
<dd>
<p><strong>--daemon N</strong> start N workers that each create a daemon
that dies immediately after creating another daemon and so on. This
effectively works through the process table with short lived processes
that do not have a parent and are waited for by init. This puts pressure
on init to do rapid child reaping. The daemon processes perform the
usual mix of calls to turn into typical UNIX daemons, so this
artificially mimics very heavy daemon system stress.</p>
<dl>
<dt><strong>--daemon-ops N</strong></dt>
<dd>
<p>stop daemon workers after N daemons have been created.</p>
</dd>
<dt><strong>--daemon-wait</strong></dt>
<dd>
<p>wait for daemon child processes rather than let init handle the
waiting. Enabling this option will reduce the daemon fork rate because
of the synchronous wait delays.</p>
</dd>
</dl>
</dd>
<dt><strong>Datagram congestion control protocol (DCCP)
stressor</strong></dt>
<dd>
<p><strong>--dccp N</strong> start N workers that send and receive data
using the Datagram Congestion Control Protocol (DCCP) (RFC4340). This
involves a pair of client/server processes performing rapid connect,
send and receives and disconnects on the local host.</p>
<dl>
<dt><strong>--dccp-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is ipv4. Currently ipv4 and
ipv6 are supported.</p>
</dd>
<dt><strong>--dccp-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--dccp-msgs N</strong></dt>
<dd>
<p>send N messages per connect, send/receive, disconnect iteration. The
default is 10000 messages. If N is too small then the rate is throttled
back by the overhead of dccp socket connect and disconnects.</p>
</dd>
<dt><strong>--dccp-port P</strong></dt>
<dd>
<p>start DCCP at port P. For N dccp worker processes, ports P to P - 1
are used.</p>
</dd>
<dt><strong>--dccp-ops N</strong></dt>
<dd>
<p>stop dccp stress workers after N bogo operations.</p>
</dd>
<dt><strong>--dccp-opts [ send | sendmsg | sendmmsg ]</strong></dt>
<dd>
<p>by default, messages are sent using send(2). This option allows one
to specify the sending method using send(2), sendmsg(2) or sendmmsg(2).
Note that sendmmsg is only available for Linux systems that support this
system call.</p>
</dd>
</dl>
</dd>
<dt><strong>Mutex using Dekker algorithm stressor</strong></dt>
<dd>
<p><strong>--dekker N</strong> start N workers that exercises mutex
exclusion between two processes using shared memory with the Dekker
Algorithm. Where possible this uses memory fencing and falls back to
using GCC __sync_synchronize if they are not available. The stressors
contain simple mutex and memory coherency sanity checks.</p>
<dl>
<dt><strong>--dekker-ops N</strong></dt>
<dd>
<p>stop dekker workers after N mutex operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Dentry stressor</strong></dt>
<dd>
<p><strong>-D N, --dentry N</strong> start N workers that create and
remove directory entries. This should create file system meta data
activity. The directory entry names are suffixed by a gray-code encoded
number to try to mix up the hashing of the namespace.</p>
<dl>
<dt><strong>--dentry-ops N</strong></dt>
<dd>
<p>stop denty thrash workers after N bogo dentry operations.</p>
</dd>
<dt><strong>--dentry-order [ forward | reverse | stride | random
]</strong></dt>
<dd>
<p>specify unlink order of dentries, can be one of forward, reverse,
stride or random. By default, dentries are unlinked in random order. The
forward order will unlink them from first to last, reverse order will
unlink them from last to first, stride order will unlink them by
stepping around order in a quasi-random pattern and random order will
randomly select one of forward, reverse or stride orders.</p>
</dd>
<dt><strong>--dentries N</strong></dt>
<dd>
<p>create N dentries per dentry thrashing loop, default is 2048.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev stressor</strong></dt>
<dd>
<p><strong>--dev N</strong> start N workers that exercise the /dev
devices. Each worker runs 5 concurrent threads that perform open(2),
fstat(2), lseek(2), poll(2), fcntl(2), mmap(2), munmap(2), fsync(2) and
close(2) on each device. Note that watchdog devices are not
exercised.</p>
<dl>
<dt><strong>--dev-file filename</strong></dt>
<dd>
<p>specify the device file to exercise, for example, /dev/null. By
default the stressor will work through all the device files it can fine,
however, this option allows a single device file to be exercised.</p>
</dd>
<dt><strong>--dev-ops N</strong></dt>
<dd>
<p>stop dev workers after N bogo device exercising operations.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev/shm stressor</strong></dt>
<dd>
<p><strong>--dev-shm N</strong> start N workers that fallocate large
files in /dev/shm and then mmap these into memory and touch all the
pages. This exercises pages being moved to/from the buffer cache. Linux
only.</p>
<dl>
<dt><strong>--dev-shm-ops N</strong></dt>
<dd>
<p>stop after N bogo allocation and mmap /dev/shm operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Directories stressor</strong></dt>
<dd>
<p><strong>--dir N</strong> start N workers that create, rename and
remove directories using mkdir, rename and rmdir.</p>
<dl>
<dt><strong>--dir-dirs N</strong></dt>
<dd>
<p>exercise dir on N directories. The default is 8192 directories, this
allows 64 to 65536 directories to be used instead.</p>
</dd>
<dt><strong>--dir-ops N</strong></dt>
<dd>
<p>stop directory thrash workers after N bogo directory operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Deep directories stressor</strong></dt>
<dd>
<p><strong>--dirdeep N</strong> start N workers that create a
depth-first tree of directories to a maximum depth as limited by
PATH_MAX or ENAMETOOLONG (which ever occurs first). By default, each
level of the tree contains one directory, but this can be increased to a
maximum of 10 sub-trees using the --dirdeep-dir option. To stress inode
creation, a symlink and a hardlink to a file at the root of the tree is
created in each level.</p>
<dl>
<dt><strong>--dirdeep-bytes N</strong></dt>
<dd>
<p>allocated file size, the default is 0. One can specify the size as %
of free space on the file system or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g. Used in conjunction with the
--dirdeep-files option.</p>
</dd>
<dt><strong>--dirdeep-dirs N</strong></dt>
<dd>
<p>create N directories at each tree level. The default is just 1 but
can be increased to a maximum of 36 per level.</p>
</dd>
<dt><strong>--dirdeep-files N</strong></dt>
<dd>
<p>create N files at each tree level. The default is 0 with the file
size specified by the --dirdeep-bytes option.</p>
</dd>
<dt><strong>--dirdeep-inodes N</strong></dt>
<dd>
<p>consume up to N inodes per dirdeep stressor while creating
directories and links. The value N can be the number of inodes or a
percentage of the total available free inodes on the filesystem being
used.</p>
</dd>
<dt><strong>--dirdeep-ops N</strong></dt>
<dd>
<p>stop directory depth workers after N bogo directory operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Maximum files creation in a directory stressor</strong></dt>
<dd>
<p><strong>--dirmany N</strong> start N stressors that create as many
files in a directory as possible and then remove them. The file creation
phase stops when an error occurs (for example, out of inodes, too many
files, quota reached, etc.) and then the files are removed. This cycles
until the run time is reached or the file creation count bogo-ops metric
is reached. This is a much faster and light weight directory exercising
stressor compared to the dentry stressor.</p>
<dl>
<dt><strong>--dirmany-bytes N</strong></dt>
<dd>
<p>allocated file size, the default is 0. One can specify the size as %
of free space on the file system or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--dirmany-ops N</strong></dt>
<dd>
<p>stop dirmany stressors after N empty files have been created.</p>
</dd>
</dl>
</dd>
<dt><strong>Dnotify stressor</strong></dt>
<dd>
<p><strong>--dnotify N</strong> start N workers performing file system
activities such as making/deleting files/directories, renaming files,
etc. to stress exercise the various dnotify events (Linux only).</p>
<dl>
<dt><strong>--dnotify-ops N</strong></dt>
<dd>
<p>stop inotify stress workers after N dnotify bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Dup stressor</strong></dt>
<dd>
<p><strong>--dup N</strong> start N workers that perform dup(2) and then
close(2) operations on /dev/zero. The maximum opens at one time is
system defined, so the test will run up to this maximum, or 65536 open
file descriptors, which ever comes first.</p>
<dl>
<dt><strong>--dup-ops N</strong></dt>
<dd>
<p>stop the dup stress workers after N bogo open operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Dynamic libraries loading stressor</strong></dt>
<dd>
<p><strong>--dynlib N</strong> start N workers that dynamically load and
unload various shared libraries. This exercises memory mapping and
dynamic code loading and symbol lookups. See dlopen(3) for more details
of this mechanism.</p>
<dl>
<dt><strong>--dynlib-ops N</strong></dt>
<dd>
<p>stop workers after N bogo load/unload cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>Eigen C++ matrix library stressor</strong></dt>
<dd>
<p><strong>--eigen N</strong> start N workers that exercise the Eigen
C++ matrix library for 2D matrix addition, multiplication, determinant,
inverse and transpose operations on long double, double and float
matrices. This currently is only available for gcc/g++ builds.</p>
<dl>
<dt><strong>--eigen-method method</strong></dt>
<dd>
<p>select the floating point method to use, available methods are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the Eigen 2D matrix
operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">add-longdouble</td>
<td style="text-align: left;">addition of two matrices of long double
floating point values T{ add-doublee T{ addition of two matrices of
double floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">add-float</td>
<td style="text-align: left;">addition of two matrices of floating point
values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">determinant-longdouble</td>
<td style="text-align: left;">determinant of matrix of long double
floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">determinant-double</td>
<td style="text-align: left;">determinant of matrix of double floating
point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">determinant-float</td>
<td style="text-align: left;">determinant of matrix of floating point
values</td>
</tr>
<tr class="even">
<td style="text-align: left;">inverse-longdouble</td>
<td style="text-align: left;">inverse of matrix of long double floating
point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">inverse-double</td>
<td style="text-align: left;">inverse of matrix of double floating point
values</td>
</tr>
<tr class="even">
<td style="text-align: left;">inverse-float</td>
<td style="text-align: left;">inverse of matrix of floating point
values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">multiply-longdouble</td>
<td style="text-align: left;">mutiplication of two matrices of long
double floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">multiply-doublee</td>
<td style="text-align: left;">mutiplication of two matrices of double
floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">multiply-float</td>
<td style="text-align: left;">mutiplication of two matrices of floating
point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">transpose-longdouble</td>
<td style="text-align: left;">transpose of matrix of long double
floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">transpose-double</td>
<td style="text-align: left;">transpose of matrix of double floating
point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">transpose-float</td>
<td style="text-align: left;">transpose of matrix of floating point
values</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--eigen-ops N</strong></dt>
<dd>
<p>stop after N Eigen matrix computations</p>
</dd>
<dt><strong>--eigen-size N</strong></dt>
<dd>
<p>specify the 2D matrix size N × N. The default is a 32 × 32
matrix.</p>
</dd>
</dl>
</dd>
<dt><strong>EFI variables stressor</strong></dt>
<dd>
<p><strong>--efivar N</strong> start N workers that exercise the Linux
/sys/firmware/efi/efivars and /sys/firmware/efi/vars interfaces by
reading the EFI variables. This is a Linux only stress test for
platforms that support the EFI vars interface and may require the
CAP_SYS_ADMIN capability.</p>
<dl>
<dt><strong>--efivar-ops N</strong></dt>
<dd>
<p>stop the efivar stressors after N EFI variable read operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Non-functional system call (ENOSYS) stressor</strong></dt>
<dd>
<p><strong>--enosys N</strong> start N workers that exercise
non-functional system call numbers. This calls a wide range of system
call numbers to see if it can break a system where these are not wired
up correctly. It also keeps track of system calls that exist (ones that
don't return ENOSYS) so that it can focus on purely finding and
exercising non-functional system calls. This stressor exercises system
calls from 0 to __NR_syscalls + 1024, random system calls within
constrained in the ranges of 0 to 2↑8, 2↑16, 2↑24, 2↑32, 2↑40, 2↑48,
2↑56 and 2↑64 bits, high system call numbers and various other bit
patterns to try to get wide coverage. To keep the environment clean,
each system call being tested runs in a child process with reduced
capabilities.</p>
<dl>
<dt><strong>--enosys-ops N</strong></dt>
<dd>
<p>stop after N bogo enosys system call attempts</p>
</dd>
</dl>
</dd>
<dt><strong>Environment variables stressor</strong></dt>
<dd>
<p><strong>--env N</strong> start N workers that creates numerous large
environment variables to try to trigger out of memory conditions using
setenv(3). If ENOMEM occurs then the environment is emptied and another
memory filling retry occurs. The process is restarted if it is killed by
the Out Of Memory (OOM) killer.</p>
<dl>
<dt><strong>--env-ops N</strong></dt>
<dd>
<p>stop after N bogo setenv/unsetenv attempts.</p>
</dd>
</dl>
</dd>
<dt><strong>Epoll stressor</strong></dt>
<dd>
<p><strong>--epoll N</strong> start N workers that perform various
related socket stress activity using epoll_wait(2) to monitor and handle
new connections. This involves client/server processes performing rapid
connect, send/receives and disconnects on the local host. Using epoll
allows a large number of connections to be efficiently handled, however,
this can lead to the connection table filling up and blocking further
socket connections, hence impacting on the epoll bogo op stats. For ipv4
and ipv6 domains, multiple servers are spawned on multiple ports. The
epoll stressor is for Linux only.</p>
<dl>
<dt><strong>--epoll-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is unix (aka local). Currently
ipv4, ipv6 and unix are supported.</p>
</dd>
<dt><strong>--epoll-ops N</strong></dt>
<dd>
<p>stop epoll workers after N bogo operations.</p>
</dd>
<dt><strong>--epoll-port P</strong></dt>
<dd>
<p>start at socket port P. For N epoll worker processes, ports P to (P *
4) - 1 are used for ipv4, ipv6 domains and ports P to P - 1 are used for
the unix domain.</p>
</dd>
<dt><strong>--epoll-sockets N</strong></dt>
<dd>
<p>specify the maximum number of concurrently open sockets allowed in
server. Setting a high value impacts on memory usage and may trigger out
of memory conditions.</p>
</dd>
</dl>
</dd>
<dt><strong>Event file descriptor (eventfd) stressor</strong></dt>
<dd>
<p><strong>--eventfd N</strong> start N parent and child worker
processes that read and write 8 byte event messages between them via the
eventfd mechanism (Linux only).</p>
<dl>
<dt><strong>--eventfd-nonblock</strong></dt>
<dd>
<p>enable EFD_NONBLOCK to allow non-blocking on the event file
descriptor. This will cause reads and writes to return with EAGAIN
rather the blocking and hence causing a high rate of polling I/O.</p>
</dd>
<dt><strong>--eventfd-ops N</strong></dt>
<dd>
<p>stop eventfd workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Exec processes stressor</strong></dt>
<dd>
<p><strong>--exec N</strong> start N workers continually forking
children that exec stress-ng and then exit almost immediately. If a
system has pthread support then 1 in 4 of the exec's will be from inside
a pthread to exercise exec'ing from inside a pthread context.</p>
<dl>
<dt><strong>--exec-fork-method [ clone | fork | rfork | spawn | vfork
]</strong></dt>
<dd>
<p>select the process creation method using clone(2), fork(2), BSD
rfork(2), posix_spawn(3) or vfork(2). Note that vfork will only exec
programs using execve due to the constraints on the shared stack between
the parent and the child process.</p>
</dd>
<dt><strong>--exec-max P</strong></dt>
<dd>
<p>create P child processes that exec stress-ng and then wait for them
to exit per iteration. The default is 4096; higher values may create
many temporary zombie processes that are waiting to be reaped. One can
potentially fill up the process table using high values for --exec-max
and --exec.</p>
</dd>
<dt><strong>--exec-method [ all | execve | execveat ]</strong></dt>
<dd>
<p>select the exec system call to use; all will perform a random choice
between execve(2) and execveat(2), execve will use execve(2) and
execveat will use execveat(2) if it is available.</p>
</dd>
<dt><strong>--exec-no-pthread</strong></dt>
<dd>
<p>do not use pthread_create(3).</p>
</dd>
<dt><strong>--exec-ops N</strong></dt>
<dd>
<p>stop exec stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Exiting pthread groups stressor</strong></dt>
<dd>
<p><strong>--exit-group N</strong> start N workers that create 16
pthreads and terminate the pthreads and the controlling child process
using exit_group(2). (Linux only stressor).</p>
<dl>
<dt><strong>--exit-group-ops N</strong></dt>
<dd>
<p>stop after N iterations of pthread creation and deletion loops.</p>
</dd>
</dl>
</dd>
<dt><strong>Factorization of large integers stressor</strong></dt>
<dd>
<p><strong>--factor N</strong> start N workers that factorize large
integers using the GNU Multiple Precision Arithmetic Library. Randomized
values to be factorized are computed so that an N digit value is
comprised of about 0.4 × N random factors, for N &gt; 100. The default
number of digits in the value to be factorized is 10.</p>
<dl>
<dt><strong>--factor-digits N</strong></dt>
<dd>
<p>select the number of digits in the values to be factorized. Range 8
to 100000000 digits, default is 10.</p>
</dd>
<dt><strong>--factor-ops N</strong></dt>
<dd>
<p>stop after N factorizations.</p>
</dd>
</dl>
</dd>
<dt><strong>File space allocation (fallocate) stressor</strong></dt>
<dd>
<p><strong>-F N, --fallocate N</strong> start N workers continually
fallocating (preallocating file space) and ftruncating (file truncating)
temporary files. If the file is larger than the free space, fallocate
will produce an ENOSPC error which is ignored by this stressor.</p>
<dl>
<dt><strong>--fallocate-bytes N</strong></dt>
<dd>
<p>allocated file size, the default is 1 GB. One can specify the size as
% of free space on the file system or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--fallocate-ops N</strong></dt>
<dd>
<p>stop fallocate stress workers after N bogo fallocate operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Filesystem notification (fanotify) stressor</strong></dt>
<dd>
<p><strong>--fanotify N</strong> start N workers performing file system
activities such as creating, opening, writing, reading and unlinking
files to exercise the fanotify event monitoring interface (Linux only).
Each stressor runs a child process to generate file events and a parent
process to read file events using fanotify. Has to be run with
CAP_SYS_ADMIN capability.</p>
<dl>
<dt><strong>--fanotify-ops N</strong></dt>
<dd>
<p>stop fanotify stress workers after N bogo fanotify events.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU branching instruction cache stressor</strong></dt>
<dd>
<p><strong>--far-branch N</strong> start N workers that exercise calls
to tens of thousands of functions that are relatively far from the
caller. All functions are 1 op instructions that return to the caller.
The functions are placed in pages that are memory mapped with a wide
spread of fixed virtual addresses. Function calls are pre-shuffled to
create a randomized mix of addresses to call. This stresses the
instruction cache and any instruction TLBs.</p>
<dl>
<dt><strong>--far-branch-ops N</strong></dt>
<dd>
<p>stop after N far branch bogo-ops. One full cycle of calling all the
tens of thousands of functions equates to one bogo-op.</p>
</dd>
<dt><strong>--far-branch-pages N</strong></dt>
<dd>
<p>specify the number of pages to allocate for far branch functions. The
number for functions per page depends on the processor architecture, for
example, x86 will have 4096 x 1 byte return instructions per 4K page,
where as SPARC64 will have only 512 x 8 byte return instructions per 4K
page.</p>
</dd>
</dl>
</dd>
<dt><strong>Page fault stressor</strong></dt>
<dd>
<p><strong>--fault N</strong> start N workers that generates minor and
major page faults.</p>
<dl>
<dt><strong>--fault-ops N</strong></dt>
<dd>
<p>stop the page fault workers after N bogo page fault operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Fcntl stressor</strong></dt>
<dd>
<p><strong>--fcntl N</strong> start N workers that perform fcntl(2)
calls with various commands. The exercised commands (if available) are:
F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETOWN,
F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLK,
F_SETLK, F_SETLKW, F_OFD_GETLK, F_OFD_SETLK and F_OFD_SETLKW.</p>
<dl>
<dt><strong>--fcntl-ops N</strong></dt>
<dd>
<p>stop the fcntl workers after N bogo fcntl operations.</p>
</dd>
</dl>
</dd>
<dt><strong>File extent (fiemap) stressor</strong></dt>
<dd>
<p><strong>--fiemap N</strong> start N workers that each create a file
with many randomly changing extents and has 4 child processes per worker
that gather the extent information using the FS_IOC_FIEMAP ioctl(2).</p>
<dl>
<dt><strong>--fiemap-bytes N</strong></dt>
<dd>
<p>specify the size of the fiemap'd file in bytes. One can specify the
size as % of free space on the file system or in units of Bytes, KBytes,
MBytes and GBytes using the suffix b, k, m or g. Larger files will
contain more extents, causing more stress when gathering extent
information.</p>
</dd>
<dt><strong>--fiemap-ops N</strong></dt>
<dd>
<p>stop after N fiemap bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>FIFO named pipe stressor</strong></dt>
<dd>
<p><strong>--fifo N</strong> start N workers that exercise a named pipe
by transmitting 64 bit integers.</p>
<dl>
<dt><strong>--fifo-data-size N</strong></dt>
<dd>
<p>set the byte size of the fifo write/reads, default is 8, range
8..4096.</p>
</dd>
<dt><strong>--fifo-ops N</strong></dt>
<dd>
<p>stop fifo workers after N bogo pipe write operations.</p>
</dd>
<dt><strong>--fifo-readers N</strong></dt>
<dd>
<p>for each worker, create N fifo reader workers that read the named
pipe using simple blocking reads. Default is 4, range 1..64.</p>
</dd>
</dl>
</dd>
<dt><strong>File I/O control (ioctl) stressor</strong></dt>
<dd>
<p><strong>--file-ioctl N</strong> start N workers that exercise various
file specific ioctl(2) calls. This will attempt to use the FIONBIO,
FIOQSIZE, FIGETBSZ, FIOCLEX, FIONCLEX, FIONBIO, FIOASYNC, FIOQSIZE,
FIFREEZE, FITHAW, FICLONE, FICLONERANGE, FIONREAD, FIONWRITE and
FS_IOC_RESVSP ioctls if these are defined.</p>
<dl>
<dt><strong>--file-ioctl-ops N</strong></dt>
<dd>
<p>stop file-ioctl workers after N file ioctl bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Filename stressor</strong></dt>
<dd>
<p><strong>--filename N</strong> start N workers that exercise file
creation using various length filenames containing a range of allowed
filename characters. This will try to see if it can exceed the file
system allowed filename length was well as test various filename lengths
between 1 and the maximum allowed by the file system.</p>
<dl>
<dt><strong>--filename-ops N</strong></dt>
<dd>
<p>stop filename workers after N bogo filename tests.</p>
</dd>
<dt><strong>--filename-opts opt</strong></dt>
<dd>
<p>use characters in the filename based on option 'opt'. Valid options
are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Option</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">probe</td>
<td style="text-align: left;">default option, probe the file system for
valid allowed characters in a file name and use these</td>
</tr>
<tr class="odd">
<td style="text-align: left;">posix</td>
<td style="text-align: left;">use characters as specified by The Open
Group Base Specifications Issue 7, POSIX.1-2008, 3.278 Portable Filename
Character Set</td>
</tr>
<tr class="even">
<td style="text-align: left;">ext</td>
<td style="text-align: left;">use characters allowed by the ext2, ext3,
ext4 file systems, namely any 8 bit character apart from NUL and /</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>File locking (flock) stressor</strong></dt>
<dd>
<p><strong>--flock N</strong> start N workers locking on a single
file.</p>
<dl>
<dt><strong>--flock-ops N</strong></dt>
<dd>
<p>stop flock stress workers after N bogo flock operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Cache flushing stressor</strong></dt>
<dd>
<p><strong>--flush-cache N</strong> start N workers that flush the data
and instruction cache (where possible). Some architectures may not
support cache flushing on either cache, in which case these become
no-ops.</p>
<dl>
<dt><strong>--flush-cache-ops N</strong></dt>
<dd>
<p>stop after N cache flush iterations.</p>
</dd>
</dl>
</dd>
<dt><strong>Fused Multiply/Add floating point operations (fma)
stressor</strong></dt>
<dd>
<p><strong>--fma N</strong> start N workers that exercise single and
double precision floating point multiplication and add operations on
arrays of 512 floating point values. More modern processors (Intel
Haswell, AMD Bulldozer and Piledriver) and modern C compilers these will
be performed by fused-multiply-add (fma3) opcodes. Operations used
are:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">a = a × b + c</td>
</tr>
<tr class="even">
<td style="text-align: left;">a = b × a + c</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a = b × c + a</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--fma-ops N</strong></dt>
<dd>
<p>stop after N bogo-loops of the 3 above operations on 512 single and
double precision floating point numbers.</p>
</dd>
</dl>
</dd>
<dt><strong>Process forking stressor</strong></dt>
<dd>
<p><strong>-f N, --fork N</strong> start N workers continually forking
children that immediately exit.</p>
<dl>
<dt><strong>--fork-max P</strong></dt>
<dd>
<p>create P child processes and then wait for them to exit per
iteration. The default is just 1; higher values will create many
temporary zombie processes that are waiting to be reaped. One can
potentially fill up the process table using high values for --fork-max
and --fork.</p>
</dd>
<dt><strong>--fork-ops N</strong></dt>
<dd>
<p>stop fork stress workers after N bogo operations.</p>
</dd>
<dt><strong>--fork-vm</strong></dt>
<dd>
<p>enable detrimental performance virtual memory advice using madvise on
all pages of the forked process. Where possible this will try to set
every page in the new process with using madvise MADV_MERGEABLE,
MADV_WILLNEED, MADV_HUGEPAGE and MADV_RANDOM flags. Linux only.</p>
</dd>
</dl>
</dd>
<dt><strong>Heavy process forking stressor</strong></dt>
<dd>
<p><strong>--forkheavy N</strong> start N workers that fork child
processes from a parent that has thousands of allocated system
resources. The fork becomes a heavyweight operations as it has to
duplicate the resource references of the parent. Each stressor instance
creates and reaps up to 4096 child processes that are created and reaped
in a first-in first-out manner.</p>
<dl>
<dt><strong>--forkheavy-allocs N</strong></dt>
<dd>
<p>attempt N resource allocation loops per stressor instance. Resources
include pipes, file descriptors, memory mappings, pthreads, timers,
ptys, semaphores, message queues and temporary files. These create
heavyweight processes that are more time expensive to fork from. Default
is 16384.</p>
</dd>
<dt><strong>--forkheavy-mlock</strong></dt>
<dd>
<p>attempt to mlock future allocated pages into memory causing more
memory pressure. If mlock(MCL_FUTURE) is implemented then this will stop
new brk pages from being swapped out.</p>
</dd>
<dt><strong>--forkheavy-ops N</strong></dt>
<dd>
<p>stop after N fork calls.</p>
</dd>
<dt><strong>--forkheavy-procs N</strong></dt>
<dd>
<p>attempt to fork N processes per stressor. The default is 4096
processes.</p>
</dd>
</dl>
</dd>
<dt><strong>Floating point operations stressor</strong></dt>
<dd>
<p><strong>--fp N</strong> start N workers that exercise addition,
multiplication and division operations on a range of floating point
types. For each type, 8 floating point values are operated upon 65536
times in a loop per bogo op.</p>
<dl>
<dt><strong>--fp-method method</strong></dt>
<dd>
<p>select the floating point method to use, available methods are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the following floating
point methods:</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float128add</td>
<td style="text-align: left;">128 bit floating point add</td>
</tr>
<tr class="even">
<td style="text-align: left;">float80add</td>
<td style="text-align: left;">80 bit floating point add</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float64add</td>
<td style="text-align: left;">64 bit floating point add</td>
</tr>
<tr class="even">
<td style="text-align: left;">float32add</td>
<td style="text-align: left;">32 bit binary32 floating point add</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatadd</td>
<td style="text-align: left;">floating point add</td>
</tr>
<tr class="even">
<td style="text-align: left;">doubleadd</td>
<td style="text-align: left;">double precision floating point add</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ldoubleadd</td>
<td style="text-align: left;">long double precision floating point
add</td>
</tr>
<tr class="even">
<td style="text-align: left;">float128mul</td>
<td style="text-align: left;">128 bit floating point multiply</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float80mul</td>
<td style="text-align: left;">80 bit floating point multiply</td>
</tr>
<tr class="even">
<td style="text-align: left;">float64mul</td>
<td style="text-align: left;">64 bit floating point multiply</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float32mul</td>
<td style="text-align: left;">32 bit binary32 floating point
multiply</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatmul</td>
<td style="text-align: left;">floating point multiply</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublemul</td>
<td style="text-align: left;">double precision floating point
multiply</td>
</tr>
<tr class="even">
<td style="text-align: left;">ldoublemul</td>
<td style="text-align: left;">long double precision floating point
multiply</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float128div</td>
<td style="text-align: left;">128 bit floating point divide</td>
</tr>
<tr class="even">
<td style="text-align: left;">float80div</td>
<td style="text-align: left;">80 bit floating point divide</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float64div</td>
<td style="text-align: left;">64 bit floating point divide</td>
</tr>
<tr class="even">
<td style="text-align: left;">float32div</td>
<td style="text-align: left;">32 bit binary32 floating point divide</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatdiv</td>
<td style="text-align: left;">floating point divide</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublediv</td>
<td style="text-align: left;">double precision floating point
divide</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ldoublediv</td>
<td style="text-align: left;">long double precision floating point
divide</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note that some of these floating point methods may not be available
on some systems.</p>
</blockquote>
<dl>
<dt><strong>--fp-ops N</strong></dt>
<dd>
<p>stop after N floating point bogo ops. Note that bogo-ops are counted
for just standard float, double and long double floating point
types.</p>
</dd>
</dl>
</dd>
<dt><strong>Floating point exception stressor</strong></dt>
<dd>
<p><strong>--fp-error N</strong> start N workers that generate floating
point exceptions. Computations are performed to force and check for the
FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW and FE_UNDERFLOW
exceptions. EDOM and ERANGE errors are also checked.</p>
<dl>
<dt><strong>--fp-error-ops N</strong></dt>
<dd>
<p>stop after N bogo floating point exceptions.</p>
</dd>
</dl>
</dd>
<dt><strong>File punch and hole filling stressor</strong></dt>
<dd>
<p><strong>--fpunch N</strong> start N workers that punch and fill holes
in a 16 MB file using five concurrent processes per stressor exercising
on the same file. Where available, this uses fallocate(2)
FALLOC_FL_KEEP_SIZE, FALLOC_FL_PUNCH_HOLE, FALLOC_FL_ZERO_RANGE,
FALLOC_FL_COLLAPSE_RANGE and FALLOC_FL_INSERT_RANGE to make and fill
holes across the file and breaks it into multiple extents.</p>
<dl>
<dt><strong>--fpunch-ops N</strong></dt>
<dd>
<p>stop fpunch workers after N punch and fill bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>File size limit stressor</strong></dt>
<dd>
<p><strong>--fsize N</strong> start N workers that exercise file size
limits (via setrlimit RLIMIT_FSIZE) with file sizes that are fixed,
random and powers of 2. The files are truncated and allocated to trigger
SIGXFSZ signals.</p>
<dl>
<dt><strong>--fsize-ops N</strong></dt>
<dd>
<p>stop after N bogo file size test iterations.</p>
</dd>
</dl>
</dd>
<dt><strong>File stats (fstat) stressor</strong></dt>
<dd>
<p><strong>--fstat N</strong> start N workers fstat'ing files in a
directory (default is /dev).</p>
<dl>
<dt><strong>--fstat-dir directory</strong></dt>
<dd>
<p>specify the directory to fstat to override the default of /dev. All
the files in the directory will be fstat'd repeatedly.</p>
</dd>
<dt><strong>--fstat-ops N</strong></dt>
<dd>
<p>stop fstat stress workers after N bogo fstat operations.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev/full stressor</strong></dt>
<dd>
<p><strong>--full N</strong> start N workers that exercise /dev/full.
This attempts to write to the device (which should always get error
ENOSPC), to read from the device (which should always return a buffer of
zeros) and to seek randomly on the device (which should always succeed).
(Linux only).</p>
<dl>
<dt><strong>--full-ops N</strong></dt>
<dd>
<p>stop the stress full workers after N bogo I/O operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Function argument passing stressor</strong></dt>
<dd>
<p><strong>--funccall N</strong> start N workers that call functions of
1 through to 9 arguments. By default all functions with a range of
argument types are called, however, this can be changed using the
--funccall-method option. This exercises stack function argument passing
and re-ordering on the stack and in registers.</p>
<dl>
<dt><strong>--funccall-ops N</strong></dt>
<dd>
<p>stop the funccall workers after N bogo function call operations. Each
bogo operation is 1000 calls of functions of 1 through to 9 arguments of
the chosen argument type.</p>
</dd>
<dt><strong>--funccall-method method</strong></dt>
<dd>
<p>specify the method of funccall argument type to be used. The default
is all the types but can be one of bool, uint8, uint16, uint32, uint64,
uint128, float, double, longdouble, cfloat (complex float), cdouble
(complex double), clongdouble (complex long double), float16, float32,
float64, float80, float128, decimal32, decimal64 and decimal128. Note
that some of these types are only available with specific architectures
and compiler versions.</p>
</dd>
</dl>
</dd>
<dt><strong>Function return stressor</strong></dt>
<dd>
<p><strong>--funcret N</strong> start N workers that pass and return by
value various small to large data types.</p>
<dl>
<dt><strong>--funcret-ops N</strong></dt>
<dd>
<p>stop the funcret workers after N bogo function call operations.</p>
</dd>
<dt><strong>--funcret-method method</strong></dt>
<dd>
<p>specify the method of funcret argument type to be used. The default
is uint64_t but can be one of uint8 uint16 uint32 uint64 uint128 float
double longdouble float80 float128 decimal32 decimal64 decimal128
uint8x32 uint8x128 uint64x128.</p>
</dd>
</dl>
</dd>
<dt><strong>Fast mutex (futex) stressor</strong></dt>
<dd>
<p><strong>--futex N</strong> start N workers that rapidly exercise the
futex system call. Each worker has two processes, a futex waiter and a
futex waker. The waiter waits with a very small timeout to stress the
timeout and rapid polled futex waiting. This is a Linux specific stress
option.</p>
<dl>
<dt><strong>--futex-ops N</strong></dt>
<dd>
<p>stop futex workers after N bogo successful futex wait operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Fetching data from kernel stressor</strong></dt>
<dd>
<p><strong>--get N</strong> start N workers that call system calls that
fetch data from the kernel, currently these are: getpid, getppid,
getcwd, getgid, getegid, getuid, getgroups, getpgrp, getpgid,
getpriority, getresgid, getresuid, getrlimit, prlimit, getrusage,
getsid, gettid, getcpu, gettimeofday, uname, adjtimex, sysfs. Some of
these system calls are OS specific.</p>
<dl>
<dt><strong>--get-ops N</strong></dt>
<dd>
<p>stop get workers after N bogo get operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Virtual filesystem directories stressor
(Linux)</strong></dt>
<dd>
<p><strong>--getdent N</strong> start N workers that recursively read
directories /proc, /dev/, /tmp, /sys and /run using getdents and
getdents64 (Linux only).</p>
<dl>
<dt><strong>--getdent-ops N</strong></dt>
<dd>
<p>stop getdent workers after N bogo getdent bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Random data (getrandom) stressor</strong></dt>
<dd>
<p><strong>--getrandom N</strong> start N workers that get 8192 random
bytes from the /dev/urandom pool using the getrandom(2) system call
(Linux) or getentropy(2) (OpenBSD).</p>
<dl>
<dt><strong>--getrandom-ops N</strong></dt>
<dd>
<p>stop getrandom workers after N bogo get operations.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU pipeline and branch prediction stressor</strong></dt>
<dd>
<p><strong>--goto N</strong> start N workers that perform 1024 forward
branches (to next instruction) or backward branches (to previous
instruction) for each bogo operation loop. By default, every 1024
branches the direction is randomly chosen to be forward or backward.
This stressor exercises suboptimal pipelined execution and branch
prediction logic.</p>
<dl>
<dt><strong>--goto-direction [ forward | backward | random
]</strong></dt>
<dd>
<p>select the branching direction in the stressor loop, forward for
forward only branching, backward for a backward only branching, random
for a random choice of forward or random branching every 1024
branches.</p>
</dd>
<dt><strong>--goto-ops N</strong></dt>
<dd>
<p>stop goto workers after N bogo loops of 1024 branch instructions.</p>
</dd>
</dl>
</dd>
<dt><strong>2D GPU stressor</strong></dt>
<dd>
<p><strong>--gpu N</strong> start N worker that exercise the GPU. This
specifies a 2-D texture image that allows the elements of an image array
to be read by shaders, and render primitives using an opengl
context.</p>
<dl>
<dt><strong>--gpu-devnode DEVNAME</strong></dt>
<dd>
<p>specify the device node name of the GPU device, the default is
/dev/dri/renderD128.</p>
</dd>
<dt><strong>--gpu-frag N</strong></dt>
<dd>
<p>specify shader core usage per pixel, this sets N loops in the
fragment shader.</p>
</dd>
<dt><strong>--gpu-ops N</strong></dt>
<dd>
<p>stop gpu workers after N render loop operations.</p>
</dd>
<dt><strong>--gpu-tex-size N</strong></dt>
<dd>
<p>specify upload texture N × N, by default this value is 4096 ×
4096.</p>
</dd>
<dt><strong>--gpu-xsize X</strong></dt>
<dd>
<p>use a framebuffer size of X pixels. The default is 256 pixels.</p>
</dd>
<dt><strong>--gpu-ysize Y</strong></dt>
<dd>
<p>use a framebuffer size of Y pixels. The default is 256 pixels.</p>
</dd>
<dt><strong>--gpu-upload N</strong></dt>
<dd>
<p>specify upload texture N times per frame, the default value is 1.</p>
</dd>
</dl>
</dd>
<dt><strong>Handle stressor</strong></dt>
<dd>
<p><strong>--handle N</strong> start N workers that exercise the
name_to_handle_at(2) and open_by_handle_at(2) system calls. (Linux
only).</p>
<dl>
<dt><strong>--handle-ops N</strong></dt>
<dd>
<p>stop after N handle bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>String hashing stressor</strong></dt>
<dd>
<p><strong>--hash N</strong> start N workers that exercise various
hashing functions. Random strings from 1 to 128 bytes are hashed and the
hashing rate and chi squared is calculated from the number of hashes
performed over a period of time. The chi squared value is the
goodness-of-fit measure, it is the actual distribution of items in hash
buckets versus the expected distribution of items. Typically a chi
squared value of 0.95..1.05 indicates a good hash distribution.</p>
<dl>
<dt><strong>--hash-method method</strong></dt>
<dd>
<p>specify the hashing method to use, by default all the hashing methods
are cycled through. Methods available are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">cycle through all the hashing methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">adler32</td>
<td style="text-align: left;">Mark Adler checksum, a modification of the
Fletcher checksum</td>
</tr>
<tr class="even">
<td style="text-align: left;">coffin</td>
<td style="text-align: left;">xor and 5 bit rotate left hash</td>
</tr>
<tr class="odd">
<td style="text-align: left;">coffin32</td>
<td style="text-align: left;">xor and 5 bit rotate left hash with 32 bit
fetch optimization</td>
</tr>
<tr class="even">
<td style="text-align: left;">crc32c</td>
<td style="text-align: left;">compute CRC32C (Castagnoli CRC32) integer
hash</td>
</tr>
<tr class="odd">
<td style="text-align: left;">djb2a</td>
<td style="text-align: left;">Dan Bernstein hash using the xor
variant</td>
</tr>
<tr class="even">
<td style="text-align: left;">fnv1a</td>
<td style="text-align: left;">FNV-1a Fowler-Noll-Vo hash using the xor
then multiply variant</td>
</tr>
<tr class="odd">
<td style="text-align: left;">jenkin</td>
<td style="text-align: left;">Jenkin's integer hash</td>
</tr>
<tr class="even">
<td style="text-align: left;">kandr</td>
<td style="text-align: left;">Kernighan and Richie's multiply by 31 and
add hash from "The C Programming Language", 2nd Edition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">knuth</td>
<td style="text-align: left;">Donald E. Knuth's hash from "The Art Of
Computer Programming", Volume 3, chapter 6.4</td>
</tr>
<tr class="even">
<td style="text-align: left;">loselose</td>
<td style="text-align: left;">Kernighan and Richie's simple hash from
"The C Programming Language", 1st Edition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mid5</td>
<td style="text-align: left;">xor shift hash of the middle 5 characters
of the string. Designed by Colin Ian King</td>
</tr>
<tr class="even">
<td style="text-align: left;">muladd32</td>
<td style="text-align: left;">simple multiply and add hash using 32 bit
math and xor folding of overflow</td>
</tr>
<tr class="odd">
<td style="text-align: left;">muladd64</td>
<td style="text-align: left;">simple multiply and add hash using 64 bit
math and xor folding of overflow</td>
</tr>
<tr class="even">
<td style="text-align: left;">mulxror32</td>
<td style="text-align: left;">32 bit multiply, xor and rotate right.
Mangles 32 bits where possible. Designed by Colin Ian King</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mulxror64</td>
<td style="text-align: left;">64 bit multiply, xor and rotate right. 64
Bit version of mulxror32</td>
</tr>
<tr class="even">
<td style="text-align: left;">murmur3_32</td>
<td style="text-align: left;">murmur3_32 hash, Austin Appleby's Murmur3
hash, 32 bit variant</td>
</tr>
<tr class="odd">
<td style="text-align: left;">nhash</td>
<td style="text-align: left;">exim's nhash.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pjw</td>
<td style="text-align: left;">a non-cryptographic hash function created
by Peter J. Weinberger of AT&amp;T Bell Labs, used in UNIX ELF object
files</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sdbm</td>
<td style="text-align: left;">sdbm hash as used in the SDBM database and
GNU awk</td>
</tr>
<tr class="even">
<td style="text-align: left;">sedgwick</td>
<td style="text-align: left;">simple hash from Robert Sedgwick's C
programming book</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sobel</td>
<td style="text-align: left;">Justin Sobel's bitwise shift hash</td>
</tr>
<tr class="even">
<td style="text-align: left;">x17</td>
<td style="text-align: left;">multiply by 17 and add. The multiplication
can be optimized down to a fast right shift by 4 and add on some
architectures</td>
</tr>
<tr class="odd">
<td style="text-align: left;">xor</td>
<td style="text-align: left;">simple rotate shift and xor of values</td>
</tr>
<tr class="even">
<td style="text-align: left;">xorror32</td>
<td style="text-align: left;">32 bit exclusive-or with right rotate
hash, a fast string hash, designed by Colin Ian King</td>
</tr>
<tr class="odd">
<td style="text-align: left;">xorror64</td>
<td style="text-align: left;">64 bit version of xorror32</td>
</tr>
<tr class="even">
<td style="text-align: left;">xxhash</td>
<td style="text-align: left;">the "Extremely fast" hash in non-streaming
mode</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--hash-ops N</strong></dt>
<dd>
<p>stop after N hashing rounds</p>
</dd>
</dl>
</dd>
<dt><strong>File-system stressor</strong></dt>
<dd>
<p><strong>-d N, --hdd N</strong> start N workers continually writing,
reading and removing temporary files. The default mode is to stress test
sequential writes and reads. With the --aggressive option enabled
without any --hdd-opts options the hdd stressor will work through all
the --hdd-opt options one by one to cover a range of I/O options.</p>
<dl>
<dt><strong>--hdd-bytes N</strong></dt>
<dd>
<p>write N bytes for each hdd process, the default is 1 GB. One can
specify the size as % of free space on the file system or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--hdd-opts list</strong></dt>
<dd>
<p>specify various stress test options as a comma separated list.
Options are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Option</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">direct</td>
<td style="text-align: left;">try to minimize cache effects of the I/O.
File I/O writes are performed directly from user space buffers and
synchronous transfer is also attempted. To guarantee synchronous I/O,
also use the sync option.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dsync</td>
<td style="text-align: left;">ensure output has been transferred to
underlying hardware and file metadata has been updated (using the
O_DSYNC open flag). This is equivalent to each write(2) being followed
by a call to fdatasync(2). See also the fdatasync option.</td>
</tr>
<tr class="even">
<td style="text-align: left;">fadv-dontneed</td>
<td style="text-align: left;">advise kernel to expect the data will not
be accessed in the near future.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fadv-noreuse</td>
<td style="text-align: left;">advise kernel to expect the data to be
accessed only once.</td>
</tr>
<tr class="even">
<td style="text-align: left;">fadv-normal</td>
<td style="text-align: left;">advise kernel there are no explicit access
pattern for the data. This is the default advice assumption.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fadv-rnd</td>
<td style="text-align: left;">advise kernel to expect random access
patterns for the data.</td>
</tr>
<tr class="even">
<td style="text-align: left;">fadv-seq</td>
<td style="text-align: left;">advise kernel to expect sequential access
patterns for the data.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fadv-willneed</td>
<td style="text-align: left;">advise kernel to expect the data to be
accessed in the near future.</td>
</tr>
<tr class="even">
<td style="text-align: left;">fsync</td>
<td style="text-align: left;">flush all modified in-core data after each
write to the output device using an explicit fsync(2) call.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fdatasync</td>
<td style="text-align: left;">similar to fsync, but do not flush the
modified metadata unless metadata is required for later data reads to be
handled correctly. This uses an explicit fdatasync(2) call.</td>
</tr>
<tr class="even">
<td style="text-align: left;">iovec</td>
<td style="text-align: left;">use readv/writev multiple buffer I/Os
rather than read/write. Instead of 1 read/write operation, the buffer is
broken into an iovec of 16 buffers.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">noatime</td>
<td style="text-align: left;">do not update the file last access
timestamp, this can reduce metadata writes.</td>
</tr>
<tr class="even">
<td style="text-align: left;">sync</td>
<td style="text-align: left;">ensure output has been transferred to
underlying hardware (using the O_SYNC open flag). This is equivalent to
a each write(2) being followed by a call to fsync(2). See also the fsync
option.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rd-rnd</td>
<td style="text-align: left;">read data randomly. By default, written
data is not read back, however, this option will force it to be read
back randomly.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rd-seq</td>
<td style="text-align: left;">read data sequentially. By default,
written data is not read back, however, this option will force it to be
read back sequentially.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">syncfs</td>
<td style="text-align: left;">write all buffered modifications of file
metadata and data on the filesystem that contains the hdd worker
files.</td>
</tr>
<tr class="even">
<td style="text-align: left;">utimes</td>
<td style="text-align: left;">force update of file timestamp which may
increase metadata writes.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">wr-rnd</td>
<td style="text-align: left;">write data randomly. The wr-seq option
cannot be used at the same time.</td>
</tr>
<tr class="even">
<td style="text-align: left;">wr-seq</td>
<td style="text-align: left;">write data sequentially. This is the
default if no write modes are specified.</td>
</tr>
</tbody>
</table>
<p>Note that some of these options are mutually exclusive, for example,
there can be only one method of writing or reading. Also, fadvise flags
may be mutually exclusive, for example fadv-willneed cannot be used with
fadv-dontneed.</p>
<dl>
<dt><strong>--hdd-ops N</strong></dt>
<dd>
<p>stop hdd stress workers after N bogo operations.</p>
</dd>
<dt><strong>--hdd-write-size N</strong></dt>
<dd>
<p>specify size of each write in bytes. Size can be from 1 byte to
4MB.</p>
</dd>
</dl>
</dd>
<dt><strong>BSD heapsort stressor</strong></dt>
<dd>
<p><strong>--heapsort N</strong> start N workers that sort 32 bit
integers using the BSD heapsort.</p>
<dl>
<dt><strong>--heapsort-method [ heapsort-libc | heapsort-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of heapsort or an optimized
implementation of heapsort. The default is the libc implementation if it
is available.</p>
</dd>
<dt><strong>--heapsort-ops N</strong></dt>
<dd>
<p>stop heapsort stress workers after N bogo heapsorts.</p>
</dd>
<dt><strong>--heapsort-size N</strong></dt>
<dd>
<p>specify number of 32 bit integers to sort, default is 262144 (256 ×
1024).</p>
</dd>
</dl>
</dd>
<dt><strong>High resolution timer stressor</strong></dt>
<dd>
<p><strong>--hrtimers N</strong> start N workers that exercise high
resolution times at a high frequency. Each stressor starts 32 processes
that run with random timer intervals of 0..499999 nanoseconds. Running
this stressor with appropriate privilege will run these with the
SCHED_RR policy.</p>
<dl>
<dt><strong>--hrtimers-adjust</strong></dt>
<dd>
<p>enable automatic timer rate adjustment to try to maximize the hrtimer
frequency. The signal rate is measured every 0.1 seconds and the hrtimer
delay is adjusted to try and set the optimal hrtimer delay to generate
the highest hrtimer rates.</p>
</dd>
<dt><strong>--hrtimers-ops N</strong></dt>
<dd>
<p>stop hrtimers stressors after N timer event bogo operations</p>
</dd>
</dl>
</dd>
<dt><strong>Hashtable searching (hsearch) stressor</strong></dt>
<dd>
<p><strong>--hsearch N</strong> start N workers that search a 80% full
hash table using hsearch(3). By default, there are 8192 elements
inserted into the hash table. This is a useful method to exercise access
of memory and processor cache.</p>
<dl>
<dt><strong>--hsearch-method [ hsearch-libc | hsearch-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of hsearch or a slightly
optimized non-libc implementation of hsearch. The default is the libc
implementation if it exists, otherwise the non-libc version.</p>
</dd>
<dt><strong>--hsearch-ops N</strong></dt>
<dd>
<p>stop the hsearch workers after N bogo hsearch operations are
completed.</p>
</dd>
<dt><strong>--hsearch-size N</strong></dt>
<dd>
<p>specify the number of hash entries to be inserted into the hash
table. Size can be from 1K to 4M.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU instruction cache load stressor</strong></dt>
<dd>
<p><strong>--icache N</strong> start N workers that stress the
instruction cache by forcing instruction cache reloads.</p>
<dl>
<dt><strong>--icache-ops N</strong></dt>
<dd>
<p>stop the icache workers after N bogo icache operations are
completed.</p>
</dd>
</dl>
</dd>
<dt><strong>ICMP flooding stressor</strong></dt>
<dd>
<p><strong>--icmp-flood N</strong> start N workers that flood localhost
with randonly sized ICMP ping packets. This stressor requires the
CAP_NET_RAW capbility.</p>
<dl>
<dt><strong>--icmp-flood-ops N</strong></dt>
<dd>
<p>stop icmp flood workers after N ICMP ping packets have been sent.</p>
</dd>
</dl>
</dd>
<dt><strong>Idle pages stressor (Linux)</strong></dt>
<dd>
<p><strong>--idle-scan N</strong> start N workers that scan the idle
page bitmap across a range of physical pages. This sets and checks for
idle pages via the idle page tracking interface
/sys/kernel/mm/page_idle/bitmap. This is for Linux only.</p>
<dl>
<dt><strong>--idle-scan-ops N</strong></dt>
<dd>
<p>stop after N bogo page scan operations. Currently one bogo page scan
operation is equivalent to setting and checking 64 physical pages.</p>
</dd>
<dt><strong>--idle-page N</strong></dt>
<dd>
<p>start N workers that walks through every page exercising the Linux
/sys/kernel/mm/page_idle/bitmap interface. Requires CAP_SYS_RESOURCE
capability.</p>
</dd>
<dt><strong>--idle-page-ops N</strong></dt>
<dd>
<p>stop after N bogo idle page operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Inode ioctl flags stressor</strong></dt>
<dd>
<p><strong>--inode-flags N</strong> start N workers that exercise inode
flags using the FS_IOC_GETFLAGS and FS_IOC_SETFLAGS ioctl(2). This
attempts to apply all the available inode flags onto a directory and
file even if the underlying file system may not support these flags
(errors are just ignored). Each worker runs 4 threads that exercise the
flags on the same directory and file to try to force races. This is a
Linux only stressor, see ioctl_iflags(2) for more details.</p>
<dl>
<dt><strong>--inode-flags-ops N</strong></dt>
<dd>
<p>stop the inode-flags workers after N ioctl flag setting attempts.</p>
</dd>
</dl>
</dd>
<dt><strong>Inotify stressor</strong></dt>
<dd>
<p><strong>--inotify N</strong> start N workers performing file system
activities such as making/deleting files/directories, moving files, etc.
to stress exercise the various inotify events (Linux only).</p>
<dl>
<dt><strong>--inotify-ops N</strong></dt>
<dd>
<p>stop inotify stress workers after N inotify bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Data synchronization (sync) stressor</strong></dt>
<dd>
<p><strong>-i N, --io N</strong> start N workers continuously calling
sync(2) to commit buffer cache to disk. This can be used in conjunction
with the --hdd stressor. This is a legacy stressor that is compatible
with the original stress tool.</p>
<dl>
<dt><strong>--io-ops N</strong></dt>
<dd>
<p>stop io stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>IO mixing stressor</strong></dt>
<dd>
<p><strong>--iomix N</strong> start N workers that perform a mix of
sequential, random and memory mapped read/write operations as well as
random copy file read/writes, forced sync'ing and (if run as root) cache
dropping. Multiple child processes are spawned to all share a single
file and perform different I/O operations on the same file.</p>
<dl>
<dt><strong>--iomix-bytes N</strong></dt>
<dd>
<p>write N bytes for each iomix worker process, the default is 1 GB. One
can specify the size as % of free space on the file system or in units
of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--iomix-ops N</strong></dt>
<dd>
<p>stop iomix stress workers after N bogo iomix I/O operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Ioport stressor (x86 Linux)</strong></dt>
<dd>
<p><strong>--ioport N</strong> start N workers than perform bursts of 16
reads and 16 writes of ioport 0x80 (x86 Linux systems only). I/O
performed on x86 platforms on port 0x80 will cause delays on the CPU
performing the I/O.</p>
<dl>
<dt><strong>--ioport-ops N</strong></dt>
<dd>
<p>stop the ioport stressors after N bogo I/O operations</p>
</dd>
<dt><strong>--ioport-opts [ in | out | inout ]</strong></dt>
<dd>
<p>to be performed. The default is both in and out. specify if port
reads in, port read writes out or reads and writes are</p>
</dd>
</dl>
</dd>
<dt><strong>IO scheduling class and priority stressor</strong></dt>
<dd>
<p><strong>--ioprio N</strong> start N workers that exercise the
ioprio_get(2) and ioprio_set(2) system calls (Linux only).</p>
<dl>
<dt><strong>--ioprio-ops N</strong></dt>
<dd>
<p>stop after N io priority bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Io-uring stressor</strong></dt>
<dd>
<p><strong>--io-uring N</strong> start N workers that perform iovec
write and read I/O operations using the Linux io-uring interface. On
each bogo-loop 1024 × 512 byte writes and 1024 × reads are performed on
a temporary file.</p>
<dl>
<dt><strong>--io-uring-entries N</strong></dt>
<dd>
<p>specify the number of io-uring ring entries.</p>
</dd>
<dt><strong>--io-uring-ops</strong></dt>
<dd>
<p>stop after N rounds of write and reads.</p>
</dd>
</dl>
</dd>
<dt><strong>Ipsec multi-buffer cryptographic stressor</strong></dt>
<dd>
<p><strong>--ipsec-mb N</strong> start N workers that perform
cryptographic processing using the highly optimized Intel Multi-Buffer
Crypto for IPsec library. Depending on the features available, SSE, AVX,
AVX and AVX512 CPU features will be used on data encrypted by SHA, DES,
CMAC, CTR, HMAC MD5, HMAC SHA1 and HMAC SHA512 cryptographic routines.
This is only available for x86-64 modern Intel CPUs.</p>
<dl>
<dt><strong>--ipsec-mb-feature [ sse | avx | avx2 | avx512
]</strong></dt>
<dd>
<p>Just use the specified processor CPU feature. By default, all the
available features for the CPU are exercised.</p>
</dd>
<dt><strong>--ipsec-mb-jobs N</strong></dt>
<dd>
<p>Process N multi-block rounds of cryptographic processing per
iteration. The default is 256.</p>
</dd>
<dt><strong>--ipsec-mb-method [ all | cmac | ctr | des | hmac-md5 |
hmac-sha1 | hmac-sha512 | sha ]</strong></dt>
<dd>
<p>Select the ipsec-mb crypto/integrity method.</p>
</dd>
<dt><strong>--ipsec-mb-ops N</strong></dt>
<dd>
<p>stop after N rounds of processing of data using the cryptographic
routines.</p>
</dd>
</dl>
</dd>
<dt><strong>System interval timer stressor</strong></dt>
<dd>
<p><strong>--itimer N</strong> start N workers that exercise the system
interval timers. This sets up an ITIMER_PROF itimer that generates a
SIGPROF signal. The default frequency for the itimer is 1 MHz, however,
the Linux kernel will set this to be no more that the jiffy setting,
hence high frequency SIGPROF signals are not normally possible. A busy
loop spins on getitimer(2) calls to consume CPU and hence decrement the
itimer based on amount of time spent in CPU and system time.</p>
<dl>
<dt><strong>--itimer-freq F</strong></dt>
<dd>
<p>run itimer at F Hz; range from 1 to 1000000 Hz. Normally the highest
frequency is limited by the number of jiffy ticks per second, so running
above 1000 Hz is difficult to attain in practice.</p>
</dd>
<dt><strong>--itimer-ops N</strong></dt>
<dd>
<p>stop itimer stress workers after N bogo itimer SIGPROF signals.</p>
</dd>
<dt><strong>--itimer-rand</strong></dt>
<dd>
<p>select an interval timer frequency based around the interval timer
frequency +/- 12.5% random jitter. This tries to force more variability
in the timer interval to make the scheduling less predictable.</p>
</dd>
</dl>
</dd>
<dt><strong>Jpeg compression stressor</strong></dt>
<dd>
<p><strong>--jpeg N</strong> start N workers that use jpeg compression
on a machine generated plasma field image. The default image is a plasma
field, however different image types may be selected. The starting
raster line is changed on each compression iteration to cycle around the
data.</p>
<dl>
<dt><strong>--jpeg-height H</strong></dt>
<dd>
<p>use a RGB sample image height of H pixels. The default is 512
pixels.</p>
</dd>
<dt><strong>--jpeg-image [ brown | flat | gradient | noise | plasma |
xstripes ]</strong></dt>
<dd>
<p>select the source image type to be compressed. Available image types
are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Type</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">brown</td>
<td style="text-align: left;">brown noise, red and green values vary by
a 3 bit value, blue values vary by a 2 bit value.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">flat</td>
<td style="text-align: left;">a single random colour for the entire
image.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gradient</td>
<td style="text-align: left;">linear gradient of the red, green and blue
components across the width and height of the image.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">noise</td>
<td style="text-align: left;">random white noise for red, green, blue
values.</td>
</tr>
<tr class="even">
<td style="text-align: left;">plasma</td>
<td style="text-align: left;">plasma field with smooth colour
transitions and hard boundary edges.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">xstripes</td>
<td style="text-align: left;">a random colour for each horizontal
line.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--jpeg-ops N</strong></dt>
<dd>
<p>stop after N jpeg compression operations.</p>
</dd>
<dt><strong>--jpeg-quality Q</strong></dt>
<dd>
<p>use the compression quality Q. The range is 1..100 (1 lowest, 100
highest), with a default of 95</p>
</dd>
<dt><strong>--jpeg-width H</strong></dt>
<dd>
<p>use a RGB sample image width of H pixels. The default is 512
pixels.</p>
</dd>
</dl>
</dd>
<dt><strong>Judy array stressor</strong></dt>
<dd>
<p><strong>--judy N</strong> start N workers that insert, search and
delete 32 bit integers in a Judy array using a predictable yet sparse
array index. By default, there are 131072 integers used in the Judy
array. This is a useful method to exercise random access of memory and
processor cache.</p>
<dl>
<dt><strong>--judy-ops N</strong></dt>
<dd>
<p>stop the judy workers after N bogo judy operations are completed.</p>
</dd>
<dt><strong>--judy-size N</strong></dt>
<dd>
<p>specify the size (number of 32 bit integers) in the Judy array to
exercise. Size can be from 1K to 4M 32 bit integers.</p>
</dd>
</dl>
</dd>
<dt><strong>Kcmp stressor (Linux)</strong></dt>
<dd>
<p><strong>--kcmp N</strong> start N workers that use kcmp(2) to compare
parent and child processes to determine if they share kernel resources.
Supported only for Linux and requires CAP_SYS_PTRACE capability.</p>
<dl>
<dt><strong>--kcmp-ops N</strong></dt>
<dd>
<p>stop kcmp workers after N bogo kcmp operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Kernel key management stressor</strong></dt>
<dd>
<p><strong>--key N</strong> start N workers that create and manipulate
keys using add_key(2) and ketctl(2). As many keys are created as the per
user limit allows and then the following keyctl commands are exercised
on each key: KEYCTL_SET_TIMEOUT, KEYCTL_DESCRIBE, KEYCTL_UPDATE,
KEYCTL_READ, KEYCTL_CLEAR and KEYCTL_INVALIDATE.</p>
<dl>
<dt><strong>--key-ops N</strong></dt>
<dd>
<p>stop key workers after N bogo key operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Process signals stressor</strong></dt>
<dd>
<p><strong>--kill N</strong> start N workers sending SIGUSR1 kill
signals to a SIG_IGN signal handler in the stressor and SIGUSR1 kill
signal to a child stressor with a SIGUSR1 handler. Most of the process
time will end up in kernel space.</p>
<dl>
<dt><strong>--kill-ops N</strong></dt>
<dd>
<p>stop kill workers after N bogo kill operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Syslog stressor (Linux)</strong></dt>
<dd>
<p><strong>--klog N</strong> start N workers exercising the kernel
syslog(2) system call. This will attempt to read the kernel log with
various sized read buffers. Linux only.</p>
<dl>
<dt><strong>--klog-ops N</strong></dt>
<dd>
<p>stop klog workers after N syslog operations.</p>
</dd>
</dl>
</dd>
<dt><strong>KVM stressor</strong></dt>
<dd>
<p><strong>--kvm N</strong> start N workers that create, run and destroy
a minimal virtual machine. The virtual machine reads, increments and
writes to port 0x80 in a spin loop and the stressor handles the I/O
transactions. Currently for x86 and Linux only.</p>
<dl>
<dt><strong>--kvm-ops N</strong></dt>
<dd>
<p>stop kvm stressors after N virtual machines have been created, run
and destroyed.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU L1 cache stressor</strong></dt>
<dd>
<p><strong>--l1cache N</strong> start N workers that exercise the CPU
level 1 cache with reads and writes. A cache aligned buffer that is
twice the level 1 cache size is read and then written in level 1 cache
set sized steps over each level 1 cache set. This is designed to
exercise cache block evictions. The bogo-op count measures the number of
million cache lines touched. Where possible, the level 1 cache geometry
is determined from the kernel, however, this is not possible on some
architectures or kernels, so one may need to specify these manually. One
can specify 3 out of the 4 cache geometric parameters, these are as
follows:</p>
<dl>
<dt><strong>--l1cache-line-size N</strong></dt>
<dd>
<p>specify the level 1 cache line size (in bytes)</p>
</dd>
<dt><strong>--l1cache-method [ forward | random | reverse
]</strong></dt>
<dd>
<p>select the method of exercising a l1cache sized buffer. The default
is a forward scan, random picks random bytes to exercise, reverse scans
in reverse.</p>
</dd>
<dt><strong>--l1cache-mlock</strong></dt>
<dd>
<p>attempt to mlock the l1cache size buffer into memory to prevent it
from being swapped out.</p>
</dd>
<dt><strong>--l1cache-ops N</strong></dt>
<dd>
<p>specify the number of cache read/write bogo-op loops to run</p>
</dd>
<dt><strong>--l1cache-sets N</strong></dt>
<dd>
<p>specify the number of level 1 cache sets</p>
</dd>
<dt><strong>--l1cache-size N</strong></dt>
<dd>
<p>specify the level 1 cache size (in bytes)</p>
</dd>
<dt><strong>--l1cache-ways N</strong></dt>
<dd>
<p>specify the number of level 1 cache ways</p>
</dd>
</dl>
</dd>
<dt><strong>Landlock stressor (Linux &gt;= 5.13)</strong></dt>
<dd>
<p><strong>--landlock N</strong> start N workers that exercise Linux
5.13 landlocking. A range of landlock_create_ruleset flags are exercised
with a read only file rule to see if a directory can be accessed and a
read-write file create can be blocked. Each ruleset attempt is exercised
in a new child context and this is the limiting factor on the speed of
the stressor.</p>
<dl>
<dt><strong>--landlock-ops N</strong></dt>
<dd>
<p>stop the landlock stressors after N landlock ruleset bogo
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>File lease stressor</strong></dt>
<dd>
<p><strong>--lease N</strong> start N workers locking, unlocking and
breaking leases via the fcntl(2) F_SETLEASE operation. The parent
processes continually lock and unlock a lease on a file while a user
selectable number of child processes open the file with a non-blocking
open to generate SIGIO lease breaking notifications to the parent. This
stressor is only available if F_SETLEASE, F_WRLCK and F_UNLCK support is
provided by fcntl(2).</p>
<dl>
<dt><strong>--lease-breakers N</strong></dt>
<dd>
<p>start N lease breaker child processes per lease worker. Normally one
child is plenty to force many SIGIO lease breaking notification signals
to the parent, however, this option allows one to specify more child
processes if required.</p>
</dd>
<dt><strong>--lease-ops N</strong></dt>
<dd>
<p>stop lease workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>LED stressor (Linux)</strong></dt>
<dd>
<p><strong>--led N</strong> start N workers that exercise the
/sys/class/leds interfaces to set LED brightness levels and the various
trigger settings. This needs to be run with root privilege to be able to
write to these settings successfully. Non-root privilege will ignore
failed writes.</p>
<dl>
<dt><strong>--led-ops N</strong></dt>
<dd>
<p>stop after N interfaces are exercised.</p>
</dd>
</dl>
</dd>
<dt><strong>Hardlink stressor</strong></dt>
<dd>
<p><strong>--link N</strong> start N workers creating and removing
hardlinks.</p>
<dl>
<dt><strong>--link-ops N</strong></dt>
<dd>
<p>stop link stress workers after N bogo operations.</p>
</dd>
<dt><strong>--link-sync</strong></dt>
<dd>
<p>sync dirty data and metadata to disk.</p>
</dd>
</dl>
</dd>
<dt><strong>List data structures stressor</strong></dt>
<dd>
<p><strong>--list N</strong> start N workers that exercise list data
structures. The default is to add, find and remove 5,000 64 bit integers
into circleq (doubly linked circle queue), list (doubly linked list),
slist (singly linked list), slistt (singly linked list using tail),
stailq (singly linked tail queue) and tailq (doubly linked tail queue)
lists. The intention of this stressor is to exercise memory and cache
with the various list operations.</p>
<dl>
<dt><strong>--list-method [ all | circleq | list | slist | stailq |
tailq ]</strong></dt>
<dd>
<p>specify the list to be used. By default, all the list methods are
used (the 'all' option).</p>
</dd>
<dt><strong>--list-ops N</strong></dt>
<dd>
<p>stop list stressors after N bogo ops. A bogo op covers the addition,
finding and removing all the items into the list(s).</p>
</dd>
<dt><strong>--list-size N</strong></dt>
<dd>
<p>specify the size of the list, where N is the number of 64 bit
integers to be added into the list.</p>
</dd>
</dl>
</dd>
<dt><strong>Last level of cache stressor</strong></dt>
<dd>
<p><strong>--llc-affinity N</strong> start N workers that exercise the
last level of cache (LLC) by read/write activity across a LLC sized
buffer and then changing CPU affinity after each round of read/writes.
This can cause non-local memory stalls and LLC read/write misses.</p>
<dl>
<dt><strong>--llc-affinity-mlock</strong></dt>
<dd>
<p>attempt to mlock the LLC sized buffer into memory to prevent it from
being swapped out.</p>
</dd>
<dt><strong>--llc-affinity-ops N</strong></dt>
<dd>
<p>stop after N rounds of LLC read/writes.</p>
</dd>
</dl>
</dd>
<dt><strong>Load average (loadavg) stressor</strong></dt>
<dd>
<p><strong>--loadavg N</strong> start N workers that attempt to create
thousands of pthreads that run at the lowest nice priority to force very
high load averages. Linux systems will also perform some I/O writes as
pending I/O is also factored into system load accounting.</p>
<dl>
<dt><strong>--loadavg-max N</strong></dt>
<dd>
<p>set the maximum number of pthreads to create to N. N may be reduced
if there is as system limit on the number of pthreads that can be
created.</p>
</dd>
<dt><strong>--loadavg-ops N</strong></dt>
<dd>
<p>stop loadavg workers after N bogo scheduling yields by the pthreads
have been reached.</p>
</dd>
</dl>
</dd>
<dt><strong>Lock and increment memory stressor (x86 and
ARM)</strong></dt>
<dd>
<p><strong>--lockbus N</strong> start N workers that rapidly lock and
increment 64 bytes of randomly chosen memory from a 16MB mmap'd region
(Intel x86 and ARM CPUs only). This will cause cacheline misses and
stalling of CPUs.</p>
<dl>
<dt><strong>--lockbus-nosplit</strong></dt>
<dd>
<p>disable split locks that lock across cache line boundaries.</p>
</dd>
<dt><strong>--lockbus-ops N</strong></dt>
<dd>
<p>stop lockbus workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX lock (F_SETLK/F_GETLK) stressor</strong></dt>
<dd>
<p><strong>--locka N</strong> start N workers that randomly lock and
unlock regions of a file using the POSIX advisory locking mechanism (see
fcntl(2), F_SETLK, F_GETLK). Each worker creates a 1024 KB file and
attempts to hold a maximum of 1024 concurrent locks with a child process
that also tries to hold 1024 concurrent locks. Old locks are unlocked in
a first-in, first-out basis.</p>
<dl>
<dt><strong>--locka-ops N</strong></dt>
<dd>
<p>stop locka workers after N bogo locka operations.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX lock (lockf) stressor</strong></dt>
<dd>
<p><strong>--lockf N</strong> start N workers that randomly lock and
unlock regions of a file using the POSIX lockf(3) locking mechanism.
Each worker creates a 64 KB file and attempts to hold a maximum of 1024
concurrent locks with a child process that also tries to hold 1024
concurrent locks. Old locks are unlocked in a first-in, first-out
basis.</p>
<dl>
<dt><strong>--lockf-nonblock</strong></dt>
<dd>
<p>instead of using blocking F_LOCK lockf(3) commands, use non-blocking
F_TLOCK commands and re-try if the lock failed. This creates extra
system call overhead and CPU utilisation as the number of lockf workers
increases and should increase locking contention.</p>
</dd>
<dt><strong>--lockf-ops N</strong></dt>
<dd>
<p>stop lockf workers after N bogo lockf operations.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX lock (F_OFD_SETLK/F_OFD_GETLK) stressor</strong></dt>
<dd>
<p><strong>--lockofd N</strong> start N workers that randomly lock and
unlock regions of a file using the Linux open file description locks
(see fcntl(2), F_OFD_SETLK, F_OFD_GETLK). Each worker creates a 1024 KB
file and attempts to hold a maximum of 1024 concurrent locks with a
child process that also tries to hold 1024 concurrent locks. Old locks
are unlocked in a first-in, first-out basis.</p>
<dl>
<dt><strong>--lockofd-ops N</strong></dt>
<dd>
<p>stop lockofd workers after N bogo lockofd operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Long jump (longjmp) stressor</strong></dt>
<dd>
<p><strong>--longjmp N</strong> start N workers that exercise
setjmp(3)/longjmp(3) by rapid looping on longjmp calls.</p>
<dl>
<dt><strong>--longjmp-ops N</strong></dt>
<dd>
<p>stop longjmp stress workers after N bogo longjmp operations (1 bogo
op is 1000 longjmp calls).</p>
</dd>
</dl>
</dd>
<dt><strong>Loopback stressor (Linux)</strong></dt>
<dd>
<p><strong>--loop N</strong> start N workers that exercise the loopback
control device. This creates 2MB loopback devices, expands them to 4MB,
performs some loopback status information get and set operations and
then destoys them. Linux only and requires CAP_SYS_ADMIN capability.</p>
<dl>
<dt><strong>--loop-ops N</strong></dt>
<dd>
<p>stop after N bogo loopback creation/deletion operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Linear search stressor</strong></dt>
<dd>
<p><strong>--lsearch N</strong> start N workers that linear search a
unsorted array of 32 bit integers using lsearch(3). By default, there
are 8192 elements in the array. This is a useful method to exercise
sequential access of memory and processor cache.</p>
<dl>
<dt><strong>--lsearch-method [ lsearch-libc | lsearch-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of lsearch or a slightly
optimized non-libc implementation of lsearch. The default is the libc
implementation if it exists, otherwise the non-libc version.</p>
</dd>
<dt><strong>--lsearch-ops N</strong></dt>
<dd>
<p>stop the lsearch workers after N bogo lsearch operations are
completed.</p>
</dd>
<dt><strong>--lsearch-size N</strong></dt>
<dd>
<p>specify the size (number of 32 bit integers) in the array to lsearch.
Size can be from 1K to 4M.</p>
</dd>
</dl>
</dd>
<dt><strong>Madvise stressor</strong></dt>
<dd>
<p><strong>--madvise N</strong> start N workers that apply random
madvise(2) advise settings on pages of a 4MB file backed shared memory
mapping.</p>
<dl>
<dt><strong>--madvise-hwpoison</strong></dt>
<dd>
<p>enable MADV_HWPOISON page poisoning (if available, only when run as
root). This will page poison a few pages and will cause kernel error
messages to be reported.</p>
</dd>
<dt><strong>--madvise-ops N</strong></dt>
<dd>
<p>stop madvise stressors after N bogo madvise operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory allocation stressor</strong></dt>
<dd>
<p><strong>--malloc N</strong> start N workers continuously calling
malloc(3), calloc(3), realloc(3), posix_memalign(3), aligned_alloc(3),
memalign(3) and free(3). By default, up to 65536 allocations can be
active at any point, but this can be altered with the --malloc-max
option. Allocation, reallocation and freeing are chosen at random; 50%
of the time memory is allocation (via one of malloc, calloc or realloc,
posix_memalign, aligned_alloc, memalign) and 50% of the time allocations
are free'd. Allocation sizes are also random, with the maximum
allocation size controlled by the --malloc-bytes option, the default
size being 64K. The worker is re-started if it is killed by the out of
memory (OOM) killer.</p>
<dl>
<dt><strong>--malloc-bytes N</strong></dt>
<dd>
<p>maximum per allocation/reallocation size. Allocations are randomly
selected from 1 to N bytes. One can specify the size as % of total
available memory or in units of Bytes, KBytes, MBytes and GBytes using
the suffix b, k, m or g. Large allocation sizes cause the memory
allocator to use mmap(2) rather than expanding the heap using
brk(2).</p>
</dd>
<dt><strong>--malloc-max N</strong></dt>
<dd>
<p>maximum number of active allocations allowed. Allocations are chosen
at random and placed in an allocation slot. Because about 50%/50% split
between allocation and freeing, typically half of the allocation slots
are in use at any one time.</p>
</dd>
<dt><strong>--malloc-mlock</strong></dt>
<dd>
<p>attempt to mlock the allocations into memory to prevent them from
being swapped out.</p>
</dd>
<dt><strong>--malloc-ops N</strong></dt>
<dd>
<p>stop after N malloc bogo operations. One bogo operations relates to a
successful malloc(3), calloc(3) or realloc(3).</p>
</dd>
<dt><strong>--malloc-pthreads N</strong></dt>
<dd>
<p>specify number of malloc stressing concurrent pthreads to run. The
default is 0 (just one main process, no pthreads). This option will do
nothing if pthreads are not supported.</p>
</dd>
<dt><strong>--malloc-thresh N</strong></dt>
<dd>
<p>specify the threshold where malloc uses mmap(2) instead of sbrk(2) to
allocate more memory. This is only available on systems that provide the
GNU C mallopt(3) tuning function.</p>
</dd>
<dt><strong>--malloc-touch</strong></dt>
<dd>
<p>touch every allocated page to force pages to be populated in memory.
This will increase the memory pressure and exercise the virtual memory
harder. By default the malloc stressor will madvise pages into memory or
use mincore to check for non-resident memory pages and try to force them
into memory; this option aggressively forces pages to be memory
resident.</p>
</dd>
<dt><strong>--malloc-trim</strong></dt>
<dd>
<p>periodically trim memory allocation by attempting to release free
memory from the heap every 65536 allocation iterations. This can be a
time consuming operation. It is only available with libc malloc
implementations that support malloc_trim(3).</p>
</dd>
<dt><strong>--malloc-zerofree</strong></dt>
<dd>
<p>zero allocated memory before free'ing. This can be useful in touching
broken allocations and triggering failures. Also useful for forcing
extra cache/memory writes.</p>
</dd>
</dl>
</dd>
<dt><strong>2D Matrix stressor</strong></dt>
<dd>
<p><strong>--matrix N</strong> start N workers that perform various
matrix operations on floating point values. Testing on 64 bit x86
hardware shows that this provides a good mix of memory, cache and
floating point operations and is an excellent way to make a CPU run
hot.</p>
<p>By default, this will exercise all the matrix stress methods one by
one. One can specify a specific matrix stress method with the
--matrix-method option.</p>
<dl>
<dt><strong>--matrix-method method</strong></dt>
<dd>
<p>specify a matrix stress method. Available matrix stress methods are
described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the below matrix stress
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">add</td>
<td style="text-align: left;">add two N × N matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy</td>
<td style="text-align: left;">copy one N × N matrix to another</td>
</tr>
<tr class="odd">
<td style="text-align: left;">div</td>
<td style="text-align: left;">divide an N × N matrix by a scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">frobenius</td>
<td style="text-align: left;">Frobenius product of two N × N
matrices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hadamard</td>
<td style="text-align: left;">Hadamard product of two N × N
matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">identity</td>
<td style="text-align: left;">create an N × N identity matrix</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mean</td>
<td style="text-align: left;">arithmetic mean of two N × N matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">mult</td>
<td style="text-align: left;">multiply an N × N matrix by a scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">negate</td>
<td style="text-align: left;">negate an N × N matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;">prod</td>
<td style="text-align: left;">product of two N × N matrices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sub</td>
<td style="text-align: left;">subtract one N × N matrix from another N ×
N matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;">square</td>
<td style="text-align: left;">multiply an N × N matrix by itself</td>
</tr>
<tr class="odd">
<td style="text-align: left;">trans</td>
<td style="text-align: left;">transpose an N × N matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;">zero</td>
<td style="text-align: left;">zero an N × N matrix</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--matrix-ops N</strong></dt>
<dd>
<p>stop matrix stress workers after N bogo operations.</p>
</dd>
<dt><strong>--matrix-size N</strong></dt>
<dd>
<p>specify the N × N size of the matrices. Smaller values result in a
floating point compute throughput bound stressor, where as large values
result in a cache and/or memory bandwidth bound stressor.</p>
</dd>
<dt><strong>--matrix-yx</strong></dt>
<dd>
<p>perform matrix operations in order y by x rather than the default x
by y. This is suboptimal ordering compared to the default and will
perform more data cache stalls.</p>
</dd>
</dl>
</dd>
<dt><strong>3D Matrix stressor</strong></dt>
<dd>
<p><strong>--matrix-3d N</strong> start N workers that perform various
3D matrix operations on floating point values. Testing on 64 bit x86
hardware shows that this provides a good mix of memory, cache and
floating point operations and is an excellent way to make a CPU run
hot.</p>
<p>By default, this will exercise all the 3D matrix stress methods one
by one. One can specify a specific 3D matrix stress method with the
--matrix-3d-method option.</p>
<dl>
<dt><strong>--matrix-3d-method method</strong></dt>
<dd>
<p>specify a 3D matrix stress method. Available 3D matrix stress methods
are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the below matrix stress
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">add</td>
<td style="text-align: left;">add two N × N × N matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy</td>
<td style="text-align: left;">copy one N × N × N matrix to another</td>
</tr>
<tr class="odd">
<td style="text-align: left;">div</td>
<td style="text-align: left;">divide an N × N × N matrix by a
scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">frobenius</td>
<td style="text-align: left;">Frobenius product of two N × N × N
matrices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hadamard</td>
<td style="text-align: left;">Hadamard product of two N × N × N
matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">identity</td>
<td style="text-align: left;">create an N × N × N identity matrix</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mean</td>
<td style="text-align: left;">arithmetic mean of two N × N × N
matrices</td>
</tr>
<tr class="even">
<td style="text-align: left;">mult</td>
<td style="text-align: left;">multiply an N × N × N matrix by a
scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">negate</td>
<td style="text-align: left;">negate an N × N × N matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;">sub</td>
<td style="text-align: left;">subtract one N × N × N matrix from another
N × N × N matrix</td>
</tr>
<tr class="odd">
<td style="text-align: left;">trans</td>
<td style="text-align: left;">transpose an N × N × N matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;">zero</td>
<td style="text-align: left;">zero an N × N × N matrix</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--matrix-3d-ops N</strong></dt>
<dd>
<p>stop the 3D matrix stress workers after N bogo operations.</p>
</dd>
<dt><strong>--matrix-3d-size N</strong></dt>
<dd>
<p>specify the N × N × N size of the matrices. Smaller values result in
a floating point compute throughput bound stressor, where as large
values result in a cache and/or memory bandwidth bound stressor.</p>
</dd>
<dt><strong>--matrix-3d-zyx</strong></dt>
<dd>
<p>perform matrix operations in order z by y by x rather than the
default x by y by z. This is suboptimal ordering compared to the default
and will perform more data cache stalls.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory contention stressor</strong></dt>
<dd>
<p><strong>--mcontend N</strong> start N workers that produce memory
contention read/write patterns. Each stressor runs with 5 threads that
read and write to two different mappings of the same underlying physical
page. Various caching operations are also exercised to cause sub-optimal
memory access patterns. The threads also randomly change CPU affinity to
exercise CPU and memory migration stress.</p>
<dl>
<dt><strong>--mcontend-ops N</strong></dt>
<dd>
<p>stop mcontend stressors after N bogo read/write operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory barrier stressor (Linux)</strong></dt>
<dd>
<p><strong>--membarrier N</strong> start N workers that exercise the
membarrier system call (Linux only).</p>
<dl>
<dt><strong>--membarrier-ops N</strong></dt>
<dd>
<p>stop membarrier stress workers after N bogo membarrier
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory copy (memcpy) stressor</strong></dt>
<dd>
<p><strong>--memcpy N</strong> start N workers that copies data to and
from a buffer using memcpy(3) and then move the data in the buffer with
memmove(3) with 3 different alignments. This will exercise the data
cache and memory copying.</p>
<dl>
<dt><strong>--memcpy-method [ all | libc | builtin | naive | naive_o0 ..
naive_o3 ]</strong></dt>
<dd>
<p>specify a memcpy copying method. Available memcpy methods are
described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">use libc, builtin and naïve methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">libc</td>
<td style="text-align: left;">use libc memcpy and memmove functions,
this is the default</td>
</tr>
<tr class="even">
<td style="text-align: left;">builtin</td>
<td style="text-align: left;">use the compiler built in optimized memcpy
and memmove functions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">naive</td>
<td style="text-align: left;">use naïve byte by byte copying and memory
moving build with default compiler optimization flags</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive_o0</td>
<td style="text-align: left;">use unoptimized naïve byte by byte copying
and memory moving</td>
</tr>
<tr class="odd">
<td style="text-align: left;">naive_o1</td>
<td style="text-align: left;">use unoptimized naïve byte by byte copying
and memory moving with -O1 optimization</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive_o2</td>
<td style="text-align: left;">use optimized naïve byte by byte copying
and memory moving build with -O2 optimization and where possible use CPU
specific optimizations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">naive_o3</td>
<td style="text-align: left;">use optimized naïve byte by byte copying
and memory moving build with -O3 optimization and where possible use CPU
specific optimizations</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--memcpy-ops N</strong></dt>
<dd>
<p>stop memcpy stress workers after N bogo memcpy operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Anonymous file (memfd) stressor</strong></dt>
<dd>
<p><strong>--memfd N</strong> start N workers that create allocations of
1024 pages using memfd_create(2) and ftruncate(2) for allocation and
mmap(2) to map the allocation into the process address space. (Linux
only).</p>
<dl>
<dt><strong>--memfd-bytes N</strong></dt>
<dd>
<p>allocate N bytes per memfd stress worker, the default is 256MB. One
can specify the size in as % of total available memory or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--memfd-fds N</strong></dt>
<dd>
<p>create N memfd file descriptors, the default is 256. One can select 8
to 4096 memfd file descriptions with this option.</p>
</dd>
<dt><strong>--memfd-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--memfd-ops N</strong></dt>
<dd>
<p>stop after N memfd-create(2) bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory hotplug stressor (Linux)</strong></dt>
<dd>
<p><strong>--memhotplug N</strong> start N workers that offline and
online memory hotplug regions. Linux only and requires CAP_SYS_ADMIN
capabilities.</p>
<dl>
<dt><strong>--memhotplug-ops N</strong></dt>
<dd>
<p>stop memhotplug stressors after N memory offline and online bogo
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory read/write stressor</strong></dt>
<dd>
<p><strong>--memrate N</strong> start N workers that exercise a buffer
with 1024, 512, 256, 128, 64, 32, 16 and 8 bit reads and writes. 1024,
512 and 256 reads and writes are available with compilers that support
integer vectors. x86-64 cpus that support uncached (non-temporal "nt")
writes also exercise 128, 64 and 32 writes providing higher write rates
than the normal cached writes. x86-64 also exercises repeated string
stores using 64, 32, 16 and 8 bit writes. CPUs that support prefetching
reads also exercise 64 prefetched "pf" reads. This memory stressor
allows one to also specify the maximum read and write rates. The
stressors will run at maximum speed if no read or write rates are
specified.</p>
<dl>
<dt><strong>--memrate-bytes N</strong></dt>
<dd>
<p>specify the size of the memory buffer being exercised. The default
size is 256MB. One can specify the size in units of Bytes, KBytes,
MBytes and GBytes using the suffix b, k, m or g, or cache sizes with L1,
L2, L3 or LLC (lower level cache size).</p>
</dd>
<dt><strong>--memrate-flush</strong></dt>
<dd>
<p>flush cache between each memory exercising test to remove caching
benefits in memory rate metrics.</p>
</dd>
<dt><strong>--memrate-ops N</strong></dt>
<dd>
<p>stop after N bogo memrate operations.</p>
</dd>
<dt><strong>--memrate-rd-mbs N</strong></dt>
<dd>
<p>specify the maximum allowed read rate in MB/sec. The actual read rate
is dependent on scheduling jitter and memory accesses from other running
processes.</p>
</dd>
<dt><strong>--memrate-wr-mbs N</strong></dt>
<dd>
<p>specify the maximum allowed read rate in MB/sec. The actual write
rate is dependent on scheduling jitter and memory accesses from other
running processes.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory trash stressor</strong></dt>
<dd>
<p><strong>--memthrash N</strong> start N workers that thrash and
exercise a 16MB buffer in various ways to try and trip thermal overrun.
Each stressor will start 1 or more threads. The number of threads is
chosen so that there will be at least 1 thread per CPU. Note that the
optimal choice for N is a value that divides into the number of
CPUs.</p>
<dl>
<dt><strong>--memthrash-method method</strong></dt>
<dd>
<p>specify a memthrash stress method. Available memthrash stress methods
are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the below memthrash
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">chunk1</td>
<td style="text-align: left;">memset 1 byte chunks of random data into
random locations</td>
</tr>
<tr class="even">
<td style="text-align: left;">chunk8</td>
<td style="text-align: left;">memset 8 byte chunks of random data into
random locations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">chunk64</td>
<td style="text-align: left;">memset 64 byte chunks of random data into
random locations</td>
</tr>
<tr class="even">
<td style="text-align: left;">chunk256</td>
<td style="text-align: left;">memset 256 byte chunks of random data into
random locations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">chunkpage</td>
<td style="text-align: left;">memset page size chunks of random data
into random locations</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy128</td>
<td style="text-align: left;">copy 128 byte chunks from chunk N + 1 to
chunk N with streaming reads and writes with 128 bit memory accesses
where possible.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">flip</td>
<td style="text-align: left;">flip (invert) all bits in random
locations</td>
</tr>
<tr class="even">
<td style="text-align: left;">flush</td>
<td style="text-align: left;">flush cache line in random locations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lock</td>
<td style="text-align: left;">lock randomly choosing locations (Intel
x86 and ARM CPUs only)</td>
</tr>
<tr class="even">
<td style="text-align: left;">matrix</td>
<td style="text-align: left;">treat memory as a 2 × 2 matrix and swap
random elements</td>
</tr>
<tr class="odd">
<td style="text-align: left;">memmove</td>
<td style="text-align: left;">copy all the data in buffer to the next
memory location</td>
</tr>
<tr class="even">
<td style="text-align: left;">memset</td>
<td style="text-align: left;">memset the memory with random data</td>
</tr>
<tr class="odd">
<td style="text-align: left;">memset64</td>
<td style="text-align: left;">memset the memory with a random 64 bit
value in 64 byte chunks using non-temporal stores if possible or normal
stores as a fallback</td>
</tr>
<tr class="even">
<td style="text-align: left;">memsetstosd</td>
<td style="text-align: left;">memset the memory using x86 32 bit rep
stosd instruction (x86 only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mfence</td>
<td style="text-align: left;">stores with write serialization</td>
</tr>
<tr class="even">
<td style="text-align: left;">numa</td>
<td style="text-align: left;">memory bind pages across numa nodes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prefetch</td>
<td style="text-align: left;">prefetch data at random memory
locations</td>
</tr>
<tr class="even">
<td style="text-align: left;">random</td>
<td style="text-align: left;">randomly run any of the memthrash methods
except for 'random' and 'all'</td>
</tr>
<tr class="odd">
<td style="text-align: left;">reverse</td>
<td style="text-align: left;">swap 8 bit values from start to end and
work towards the middle</td>
</tr>
<tr class="even">
<td style="text-align: left;">spinread</td>
<td style="text-align: left;">spin loop read the same random location
2↑19 times</td>
</tr>
<tr class="odd">
<td style="text-align: left;">spinwrite</td>
<td style="text-align: left;">spin loop write the same random location
2↑19 times</td>
</tr>
<tr class="even">
<td style="text-align: left;">swap</td>
<td style="text-align: left;">step through memory swapping bytes in
steps of 65 and 129 byte strides</td>
</tr>
<tr class="odd">
<td style="text-align: left;">swap64</td>
<td style="text-align: left;">work through memory swapping adjacent 64
byte chunks</td>
</tr>
<tr class="even">
<td style="text-align: left;">swapfwdrev</td>
<td style="text-align: left;">swap 64 bit values from start to end and
work towards the middle and then from end to start and work towards the
middle.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tlb</td>
<td style="text-align: left;">work through memory in sub-optimial
strides of prime multiples of the cache line size with reads and then
writes to cause Translation Lookaside Buffer (TLB) misses.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--memthrash-ops N</strong></dt>
<dd>
<p>stop after N memthrash bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>BSD mergesort stressor</strong></dt>
<dd>
<p><strong>--mergesort N</strong> start N workers that sort 32 bit
integers using the BSD mergesort.</p>
<dl>
<dt><strong>--mergesort-method [ mergesort-libc | mergesort-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of mergesort or an unoptimized
implementation of mergesort. The default is the libc implementation if
it is available.</p>
</dd>
<dt><strong>--mergesort-ops N</strong></dt>
<dd>
<p>stop mergesort stress workers after N bogo mergesorts.</p>
</dd>
<dt><strong>--mergesort-size N</strong></dt>
<dd>
<p>specify number of 32 bit integers to sort, default is 262144 (256 ×
1024).</p>
</dd>
</dl>
</dd>
<dt><strong>File metadata mix</strong></dt>
<dd>
<p><strong>--metamix N</strong> start N workers that generate a file
metadata mix of operations. Each stressor runs 16 concurrent processes
that each exercise a file's metadata with sequences of open, 256 lseeks
and writes, fdatasync, close, fsync and then stat, open, 256 lseeks,
reads, occasional file memory mapping, close, unlink and lstat.</p>
<dl>
<dt><strong>--metamix-bytes N</strong></dt>
<dd>
<p>set the size of metamix files, the default is 1 MB. One can specify
the size as % of free space on the file system or in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--metamix-ops N</strong></dt>
<dd>
<p>stop the metamix stressor after N bogo metafile operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Resident memory (mincore) stressor</strong></dt>
<dd>
<p><strong>--mincore N</strong> start N workers that walk through all of
memory 1 page at a time checking if the page mapped and also is resident
in memory using mincore(2). It also maps and unmaps a page to check if
the page is mapped or not using mincore(2).</p>
<dl>
<dt><strong>--mincore-ops N</strong></dt>
<dd>
<p>stop after N mincore bogo operations. One mincore bogo op is
equivalent to a 300 mincore(2) calls.</p>
</dd>
</dl>
<p><strong>--mincore-random</strong> instead of walking through pages
sequentially, select pages at random. The chosen address is iterated
over by shifting it right one place and checked by mincore until the
address is less or equal to the page size.</p>
</dd>
<dt><strong>Misaligned read/write stressor</strong></dt>
<dd>
<p><strong>--misaligned N</strong> start N workers that perform
misaligned read and writes. By default, this will exercise 128 bit
misaligned read and writes in 8 × 16 bits, 4 × 32 bits, 2 × 64 bits and
1 × 128 bits at the start of a page boundary, at the end of a page
boundary and over a cache boundary. Misaligned read and writes operate
at 1 byte offset from the natural alignment of the data type. On some
architectures this can cause SIGBUS, SIGILL or SIGSEGV, these are
handled and the misaligned stressor method causing the error is
disabled.</p>
<dl>
<dt><strong>--misaligned-method method</strong></dt>
<dd>
<p>Available misaligned stress methods are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the following misaligned
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int16rd</td>
<td style="text-align: left;">8 × 16 bit integer reads</td>
</tr>
<tr class="even">
<td style="text-align: left;">int16wr</td>
<td style="text-align: left;">8 × 16 bit integer writes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int16inc</td>
<td style="text-align: left;">8 × 16 bit integer increments</td>
</tr>
<tr class="even">
<td style="text-align: left;">int16atomic</td>
<td style="text-align: left;">8 × 16 bit atomic integer increments</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32rd</td>
<td style="text-align: left;">4 × 32 bit integer reads</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32wr</td>
<td style="text-align: left;">4 × 32 bit integer writes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32wtnt</td>
<td style="text-align: left;">4 × 32 bit non-temporal stores (x86
only)</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32inc</td>
<td style="text-align: left;">4 × 32 bit integer increments</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int32atomic</td>
<td style="text-align: left;">4 × 32 bit atomic integer increments</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64rd</td>
<td style="text-align: left;">2 × 64 bit integer reads</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int64wr</td>
<td style="text-align: left;">2 × 64 bit integer writes</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64wtnt</td>
<td style="text-align: left;">4 × 64 bit non-temporal stores (x86
only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int64inc</td>
<td style="text-align: left;">2 × 64 bit integer increments</td>
</tr>
<tr class="even">
<td style="text-align: left;">int64atomic</td>
<td style="text-align: left;">2 × 64 bit atomic integer increments</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128rd</td>
<td style="text-align: left;">1 × 128 bit integer reads</td>
</tr>
<tr class="even">
<td style="text-align: left;">int128wr</td>
<td style="text-align: left;">1 × 128 bit integer writes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int128inc</td>
<td style="text-align: left;">1 × 128 bit integer increments</td>
</tr>
<tr class="even">
<td style="text-align: left;">int128atomic</td>
<td style="text-align: left;">1 × 128 bit atomic integer increments</td>
</tr>
</tbody>
</table>
<p>Note that some of these options (128 bit integer and/or atomic
operations) may not be available on some systems.</p>
<dl>
<dt><strong>--misaligned-ops N</strong></dt>
<dd>
<p>stop after N misaligned bogo operation. A misaligned bogo op is
equivalent</p>
</dd>
</dl>
</dd>
</dl>
<p>to 65536 × 128 bit reads or writes.</p>
<dl>
<dt><strong>Mknod/unlink stressor</strong></dt>
<dd>
<p><strong>--mknod N</strong> start N workers that create and remove
fifos, empty files and named sockets using mknod and unlink.</p>
<dl>
<dt><strong>--mknod-ops N</strong></dt>
<dd>
<p>stop directory thrash workers after N bogo mknod operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Mapped memory pages lock/unlock stressor</strong></dt>
<dd>
<p><strong>--mlock N</strong> start N workers that lock and unlock
memory mapped pages using mlock(2), munlock(2), mlockall(2) and
munlockall(2). This is achieved by the mapping of three contiguous pages
and then locking the second page, hence ensuring non-contiguous pages
are locked . This is then repeated until the maximum allowed mlocks or a
maximum of 262144 mappings are made. Next, all future mappings are
mlocked and the worker attempts to map 262144 pages, then all pages are
munlocked and the pages are unmapped.</p>
<dl>
<dt><strong>--mlock-ops N</strong></dt>
<dd>
<p>stop after N mlock bogo operations.</p>
</dd>
<dt><strong>--mlockmany N</strong></dt>
<dd>
<p>start N workers that fork off a default of 1024 child processes in
total; each child will attempt to anonymously mmap and mlock the maximum
allowed mlockable memory size. The stress test attempts to avoid
swapping by tracking low memory and swap allocations (but some swapping
may occur). Once either the maximum number of child process is reached
or all mlockable in-core memory is locked then child processes are
killed and the stress test is repeated.</p>
</dd>
<dt><strong>--mlockmany-ops N</strong></dt>
<dd>
<p>stop after N mlockmany (mmap and mlock) operations.</p>
</dd>
<dt><strong>--mlockmany-procs N</strong></dt>
<dd>
<p>set the number of child processes to create per stressor. The default
is to start a maximum of 1024 child processes in total across all the
stressors. This option allows the setting of N child processes per
stressor.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory mapping (mmap/munmap) stressor</strong></dt>
<dd>
<p><strong>--mmap N</strong> start N workers continuously calling
mmap(2)/munmap(2). The initial mapping is a large chunk (size specified
by --mmap-bytes) followed by pseudo-random 4K unmappings, then
pseudo-random 4K mappings, and then linear 4K unmappings. Note that this
can cause systems to trip the kernel OOM killer on Linux systems if not
enough physical memory and swap is not available. The MAP_POPULATE
option is used to populate pages into memory on systems that support
this. By default, anonymous mappings are used, however, the --mmap-file
and --mmap-async options allow one to perform file based mappings if
desired.</p>
<blockquote>
<p>Note that since stress-ng 0.17.05 the --mmap-madvise,
--mmap-mergeable, --mmap-mprotect, --mmap-slow-munmap and
--mmap-write-check options should be used to enable the pre-0.17.05 mmap
stressor behaviour.</p>
</blockquote>
<dl>
<dt><strong>--mmap-async</strong></dt>
<dd>
<p>enable file based memory mapping and use asynchronous msync'ing on
each page, see --mmap-file.</p>
</dd>
<dt><strong>--mmap-bytes N</strong></dt>
<dd>
<p>allocate N bytes per mmap stress worker, the default is 256MB. One
can specify the size as % of total available memory or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--mmap-file</strong></dt>
<dd>
<p>enable file based memory mapping and by default use synchronous
msync'ing on each page.</p>
</dd>
<dt><strong>--mmap-madvise</strong></dt>
<dd>
<p>enable randomized madvise(2) settings on pages.</p>
</dd>
<dt><strong>--mmap-mergeable</strong></dt>
<dd>
<p>mark pages as mergeable via madvise(2) where possible.</p>
</dd>
<dt><strong>--mmap-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mmap-mmap2</strong></dt>
<dd>
<p>use mmap2 for 4K page aligned offsets if mmap2 is available,
otherwise fall back to mmap.</p>
</dd>
<dt><strong>--mmap-mprotect</strong></dt>
<dd>
<p>change protection settings on each page of memory. Each time a page
or a group of pages are mapped or remapped then this option will make
the pages read-only, write-only, exec-only, and read-write.</p>
</dd>
<dt><strong>--mmap-odirect</strong></dt>
<dd>
<p>enable file based memory mapping and use O_DIRECT direct I/O.</p>
</dd>
<dt><strong>--mmap-ops N</strong></dt>
<dd>
<p>stop mmap stress workers after N bogo operations.</p>
</dd>
<dt><strong>--mmap-osync</strong></dt>
<dd>
<p>enable file based memory mapping and used O_SYNC synchronous I/O
integrity completion.</p>
</dd>
<dt><strong>--mmap-slow-munmap</strong></dt>
<dd>
<p>enable page-by-page memory unmapping rather than attempting to memory
unmap contiguous pages in one large unmapping. This can cause lock
contention when running with many concurrent mmap stressors and will
slow down the stressor.</p>
</dd>
<dt><strong>--mmap-stressful</strong></dt>
<dd>
<p>enable --mmap-file, --mmap-madvise, --mmap-mergeable, --mmap-mlock,
--mmap-mprotect, --mmap-odirect, --mmap-slow-munmap</p>
</dd>
<dt><strong>--mmap-write-check</strong></dt>
<dd>
<p>write into each page a unique 64 bit check value for all pages and
then read the value for a sanity check. This will force newly memory
mapped pages to be faulted-in which slows down mmap bogo-op rate. This
can also cause lock contention on page allocation and page unmapping on
systems with many CPU threads and with cgroup memory accounting.</p>
</dd>
</dl>
</dd>
<dt><strong>Random memory map/unmap stressor</strong></dt>
<dd>
<p><strong>--mmapaddr N</strong> start N workers that memory map pages
at a random memory location that is not already mapped. On 64 bit
machines the random address is randomly chosen 32 bit or 64 bit address.
If the mapping works a second page is memory mapped from the first
mapped address. The stressor exercises mmap/munmap, mincore and segfault
handling.</p>
<dl>
<dt><strong>--mmapaddr-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mmapaddr-ops N</strong></dt>
<dd>
<p>stop after N random address mmap bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Forked memory map stressor</strong></dt>
<dd>
<p><strong>--mmapfork N</strong> start N workers that each fork off 32
child processes, each of which tries to allocate some of the free memory
left in the system (and trying to avoid any swapping). The child
processes then hint that the allocation will be needed with madvise(2)
and then memset it to zero and hint that it is no longer needed with
madvise before exiting. This produces significant amounts of VM
activity, a lot of cache misses and with minimal swapping.</p>
<dl>
<dt><strong>--mmapfork-ops N</strong></dt>
<dd>
<p>stop after N mmapfork bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory map files stressor</strong></dt>
<dd>
<p><strong>--mmapfiles N</strong> start N workers that attempt to memory
map and then unmap up to 512 × 1024 files into memory. The stressor will
traverse /lib, /lib32, /lib64, /boot, /bin, /etc, /sbin, /usr, /var,
/sys and /proc and attempt to memory map files in these directories.
Note that mapping bogo-ops rate will depend on the speed of access to
files on these file systems.</p>
<dl>
<dt><strong>--mmapfiles-ops N</strong></dt>
<dd>
<p>stop after N memory map/unmap operations.</p>
</dd>
<dt><strong>--mmapfiles-populate</strong></dt>
<dd>
<p>The default is to perform a memory mapping and not fault any pages
into physical memory. This option uses MAP_POPULATE when available and
will also read the first byte in each page to ensure pages are faulted
into memory to force memory population from file.</p>
</dd>
<dt><strong>--mmapfiles-shared</strong></dt>
<dd>
<p>The default is for private memory mapped files, however, with this
option will use shared memory mappings.</p>
</dd>
</dl>
</dd>
<dt><strong>Fixed address memory map stressor</strong></dt>
<dd>
<p><strong>--mmapfixed N</strong> start N workers that perform fixed
address allocations from the top virtual address down to 128K. The
allocated sizes are from 1 page to 8 pages and various random mmap flags
are used MAP_SHARED/MAP_PRIVATE, MAP_LOCKED, MAP_NORESERVE,
MAP_POPULATE. If successfully map'd then the allocation is remap'd first
to a large range of addresses based on a random start and finally an
address that is several pages higher in memory. Mappings and remappings
are madvised with random madvise options to further exercise the
mappings.</p>
<dl>
<dt><strong>--mmapfixed-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mmapfixed-ops N</strong></dt>
<dd>
<p>stop after N mmapfixed memory mapping bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Huge page memory mapping stressor</strong></dt>
<dd>
<p><strong>--mmaphuge N</strong> start N workers that attempt to mmap a
set of huge pages and large huge page sized mappings. Successful
mappings are madvised with MADV_NOHUGEPAGE and MADV_HUGEPAGE settings
and then 1/64th of the normal small page size pages are touched.
Finally, an attempt to unmap a small page size page at the end of the
mapping is made (these may fail on huge pages) before the set of pages
are unmapped. By default 8192 mappings are attempted per round of
mappings or until swapping is detected.</p>
<dl>
<dt><strong>--mmaphuge-file</strong></dt>
<dd>
<p>attempt to mmap on a 16MB temporary file and random 4K offsets. If
this fails, anonymous mappings are used instead.</p>
</dd>
<dt><strong>--mmaphuge-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd huge pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mmaphuge-mmaps N</strong></dt>
<dd>
<p>set the number of huge page mappings to attempt in each round of
mappings. The default is 8192 mappings.</p>
</dd>
<dt><strong>--mmaphuge-ops N</strong></dt>
<dd>
<p>stop after N mmaphuge bogo operations</p>
</dd>
</dl>
</dd>
<dt><strong>Maximum memory mapping per process stressor</strong></dt>
<dd>
<p><strong>--mmapmany N</strong> start N workers that attempt to create
the maximum allowed per-process memory mappings. This is achieved by
mapping 3 contiguous pages and then unmapping the middle page hence
splitting the mapping into two. This is then repeated until the maximum
allowed mappings or a maximum of 262144 mappings are made.</p>
<dl>
<dt><strong>--mmapmany-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd huge pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mmapmany-ops N</strong></dt>
<dd>
<p>stop after N mmapmany bogo operations</p>
</dd>
</dl>
</dd>
<dt><strong>Kernel module loading stressor (Linux)</strong></dt>
<dd>
<p><strong>--module N</strong> start N workers that use finit_module()
to load the module specified or the hello test module, if is available.
There are different ways to test loading modules. Using modprobe calls
in a loop, using the kernel kernel module autoloader, and this stress-ng
module stressor. To stress tests modprobe we can simply run the
userspace modprobe program in a loop. To stress test the kernel module
autoloader we can stress tests using the upstream kernel
tools/testing/selftests/kmod/kmod.sh. This ends up calling modprobe in
the end, and it has its own caps built-in to self protect the kernel
from too many requests at the same time. The userspace modprobe call
will also prevent calls if the same module exists already. The stress-ng
modules stressor is designed to help stress test the finit_module()
system call even if the module is already loaded, testing races that are
otherwise hard to reproduce.</p>
<dl>
<dt><strong>--module-name NAME</strong></dt>
<dd>
<p>NAME of the module to use, for example: test_module, xfs, ext4. By
default test_module is used so CONFIG_TEST_LKM must be enabled in the
kernel. The module dependencies must be loaded prior to running these
stressor tests, as this stresses running finit_module() not using
modprobe.</p>
</dd>
<dt><strong>--module-no-modver</strong></dt>
<dd>
<p>ignore module modversions when using finit_module().</p>
</dd>
<dt><strong>--module-no-vermag</strong></dt>
<dd>
<p>ignore module versions when using finit_module().</p>
</dd>
<dt><strong>--module-no-unload</strong></dt>
<dd>
<p>do not unload the module right after loading it with
finit_module().</p>
</dd>
<dt><strong>--module-ops N</strong></dt>
<dd>
<p>stop after N module load/unload cycles</p>
</dd>
</dl>
</dd>
<dt><strong>Monte Carlo computations of π and e and various
integrals</strong></dt>
<dd>
<p><strong>--monte-carlo N</strong> start N stressors that compute π and
e (Euler's number) using Monte Carlo computational experiments with
various random number generators.</p>
<dl>
<dt><strong>--monte-carlo-method [ all | e | exp | pi | sin | sqrt
]</strong></dt>
<dd>
<p>specify the computation to perform, options are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">use all monte carlo computation
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e</td>
<td style="text-align: left;">compute Euler's constant e</td>
</tr>
<tr class="even">
<td style="text-align: left;">exp</td>
<td style="text-align: left;">integrate exp(x ↑ 2) for x = 0..1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pi</td>
<td style="text-align: left;">compute π from the area of a circle</td>
</tr>
<tr class="even">
<td style="text-align: left;">sin</td>
<td style="text-align: left;">integrate sin(x) for x = 0..π</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sqrt</td>
<td style="text-align: left;">integrate sqrt(1 + x ↑ 4) for x =
0..1</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--monte-carlo-ops N</strong></dt>
<dd>
<p>stop after Monte Carlo computation experiments</p>
</dd>
<dt><strong>--monte-carlo-rand [ all | drand48 | getrandom | lcg | pcg32
| mwc64 | random | xorshift ]</strong></dt>
<dd>
<p>specify the random number generator to use, options are as
follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">use all the random number generators</td>
</tr>
<tr class="odd">
<td style="text-align: left;">drand48</td>
<td style="text-align: left;">use the libc linear congruential algorithm
drand48(3) using 48-bit integer arithmetic.</td>
</tr>
<tr class="even">
<td style="text-align: left;">getrandom</td>
<td style="text-align: left;">use the getrandom(2) system call for
random values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lcg</td>
<td style="text-align: left;">use a 32 bit Paker-Miller Linear
Congruential Generator, with a division optimization.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pcg32</td>
<td style="text-align: left;">use a 32 bit O'Neill Permuted Congruential
Generator.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mwc64</td>
<td style="text-align: left;">use the 64 bit stress-ng Multiply With
Carry random number generator.</td>
</tr>
<tr class="even">
<td style="text-align: left;">random</td>
<td style="text-align: left;">use the libc random(3) Non-linear Additive
Feedback random number generator.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">xorshift</td>
<td style="text-align: left;">use a 32 bit Marsaglia shift-register
random number generator.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--monte-carlo-samples N</strong></dt>
<dd>
<p>specify the number of random number samples to use to compute π or e,
default is 100000.</p>
</dd>
</dl>
</dd>
<dt><strong>Multi-precision floating operations (mpfr)
stressor</strong></dt>
<dd>
<p><strong>--mpfr N</strong> start N workers that exercise
multi-precision floating point operations using the GNU Multi-Precision
Floating Point Reliable library (mpfr). Operations computed are as
follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">apery</td>
<td style="text-align: left;">calculate Apery's constant ζ(3); the sum
of 1/(n ↑ 3).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cosine</td>
<td style="text-align: left;">compute cos(θ) for θ = 0 to 2π in 100
steps.</td>
</tr>
<tr class="even">
<td style="text-align: left;">euler</td>
<td style="text-align: left;">compute e using n = (1 + (1 ÷ n)) ↑
n.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">exp</td>
<td style="text-align: left;">compute 1000 exponentials.</td>
</tr>
<tr class="even">
<td style="text-align: left;">log</td>
<td style="text-align: left;">computer 1000 natural logarithms.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">omega</td>
<td style="text-align: left;">compute the omega constant defined by Ωe↑Ω
= 1 using efficient iteration of Ωn+1 = (1 + Ωn) / (1 + e↑Ωn).</td>
</tr>
<tr class="even">
<td style="text-align: left;">phi</td>
<td style="text-align: left;">compute the Golden Ratio ϕ using
series.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sine</td>
<td style="text-align: left;">compute sin(θ) for θ = 0 to 2π in 100
steps.</td>
</tr>
<tr class="even">
<td style="text-align: left;">nsqrt</td>
<td style="text-align: left;">compute square root using
Newton-Raphson.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--mpfr-ops N</strong></dt>
<dd>
<p>stop workers after N iterations of various multi-precision floating
point operations.</p>
</dd>
<dt><strong>--mpfr-precision N</strong></dt>
<dd>
<p>specify the precision in binary digits of the floating point
operations. The default is 1000 bits, the allowed range is 32 to 1000000
(very slow).</p>
</dd>
</dl>
</dd>
<dt><strong>Memory protection stressor</strong></dt>
<dd>
<p><strong>--mprotect N</strong> start N workers that exercise changing
page protection settings and access memory after each change. 8
processes per worker contend with each other changing page proection
settings on a shared memory region of just a few pages to cause TLB
flushes. A read and write to the pages can cause segmentation faults and
these are handled by the stressor. All combinations of page protection
settings are exercised including invalid combinations.</p>
<dl>
<dt><strong>--mprotect-ops N</strong></dt>
<dd>
<p>stop after N mprotect calls.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX message queue stressor (Linux)</strong></dt>
<dd>
<p><strong>--mq N</strong> start N sender and receiver processes that
continually send and receive messages using POSIX message queues. (Linux
only).</p>
<dl>
<dt><strong>--mq-ops N</strong></dt>
<dd>
<p>stop after N bogo POSIX message send operations completed.</p>
</dd>
<dt><strong>--mq-size N</strong></dt>
<dd>
<p>specify size of POSIX message queue. The default size is 10 messages
and most Linux systems this is the maximum allowed size for normal
users. If the given size is greater than the allowed message queue size
then a warning is issued and the maximum allowed size is used
instead.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory remap stressor (Linux)</strong></dt>
<dd>
<p><strong>--mremap N</strong> start N workers continuously calling
mmap(2), mremap(2) and munmap(2). The initial anonymous mapping is a
large chunk (size specified by --mremap-bytes) and then iteratively
halved in size by remapping all the way down to a page size and then
back up to the original size. This worker is only available for
Linux.</p>
<dl>
<dt><strong>--mremap-bytes N</strong></dt>
<dd>
<p>initially allocate N bytes per remap stress worker, the default is
256MB. One can specify the size in units of Bytes, KBytes, MBytes and
GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--mremap-mlock</strong></dt>
<dd>
<p>attempt to mlock remap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--mremap-ops N</strong></dt>
<dd>
<p>stop mremap stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>System V message IPC stressor</strong></dt>
<dd>
<p><strong>--msg N</strong> start N sender and receiver processes that
continually send and receive messages using System V message IPC.</p>
<dl>
<dt><strong>--msg-bytes N</strong></dt>
<dd>
<p>specify the size of the message being sent and received. Range 4 to
8192 bytes, default is 4 bytes.</p>
</dd>
<dt><strong>--msg-ops N</strong></dt>
<dd>
<p>stop after N bogo message send operations completed.</p>
</dd>
<dt><strong>--msg-types N</strong></dt>
<dd>
<p>select the quality of message types (mtype) to use. By default,
msgsnd sends messages with a mtype of 1, this option allows one to send
messages types in the range 1..N to exercise the message queue receive
ordering. This will also impact throughput performance.</p>
</dd>
</dl>
</dd>
<dt><strong>Synchronize file with memory map (msync)
stressor</strong></dt>
<dd>
<p><strong>--msync N</strong> start N stressors that msync data from a
file backed memory mapping from memory back to the file and msync
modified data from the file back to the mapped memory. This exercises
the msync(2) MS_SYNC and MS_INVALIDATE sync operations.</p>
<dl>
<dt><strong>--msync-bytes N</strong></dt>
<dd>
<p>allocate N bytes for the memory mapped file, the default is 256MB.
One can specify the size as % of total available memory or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--msync-ops N</strong></dt>
<dd>
<p>stop after N msync bogo operations completed.</p>
</dd>
</dl>
</dd>
<dt><strong>Synchronize file with memory map (msync) coherency
stressor</strong></dt>
<dd>
<p><strong>--msyncmany N</strong> start N stressors that memory map up
to 32768 pages on the same page of a temporary file, change the first 32
bits in a page and msync the data back to the file. The other 32767
pages are examined to see if the 32 bit check value is msync'd back to
these pages.</p>
<dl>
<dt><strong>--msyncmany-ops N</strong></dt>
<dd>
<p>stop after N msync calls in the msyncmany stressors are
completed.</p>
</dd>
</dl>
</dd>
<dt><strong>Unmapping shared non-executable memory stressor
(Linux)</strong></dt>
<dd>
<p><strong>--munmap N</strong> start N stressors that exercise unmapping
of shared non-executable mapped regions of child processes (Linux only).
The unmappings map shared memory regions page by page with a prime sized
stride that creates many temporary mapping holes. One the unmappings are
complete the child will exit and a new one is started. Note that this
may trigger segmentation faults in the child process, these are handled
where possible by forcing the child process to call _exit(2).</p>
<dl>
<dt><strong>--munmap-ops N</strong></dt>
<dd>
<p>stop after N page unmappings.</p>
</dd>
</dl>
</dd>
<dt><strong>Pthread mutex stressor</strong></dt>
<dd>
<p><strong>--mutex N</strong> start N stressors that exercise pthread
mutex locking and unlocking. If run with enough privilege then the FIFO
scheduler is used and a random priority between 0 and 80% of the maximum
FIFO priority level is selected for the locking operation. The minimum
FIFO priority level is selected for the critical mutex section and
unlocking operation to exercise random inverted priority scheduling.</p>
<dl>
<dt><strong>--mutex-affinity</strong></dt>
<dd>
<p>enable random CPU affinity changing between mutex lock and
unlock.</p>
</dd>
<dt><strong>--mutex-ops N</strong></dt>
<dd>
<p>stop after N bogo mutex lock/unlock operations.</p>
</dd>
<dt><strong>--mutex-procs N</strong></dt>
<dd>
<p>By default 2 threads are used for locking/unlocking on a single
mutex. This option allows the default to be changed to 2 to 64
concurrent threads.</p>
</dd>
</dl>
</dd>
<dt><strong>High resolution and scheduler stressor via nanosleep
calls</strong></dt>
<dd>
<p><strong>--nanosleep N</strong> start N workers that each run pthreads
that call nanosleep with random delays from 1 to 2↑18 nanoseconds. This
should exercise the high resolution timers and scheduler.</p>
<dl>
<dt><strong>--nanosleep-method [ all | cstate | random | ns | us | ms
]</strong></dt>
<dd>
<p>select the nanosleep sleep duration method. By default, cstate
residency durations (if they exist) and random durations are used. This
option allows one to select one of the three methods:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">use cstate and random nanosecond
durations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cstate</td>
<td style="text-align: left;">use cstate nanosecond durations. It is
recommended to also use --nanosleep-threads 1 to exercise less
conconcurrent nanosleeps to allow CPUs to drop into deep C states.</td>
</tr>
<tr class="even">
<td style="text-align: left;">random</td>
<td style="text-align: left;">use random nanosecond durations between 1
and 2^18 nanoseconds.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ns</td>
<td style="text-align: left;">use 1ns (nanosecond) nanosleeps</td>
</tr>
<tr class="even">
<td style="text-align: left;">us</td>
<td style="text-align: left;">use 1us (microsecond) nanosleeps</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ms</td>
<td style="text-align: left;">use 1ms (millisecond) nanosleeps</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--nanosleep-ops N</strong></dt>
<dd>
<p>stop the nanosleep stressor after N bogo nanosleep operations.</p>
</dd>
<dt><strong>--nanosleep-threads N</strong></dt>
<dd>
<p>specify the number of concurrent pthreads to run per stressor. The
default is 8 and the allowed range is 1 to 1024.</p>
</dd>
</dl>
</dd>
<dt><strong>Network device ioctl stressor</strong></dt>
<dd>
<p><strong>--netdev N</strong> start N workers that exercise various
netdevice ioctl commands across all the available network devices. The
ioctls exercised by this stressor are as follows: SIOCGIFCONF,
SIOCGIFINDEX, SIOCGIFNAME, SIOCGIFFLAGS, SIOCGIFADDR, SIOCGIFNETMASK,
SIOCGIFMETRIC, SIOCGIFMTU, SIOCGIFHWADDR, SIOCGIFMAP and SIOCGIFTXQLEN.
See netdevice(7) for more details of these ioctl commands.</p>
<dl>
<dt><strong>--netdev-ops N</strong></dt>
<dd>
<p>stop after N netdev bogo operations completed.</p>
</dd>
</dl>
</dd>
<dt><strong>Netlink stressor (Linux)</strong></dt>
<dd>
<p><strong>--netlink-proc N</strong> start N workers that spawn child
processes and monitor fork/exec/exit process events via the proc netlink
connector. Each event received is counted as a bogo op. This stressor
can only be run on Linux and requires CAP_NET_ADMIN capability.</p>
<dl>
<dt><strong>--netlink-proc-ops N</strong></dt>
<dd>
<p>stop the proc netlink connector stressors after N bogo ops.</p>
</dd>
<dt><strong>--netlink-task N</strong></dt>
<dd>
<p>start N workers that collect task statistics via the netlink
taskstats interface. This stressor can only be run on Linux and requires
CAP_NET_ADMIN capability.</p>
</dd>
<dt><strong>--netlink-task-ops N</strong></dt>
<dd>
<p>stop the taskstats netlink connector stressors after N bogo ops.</p>
</dd>
</dl>
</dd>
<dt><strong>Nice stressor</strong></dt>
<dd>
<p><strong>--nice N</strong> start N cpu consuming workers that exercise
the available nice levels. Each iteration forks off a child process that
runs through the all the nice levels running a busy loop for 0.1 seconds
per level and then exits.</p>
<dl>
<dt><strong>--nice-ops N</strong></dt>
<dd>
<p>stop after N nice bogo nice loops</p>
</dd>
</dl>
</dd>
<dt><strong>NO-OP CPU instruction stressor</strong></dt>
<dd>
<p><strong>--nop N</strong> start N workers that consume cpu cycles
issuing no-op instructions. This stressor is available if the assembler
supports the "nop" instruction.</p>
<dl>
<dt><strong>--nop-instr INSTR</strong></dt>
<dd>
<p>use alternative nop instruction INSTR. For x86 CPUs INSTR can be one
of nop, pause, nop2 (2 byte nop) through to nop15 (15 byte nop). For ARM
CPUs, INSTR can be one of nop or yield. For PPC64 CPUs, INSTR can be one
of nop, mdoio, mdoom or yield. For S390 CPUs, INSTR can be one of nop or
nopr. For other processors, INSTR is only nop. The random INSTR option
selects a randon mix of the available nop instructions. If the chosen
INSTR generates an SIGILL signal, then the stressor falls back to the
vanilla nop instruction.</p>
</dd>
<dt><strong>--nop-ops N</strong></dt>
<dd>
<p>stop nop workers after N no-op bogo operations. Each bogo-operation
is equivalent to 256 loops of 256 no-op instructions.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev/null stressor</strong></dt>
<dd>
<p><strong>--null N</strong> start N workers that exercise /dev/null
with writes, lseek, ioctl, fcntl, fallocate and fdatasync. For just
/dev/null write benchmarking use the --null-write option.</p>
<dl>
<dt><strong>--null-ops N</strong></dt>
<dd>
<p>stop null stress workers after N /dev/null bogo operations.</p>
</dd>
<dt><strong>--null-write</strong></dt>
<dd>
<p>just write to /dev/null with 4K writes with no additional exercising
on /dev/null.</p>
</dd>
</dl>
</dd>
<dt><strong>Migrate memory pages over NUMA nodes stressor</strong></dt>
<dd>
<p><strong>--numa N</strong> start N workers that migrate stressors and
a 4MB memory mapped buffer around all the available NUMA nodes. This
uses migrate_pages(2) to move the stressors and mbind(2) and
move_pages(2) to move the pages of the mapped buffer. After each move,
the buffer is written to force activity over the bus which results cache
misses. This test will only run on hardware with NUMA enabled and more
than 1 NUMA node.</p>
<dl>
<dt><strong>--numa-bytes N</strong></dt>
<dd>
<p>specify the total number bytes to be exercised by all the workers,
the given size is divided by the number of workers and rounded to the
nearest page size. The default is 4MB per worker. One can specify the
size as % of total available memory or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--numa-ops N</strong></dt>
<dd>
<p>stop NUMA stress workers after N bogo NUMA operations.</p>
</dd>
<dt><strong>--numa-shuffle-addr</strong></dt>
<dd>
<p>shuffle page order for the address list when calling
move_pages(2)</p>
</dd>
<dt><strong>--numa-shuffle-node</strong></dt>
<dd>
<p>shuffle node order for the address list when calling
move_pages(2)</p>
</dd>
</dl>
</dd>
<dt><strong>Large Pipe stressor</strong></dt>
<dd>
<p><strong>--oom-pipe N</strong> start N workers that create as many
pipes as allowed and exercise expanding and shrinking the pipes from the
largest pipe size down to a page size. Data is written into the pipes
and read out again to fill the pipe buffers. With the --aggressive mode
enabled the data is not read out when the pipes are shrunk, causing the
kernel to OOM processes aggressively. Running many instances of this
stressor will force kernel to OOM processes due to the many large pipe
buffer allocations.</p>
<dl>
<dt><strong>--oom-pipe-ops N</strong></dt>
<dd>
<p>stop after N bogo pipe expand/shrink operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Illegal instructions stressors</strong></dt>
<dd>
<p><strong>--opcode N</strong> start N workers that fork off children
that execute randomly generated executable code. This will generate
issues such as illegal instructions, bus errors, segmentation faults,
traps, floating point errors that are handled gracefully by the
stressor.</p>
<dl>
<dt><strong>--opcode-method [ inc | mixed | random | text
]</strong></dt>
<dd>
<p>select the opcode generation method. By default, random bytes are
used to generate the executable code. This option allows one to select
one of the three methods:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">inc</td>
<td style="text-align: left;">use incrementing 32 bit opcode patterns
from 0x00000000 to 0xfffffff inclusive.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mixed</td>
<td style="text-align: left;">use a mix of incrementing 32 bit opcode
patterns and random 32 bit opcode patterns that are also inverted,
encoded with gray encoding and bit reversed.</td>
</tr>
<tr class="even">
<td style="text-align: left;">random</td>
<td style="text-align: left;">generate opcodes using random bytes from a
mwc random generator.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">text</td>
<td style="text-align: left;">copies random chunks of code from the
stress-ng text segment and randomly flips single bits in a random choice
of 1/8th of the code.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--opcode-ops N</strong></dt>
<dd>
<p>stop after N attempts to execute illegal code.</p>
</dd>
</dl>
</dd>
<dt><strong>Opening file (open) stressor</strong></dt>
<dd>
<p><strong>-o N, --open N</strong> start N workers that perform open(2)
and then close(2) operations on /dev/zero. The maximum opens at one time
is system defined, so the test will run up to this maximum, or 65536
open file descriptors, which ever comes first.</p>
<dl>
<dt><strong>--open-fd</strong></dt>
<dd>
<p>run a child process that scans /proc/$PID/fd and attempts to open the
files that the stressor has opened. This exercises racing open/close
operations on the proc interface.</p>
</dd>
<dt><strong>--open-max N</strong></dt>
<dd>
<p>try to open a maximum of N files (or up to the maximum per-process
open file system limit). The value can be the number of files or a
percentage of the maximum per-process open file system limit.</p>
</dd>
<dt><strong>--open-ops N</strong></dt>
<dd>
<p>stop the open stress workers after N bogo open operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Page table and TLB stressor</strong></dt>
<dd>
<p><strong>--pagemove N</strong> start N workers that mmap a memory
region (default 4 MB) and then shuffle pages to the virtual address of
the previous page. Each page shuffle uses 3 mremap operations to move a
page. This exercises page tables and Translation Lookaside Buffer (TLB)
flushing.</p>
<dl>
<dt><strong>--pagemove-bytes</strong></dt>
<dd>
<p>specify the size of the memory mapped region to be exercised. One can
specify the size as % of total available memory or in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--pagemove-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd and mremap'd pages into memory causing more
memory pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--pagemove-ops N</strong></dt>
<dd>
<p>stop after N pagemove shuffling operations, where suffling all the
pages in the mmap'd region is equivalent to 1 bogo-operation.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory page swapping stressor</strong></dt>
<dd>
<p><strong>--pageswap N</strong> start N workers that exercise page swap
in and swap out. Pages are allocated and paged out using madvise
MADV_PAGEOUT. One the maximum per process number of mmaps are reached or
65536 pages are allocated the pages are read to page them back in and
unmapped in reverse mapping order.</p>
<dl>
<dt><strong>--pageswap-ops N</strong></dt>
<dd>
<p>stop after N page allocation bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>PCI sysfs stressor (Linux)</strong></dt>
<dd>
<p><strong>--pci N</strong> exercise PCI sysfs by running N workers that
read data (and mmap/unmap PCI config or PCI resource files). Linux only.
Running as root will allow config and resource mmappings to be read and
exercises PCI I/O mapping.</p>
<dl>
<dt><strong>--pci-ops N</strong></dt>
<dd>
<p>stop pci stress workers after N PCI subdirectory exercising
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Personality stressor</strong></dt>
<dd>
<p><strong>--personality N</strong> start N workers that attempt to set
personality and get all the available personality types (process
execution domain types) via the personality(2) system call. (Linux
only).</p>
<dl>
<dt><strong>--personality-ops N</strong></dt>
<dd>
<p>stop personality stress workers after N bogo personality
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Mutex using Peterson algorithm stressor</strong></dt>
<dd>
<p><strong>--peterson N</strong> start N workers that exercises mutex
exclusion between two processes using shared memory with the Peterson
Algorithm. Where possible this uses memory fencing and falls back to
using GCC __sync_synchronize if they are not available. The stressors
contain simple mutex and memory coherency sanity checks.</p>
<dl>
<dt><strong>--peterson-ops N</strong></dt>
<dd>
<p>stop peterson workers after N mutex operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Page map stressor</strong></dt>
<dd>
<p><strong>--physpage N</strong> start N workers that use
/proc/self/pagemap and /proc/kpagecount to determine the physical page
and page count of a virtual mapped page and a page that is shared among
all the stressors. Linux only and requires the CAP_SYS_ADMIN
capabilities.</p>
<dl>
<dt><strong>--physpage-mtrr</strong></dt>
<dd>
<p>enable setting various memory type rage register (MTRR) types on
physical pages (Linux and x86 only).</p>
</dd>
<dt><strong>--physpage-ops N</strong></dt>
<dd>
<p>stop physpage stress workers after N bogo physical address
lookups.</p>
</dd>
</dl>
</dd>
<dt><strong>Process signals (pidfd_send_signal) stressor</strong></dt>
<dd>
<p><strong>--pidfd N</strong> start N workers that exercise signal
sending via the pidfd_send_signal system call. This stressor creates
child processes and checks if they exist and can be stopped, restarted
and killed using the pidfd_send_signal system call.</p>
<dl>
<dt><strong>--pidfd-ops N</strong></dt>
<dd>
<p>stop pidfd stress workers after N child processes have been created,
tested and killed with pidfd_send_signal.</p>
</dd>
</dl>
</dd>
<dt><strong>Localhost ICMP (ping) stressor</strong></dt>
<dd>
<p><strong>--ping-sock N</strong> start N workers that send small
randomized ICMP messages to the localhost across a range of ports
(1024..65535) using a "ping" socket with an AF_INET domain, a SOCK_DGRAM
socket type and an IPPROTO_ICMP protocol.</p>
<dl>
<dt><strong>--ping-sock-ops N</strong></dt>
<dd>
<p>stop the ping-sock stress workers after N ICMP messages are sent.</p>
</dd>
</dl>
</dd>
<dt><strong>Large pipe stressor</strong></dt>
<dd>
<p><strong>-p N, --pipe N</strong> start N workers that perform large
pipe writes and reads to exercise pipe I/O. This exercises memory write
and reads as well as context switching. Each worker has two processes, a
reader and a writer.</p>
<dl>
<dt><strong>--pipe-data-size N</strong></dt>
<dd>
<p>specifies the size in bytes of each write to the pipe (range from 4
bytes to 4096 bytes). Setting a small data size will cause more writes
to be buffered in the pipe, hence reducing the context switch rate
between the pipe writer and pipe reader processes. Default size is the
page size.</p>
</dd>
<dt><strong>--pipe-ops N</strong></dt>
<dd>
<p>stop pipe stress workers after N bogo pipe write operations.</p>
</dd>
<dt><strong>--pipe-vmsplice</strong></dt>
<dd>
<p>use vmsplice(2) to splice data pages to/from pipe. Requires pipe
packet mode using O_DIRECT and buffer twice the size of the pipe to
ensure verification data sequences.</p>
</dd>
<dt><strong>--pipe-size N</strong></dt>
<dd>
<p>specifies the size of the pipe in bytes (for systems that support the
F_SETPIPE_SZ fcntl() command). Setting a small pipe size will cause the
pipe to fill and block more frequently, hence increasing the context
switch rate between the pipe writer and the pipe reader processes. As of
version 0.15.11 the default size is 4096 bytes.</p>
</dd>
</dl>
</dd>
<dt><strong>Shared pipe stressor</strong></dt>
<dd>
<p><strong>--pipeherd N</strong> start N workers that pass a 64 bit
token counter to/from 100 child processes over a shared pipe. This
forces a high context switch rate and can trigger a "thundering herd" of
wakeups on processes that are blocked on pipe waits.</p>
<dl>
<dt><strong>--pipeherd-ops N</strong></dt>
<dd>
<p>stop pipe stress workers after N bogo pipe write operations.</p>
</dd>
<dt><strong>--pipeherd-yield</strong></dt>
<dd>
<p>force a scheduling yield after each write, this increases the context
switch rate.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory protection key mechanism stressor
(Linux)</strong></dt>
<dd>
<p><strong>--pkey N</strong> start N workers that change memory
protection using a protection key (pkey) and the pkey_mprotect call
(Linux only). This will try to allocate a pkey and use this for the page
protection, however, if this fails then the special pkey -1 will be used
(and the kernel will use the normal mprotect mechanism instead). Various
page protection mixes of read/write/exec/none will be cycled through on
randomly chosen pre-allocated pages.</p>
<dl>
<dt><strong>--pkey-ops N</strong></dt>
<dd>
<p>stop after N pkey_mprotect page protection cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>Stress-ng plugin stressor</strong></dt>
<dd>
<p><strong>--plugin N</strong> start N workers that run user provided
stressor functions loaded from a shared library. The shared library can
contain one or more stressor functions prefixed with stress_ in their
name. By default the plugin stressor will find all functions prefixed
with stress_ in their name and exercise these one by one in a
round-robin loop, but a specific stressor can be selected using the
--plugin-method option. The stressor function takes no parameters and
returns 0 for success and non-zero for failure (and will terminate the
plugin stressor). Each time a stressor function is executed the bogo-op
counter is incremented by one. The following example performs 10,000 nop
instructions per bogo-op:</p>
<pre><code>int stress_example(void)
{
        int i;

        for (i = 0; i &lt; 10000; i++) {
                __volatile__ __asm__(&quot;nop&quot;);
        }
        return 0;  /* Success */
}</code></pre>
<blockquote>
<p>and compile the source into a shared library as, for example:</p>
</blockquote>
<pre><code>gcc -fpic -shared -o example.so example.c</code></pre>
<blockquote>
<p>and run as using:</p>
</blockquote>
<pre><code>stress-ng --plugin 1 --plugin-so ./example.so</code></pre>
<dl>
<dt><strong>--plugin-method function</strong></dt>
<dd>
<p>run a specific stressor function, specify the name without the
leading stress_ prefix.</p>
</dd>
<dt><strong>--plugin-ops N</strong></dt>
<dd>
<p>stop after N iterations of the user provided stressor
function(s).</p>
</dd>
<dt><strong>--plugin-so name</strong></dt>
<dd>
<p>specify the shared library containing the user provided stressor
function(s).</p>
</dd>
</dl>
</dd>
<dt><strong>Polling stressor</strong></dt>
<dd>
<p><strong>-P N, --poll N</strong> start N workers that perform zero
timeout polling via the poll(2), ppoll(2), select(2), pselect(2) and
sleep(3) calls. This wastes system and user time doing nothing.</p>
<dl>
<dt><strong>--poll-fds N</strong></dt>
<dd>
<p>specify the number of file descriptors to poll/ppoll/select/pselect
on. The maximum number for select/pselect is limited by FD_SETSIZE and
the upper maximum is also limited by the maximum number of pipe open
descriptors allowed.</p>
</dd>
<dt><strong>--poll-ops N</strong></dt>
<dd>
<p>stop poll stress workers after N bogo poll operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Prctl stressor</strong></dt>
<dd>
<p><strong>--prctl N</strong> start N workers that exercise the majority
of the prctl(2) system call options. Each batch of prctl calls is
performed inside a new child process to ensure the limit of prctl is
contained inside a new process every time. Some prctl options are
architecture specific, however, this stressor will exercise these even
if they are not implemented.</p>
<dl>
<dt><strong>--prctl-ops N</strong></dt>
<dd>
<p>stop prctl workers after N batches of prctl calls</p>
</dd>
</dl>
</dd>
<dt><strong>L3 cache prefetching stressor</strong></dt>
<dd>
<p><strong>--prefetch N</strong> start N workers that benchmark prefetch
and non-prefetch reads of a L3 cache sized buffer. The buffer is read
with loops of 8 × 64 bit reads per iteration. In the prefetch cases,
data is prefetched ahead of the current read position by various sized
offsets, from 64 bytes to 8K to find the best memory read throughput.
The stressor reports the non-prefetch read rate and the best prefetched
read rate. It also reports the prefetch offset and an estimate of the
amount of time between the prefetch issue and the actual memory read
operation. These statistics will vary from run-to-run due to system
noise and CPU frequency scaling.</p>
<dl>
<dt><strong>--prefetch-l3-size N</strong></dt>
<dd>
<p>specify the size of the l3 cache</p>
</dd>
<dt><strong>--prefetch-method N</strong></dt>
<dd>
<p>select the prefetching method. Available methods are:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">builtin</td>
<td style="text-align: left;">Use the __builtin_prefetch(3) function for
prefetching. This is the default.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">builtinl0</td>
<td style="text-align: left;">Use the __builtin_prefetch(3) function for
prefetching, with a locality 0 hint.</td>
</tr>
<tr class="even">
<td style="text-align: left;">builtinl3</td>
<td style="text-align: left;">Use the __builtin_prefetch(3) function for
prefetching, with a locality 3 hint.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dcbt</td>
<td style="text-align: left;">Use the ppc64 dcbt instruction to fetch
data into the L1 cache (ppc64 only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">dcbtst</td>
<td style="text-align: left;">Use the ppc64 dcbtst instruction to fetch
data into the L1 cache (ppc64 only).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prefetcht0</td>
<td style="text-align: left;">Use the x86 prefetcht0 instruction to
prefetch data into all levels of the cache hierarchy (x86 only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">prefetcht1</td>
<td style="text-align: left;">Use the x86 prefetcht1 instruction
(temporal data with respect to first level cache) to prefetch data into
level 2 cache and higher (x86 only).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prefetcht2</td>
<td style="text-align: left;">Use the x86 prefetcht2 instruction
(temporal data with respect to second level cache) to prefetch data into
level 2 cache and higher (x86 only).</td>
</tr>
<tr class="even">
<td style="text-align: left;">prefetchnta</td>
<td style="text-align: left;">Use the x86 prefetchnta instruction
(non-temporal data with respect to all cache levels) into a location
close to the processor, minimizing cache pollution (x86 only).</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--prefetch-ops N</strong></dt>
<dd>
<p>stop prefetch stressors after N benchmark operations</p>
</dd>
</dl>
</dd>
<dt><strong>Priority inversion stressor</strong></dt>
<dd>
<p><strong>--prio-inv N</strong> start N workers that exercise mutex
lock priority inversion scheduling. Three child process run with low,
medium and high FIFO scheduling priorities. The processes with low and
high priorities share a mutex lock that both try to lock and unlock,
aiming to make the low priority process block the high priority process.
Meanwhile the middle priority process will run in priority over the low
priority process, causing the high priority process to become
unrunnable.</p>
<dl>
<dt><strong>--prio-inv-ops N</strong></dt>
<dd>
<p>stop after N bogo lock/unlock operations.</p>
</dd>
<dt><strong>--prio-inv-type [ inherit | none | protect ]</strong></dt>
<dd>
<p>select the mutex lock priority inversion type, described as
follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Type</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">inherit</td>
<td style="text-align: left;">The priority of the process owning the
mutex lock is run with highest priority of any other process waiting on
the lock to avoid priority inversion deadlock.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">none</td>
<td style="text-align: left;">The priority of the process owning the
mutex lock is not affected by its mutex ownership. This may lead to the
high priority process to become unrunnable on a single thread
system.</td>
</tr>
<tr class="even">
<td style="text-align: left;">protect</td>
<td style="text-align: left;">The priority of the process owning the
mutex lock is given the priority of the mutex (in this stress test case,
the maximum priority) during the lock ownership.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--prio-inv-policy [ batch, idle, fifo, other, rr
]</strong></dt>
<dd>
<p>select the scheduling policy. "Normal" policies (batch, idle and
other) can be selected as an unprivileged user, however "Real Time"
policies (fifo and rr) can only be selected with the appropriate
privilege. By default "rr" is selected but will it fall back to "other"
for unprivileged users.</p>
</dd>
</dl>
</dd>
<dt><strong>Privileged CPU instructions stressor</strong></dt>
<dd>
<p><strong>--priv-instr N</strong> start N workers that exercise various
architecture specific privileged instructions that cannot be executed by
userspace programs. These instructions will be trapped and processed by
SIGSEGV or SIGILL signal handlers.</p>
<dl>
<dt><strong>--priv-instr-ops N</strong></dt>
<dd>
<p>stop priv-instr stressors after N rounds of executing privileged
instructions.</p>
</dd>
</dl>
</dd>
<dt><strong>/proc stressor</strong></dt>
<dd>
<p><strong>--procfs N</strong> start N workers that read files from
/proc and recursively read files from /proc/self (Linux only).</p>
<dl>
<dt><strong>--procfs-ops N</strong></dt>
<dd>
<p>stop procfs reading after N bogo read operations. Note, since the
number of entries may vary between kernels, this bogo ops metric is
probably very misleading.</p>
</dd>
</dl>
</dd>
<dt><strong>Pthread stressor</strong></dt>
<dd>
<p><strong>--pthread N</strong> start N workers that iteratively creates
and terminates multiple pthreads (the default is 1024 pthreads per
worker). In each iteration, each newly created pthread waits until the
worker has created all the pthreads and then they all terminate
together.</p>
<dl>
<dt><strong>--pthread-max N</strong></dt>
<dd>
<p>create N pthreads per worker. If the product of the number of
pthreads by the number of workers is greater than the soft limit of
allowed pthreads then the maximum is re-adjusted down to the maximum
allowed.</p>
</dd>
<dt><strong>--pthread-ops N</strong></dt>
<dd>
<p>stop pthread workers after N bogo pthread create operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Ptrace stressor</strong></dt>
<dd>
<p><strong>--ptrace N</strong> start N workers that fork and trace
system calls of a child process using ptrace(2).</p>
<dl>
<dt><strong>--ptrace-ops N</strong></dt>
<dd>
<p>stop ptracer workers after N bogo system calls are traced.</p>
</dd>
</dl>
</dd>
<dt><strong>Pseudo-terminals (pty) stressor</strong></dt>
<dd>
<p><strong>--pty N</strong> start N workers that repeatedly attempt to
open pseudoterminals and perform various pty ioctls upon the ptys before
closing them.</p>
<dl>
<dt><strong>--pty-max N</strong></dt>
<dd>
<p>try to open a maximum of N pseudoterminals, the default is 65536. The
allowed range of this setting is 8..65536.</p>
</dd>
<dt><strong>--pty-ops N</strong></dt>
<dd>
<p>stop pty workers after N pty bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Qsort stressor</strong></dt>
<dd>
<p><strong>-Q, --qsort N</strong> start N workers that sort 32 bit
integers using qsort.</p>
<dl>
<dt><strong>--qsort-method [ qsort-libc | qsort-bm ]</strong></dt>
<dd>
<p>select either the libc implementation of qsort or the J. L. Bentley
and M. D. McIlroy implementation of qsort. The default is the libc
implementation.</p>
</dd>
<dt><strong>--qsort-ops N</strong></dt>
<dd>
<p>stop qsort stress workers after N bogo qsorts.</p>
</dd>
<dt><strong>--qsort-size N</strong></dt>
<dd>
<p>specify number of 32 bit integers to sort, default is 262144 (256 ×
1024).</p>
</dd>
</dl>
</dd>
<dt><strong>Quota stressor</strong></dt>
<dd>
<p><strong>--quota N</strong> start N workers that exercise the
Q_GETQUOTA, Q_GETFMT, Q_GETINFO, Q_GETSTATS and Q_SYNC quotactl(2)
commands on all the available mounted block based file systems. Requires
CAP_SYS_ADMIN capability to run.</p>
<dl>
<dt><strong>--quota-ops N</strong></dt>
<dd>
<p>stop quota stress workers after N bogo quotactl operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Process scheduler stressor</strong></dt>
<dd>
<p><strong>--race-sched N</strong> start N workers that exercise rapid
changing CPU affinity child processes both from the controlling stressor
and by the child processes. Child processes are created and terminated
rapidly with the aim to create race conditions where affinity changing
occurs during process run states.</p>
<dl>
<dt><strong>--race-sched-method [ all | next | prev | rand | randinc |
syncnext | syncprev ]</strong></dt>
<dd>
<p>Select the method moving a process to a specific CPU. Available
methods are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the race-sched methods as
listed below:</td>
</tr>
<tr class="odd">
<td style="text-align: left;">next</td>
<td style="text-align: left;">move a process to the next CPU, wrap
around to zero when maximum CPU is reached.</td>
</tr>
<tr class="even">
<td style="text-align: left;">prev</td>
<td style="text-align: left;">move a process to the previous CPU, wrap
around to the maximum CPU when the first CPU is reached.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rand</td>
<td style="text-align: left;">move a process to any randomly chosen
CPU.</td>
</tr>
<tr class="even">
<td style="text-align: left;">randinc</td>
<td style="text-align: left;">move a process to the current CPU + a
randomly chosen value 1..4, modulo the number of CPUs.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">syncnext</td>
<td style="text-align: left;">move synchronously all the race-sched
stressor processes to the next CPU every second; this loads just 1 CPU
at a time in a round-robin method.</td>
</tr>
<tr class="even">
<td style="text-align: left;">syncprev</td>
<td style="text-align: left;">move synchronously all the race-sched
stressor processes to the previous CPU every second; this loads just 1
CPU at a time in a round-robin method.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--race-sched-ops N</strong></dt>
<dd>
<p>stop after N process creation bogo-operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Radixsort stressor</strong></dt>
<dd>
<p><strong>--radixsort N</strong> start N workers that sort random 8
byte strings using radixsort.</p>
<dl>
<dt><strong>--radixsort-method [ radixsort-libc | radixsort-nonlibc
]</strong></dt>
<dd>
<p>select either the libc implementation of radixsort or an optimized
implementation of radixsort. The default is the libc implementation if
it is available.</p>
</dd>
<dt><strong>--radixsort-ops N</strong></dt>
<dd>
<p>stop radixsort stress workers after N bogo radixsorts.</p>
</dd>
<dt><strong>--radixsort-size N</strong></dt>
<dd>
<p>specify number of strings to sort, default is 262144 (256 ×
1024).</p>
</dd>
</dl>
</dd>
<dt><strong>Memory filesystem stressor</strong></dt>
<dd>
<p><strong>--ramfs N</strong> start N workers mounting a memory based
file system using ramfs and tmpfs (Linux only). This alternates between
mounting and umounting a ramfs or tmpfs file system using the
traditional mount(2) and umount(2) system call as well as the newer
Linux 5.2 fsopen(2), fsmount(2), fsconfig(2) and move_mount(2) system
calls if they are available. The default ram file system size is
2MB.</p>
<dl>
<dt><strong>--ramfs-fill</strong></dt>
<dd>
<p>fill ramfs with zero'd data using fallocate(2) if it is available or
multiple calls to write(2) if not.</p>
</dd>
<dt><strong>--ramfs-ops N</strong></dt>
<dd>
<p>stop after N ramfs mount operations.</p>
</dd>
<dt><strong>--ramfs-size N</strong></dt>
<dd>
<p>set the ramfs size (must be multiples of the page size).</p>
</dd>
</dl>
</dd>
<dt><strong>Raw device stressor</strong></dt>
<dd>
<p><strong>--rawdev N</strong> start N workers that read the underlying
raw drive device using direct IO reads. The device (with minor number 0)
that stores the current working directory is the raw device to be read
by the stressor. The read size is exactly the size of the underlying
device block size. By default, this stressor will exercise all the of
the rawdev methods (see the --rawdev-method option). This is a Linux
only stressor and requires root privilege to be able to read the raw
device.</p>
<dl>
<dt><strong>--rawdev-method method</strong></dt>
<dd>
<p>Available rawdev stress methods are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the rawdev stress methods
as listed below:</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sweep</td>
<td style="text-align: left;">repeatedly read across the raw device from
the 0th block to the end block in steps of the number of blocks on the
device / 128 and back to the start again.</td>
</tr>
<tr class="even">
<td style="text-align: left;">wiggle</td>
<td style="text-align: left;">repeatedly read across the raw device in
128 evenly steps with each step reading 1024 blocks backwards from each
step.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ends</td>
<td style="text-align: left;">repeatedly read the first and last 128
start and end blocks of the raw device alternating from start of the
device to the end of the device.</td>
</tr>
<tr class="even">
<td style="text-align: left;">random</td>
<td style="text-align: left;">repeatedly read 256 random blocks</td>
</tr>
<tr class="odd">
<td style="text-align: left;">burst</td>
<td style="text-align: left;">repeatedly read 256 sequential blocks
starting from a random block on the raw device.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--rawdev-ops N</strong></dt>
<dd>
<p>stop the rawdev stress workers after N raw device read bogo
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Random list stressor</strong></dt>
<dd>
<p><strong>--randlist N</strong> start N workers that creates a list of
objects in randomized memory order and traverses the list setting and
reading the objects. This is designed to exerise memory and cache
thrashing. Normally the objects are allocated on the heap, however for
objects of page size or larger there is a 1 in 16 chance of objects
being allocated using shared anonymous memory mapping to mix up the
address spaces of the allocations to create more TLB thrashing.</p>
<dl>
<dt><strong>--randist-compact</strong></dt>
<dd>
<p>Allocate all the list objects using one large heap allocation and
divide this up for all the list objects. This removes the overhead of
the heap keeping track of each list object, hence uses less memory.</p>
</dd>
<dt><strong>--randlist-items N</strong></dt>
<dd>
<p>Allocate N items on the list. By default, 100,000 items are
allocated.</p>
</dd>
<dt><strong>--randlist-ops N</strong></dt>
<dd>
<p>stop randlist workers after N list traversals</p>
</dd>
<dt><strong>--randlist-size N</strong></dt>
<dd>
<p>Allocate each item to be N bytes in size. By default, the size is 64
bytes of data payload plus the list handling pointer overhead.</p>
</dd>
</dl>
</dd>
<dt><strong>Localhost raw socket stressor</strong></dt>
<dd>
<p><strong>--rawsock N</strong> start N workers that send and receive
packet data using raw sockets on the localhost. Requires CAP_NET_RAW to
run.</p>
<dl>
<dt><strong>--rawsock-ops N</strong></dt>
<dd>
<p>stop rawsock workers after N packets are received.</p>
</dd>
<dt><strong>--rawsock-port P</strong></dt>
<dd>
<p>start at socket port P. For N rawsock worker processes, ports P to P
- 1 are used.</p>
</dd>
</dl>
</dd>
<dt><strong>Localhost ethernet raw packets stressor</strong></dt>
<dd>
<p><strong>--rawpkt N</strong> start N workers that sends and receives
ethernet packets using raw packets on the localhost via the loopback
device. Requires CAP_NET_RAW to run.</p>
<dl>
<dt><strong>--rawpkt-ops N</strong></dt>
<dd>
<p>stop rawpkt workers after N packets from the sender process are
received.</p>
</dd>
<dt><strong>--rawpkt-port N</strong></dt>
<dd>
<p>start at port P. For N rawpkt worker processes, ports P to (P * 4) -
1 are used. The default starting port is port 14000.</p>
</dd>
<dt><strong>--rawpkt-rxring N</strong></dt>
<dd>
<p>setup raw packets with RX ring with N number of blocks, this selects
TPACKET_V. N must be one of 1, 2, 4, 8 or 16.</p>
</dd>
</dl>
</dd>
<dt><strong>Localhost raw UDP packet stressor</strong></dt>
<dd>
<p><strong>--rawudp N</strong> start N workers that send and receive UDP
packets using raw sockets on the localhost. Requires CAP_NET_RAW to
run.</p>
<dl>
<dt><strong>--rawudp-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--rawudp-ops N</strong></dt>
<dd>
<p>stop rawudp workers after N packets are received.</p>
</dd>
<dt><strong>--rawudp-port N</strong></dt>
<dd>
<p>start at port P. For N rawudp worker processes, ports P to (P * 4) -
1 are used. The default starting port is port 13000.</p>
</dd>
</dl>
</dd>
<dt><strong>Random number generator stressor</strong></dt>
<dd>
<p><strong>--rdrand N</strong> start N workers that read a random number
from an on-chip random number generator This uses the rdrand instruction
on Intel x86 processors or the darn instruction on Power9
processors.</p>
<dl>
<dt><strong>--rdrand-ops N</strong></dt>
<dd>
<p>stop rdrand stress workers after N bogo rdrand operations (1 bogo op
= 2048 random bits successfully read).</p>
</dd>
<dt><strong>--rdrand-seed</strong></dt>
<dd>
<p>use rdseed instead of rdrand (x86 only).</p>
</dd>
</dl>
</dd>
<dt><strong>Read-ahead stressor</strong></dt>
<dd>
<p><strong>--readahead N</strong> start N workers that randomly seek and
perform 4096 byte read/write I/O operations on a file with readahead.
The default file size is 64 MB. Readaheads and reads are batched into 16
readaheads and then 16 reads.</p>
<dl>
<dt><strong>--readahead-bytes N</strong></dt>
<dd>
<p>set the size of readahead file, the default is 1 GB. One can specify
the size as % of free space on the file system or in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--readahead-ops N</strong></dt>
<dd>
<p>stop readahead stress workers after N bogo read operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Reboot stressor</strong></dt>
<dd>
<p><strong>--reboot N</strong> start N workers that exercise the
reboot(2) system call. When possible, it will create a process in a PID
namespace and perform a reboot power off command that should shutdown
the process. Also, the stressor exercises invalid reboot magic values
and invalid reboots when there are insufficient privileges that will not
actually reboot the system.</p>
<dl>
<dt><strong>--reboot-ops N</strong></dt>
<dd>
<p>stop the reboot stress workers after N bogo reboot cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU registers stressor</strong></dt>
<dd>
<p><strong>--regs N</strong> start N workers that shuffle data around
the CPU registers exercising register move instructions. Each bogo-op
represents 1000 calls of a shuffling function that shuffles the
registers 32 times. Only implemented for the GCC compiler since this
requires register annotations and optimization level 0 to compile
appropriately.</p>
<dl>
<dt><strong>--regs-ops N</strong></dt>
<dd>
<p>stop regs stressors after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory page reordering stressor</strong></dt>
<dd>
<p><strong>--remap N</strong> start N workers that map 512 pages and
re-order these pages using the deprecated system call
remap_file_pages(2). Several page re-orderings are exercised: forward,
reverse, random and many pages to 1 page.</p>
<dl>
<dt><strong>--remap-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd huge pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--remap-ops N</strong></dt>
<dd>
<p>stop after N remapping bogo operations.</p>
</dd>
<dt><strong>--remap-pages N</strong></dt>
<dd>
<p>specify number of pages to remap, must be a power of 2, default is
512 pages.</p>
</dd>
</dl>
</dd>
<dt><strong>Renaming file stressor</strong></dt>
<dd>
<p><strong>-R N, --rename N</strong> start N workers that each create a
file and then repeatedly rename it.</p>
<dl>
<dt><strong>--rename-ops N</strong></dt>
<dd>
<p>stop rename stress workers after N bogo rename operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Process rescheduling stressor</strong></dt>
<dd>
<p><strong>--resched N</strong> start N workers that exercise process
rescheduling. Each stressor spawns a child process for each of the
positive nice levels and iterates over the nice levels from 0 to the
lowest priority level (highest nice value). For each of the nice levels
1024 iterations over 3 non-real time scheduling polices SCHED_OTHER,
SCHED_BATCH and SCHED_IDLE are set and a sched_yield occurs to force
heavy rescheduling activity. When the -v verbose option is used the
distribution of the number of yields across the nice levels is printed
for the first stressor out of the N stressors.</p>
<dl>
<dt><strong>--resched-ops N</strong></dt>
<dd>
<p>stop after N rescheduling sched_yield calls.</p>
</dd>
</dl>
</dd>
<dt><strong>System resources stressor</strong></dt>
<dd>
<p><strong>--resources N</strong> start N workers that consume various
system resources. Each worker will spawn 1024 child processes that
iterate 1024 times consuming shared memory, heap, stack, temporary files
and various file descriptors (eventfds, memoryfds, userfaultfds, pipes
and sockets).</p>
<dl>
<dt><strong>--resources-mlock</strong></dt>
<dd>
<p>attempt to mlock mmap'd pages into memory causing more memory
pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--resources-ops N</strong></dt>
<dd>
<p>stop after N resource child forks.</p>
</dd>
</dl>
</dd>
<dt><strong>Writing temporary files in reverse position
stressor</strong></dt>
<dd>
<p><strong>--revio N</strong> start N workers continually writing in
reverse position order to temporary files. The default mode is to stress
test reverse position ordered writes with randomly sized sparse holes
between each write. With the --aggressive option enabled without any
--revio-opts options the revio stressor will work through all the
--revio-opt options one by one to cover a range of I/O options.</p>
<dl>
<dt><strong>--revio-bytes N</strong></dt>
<dd>
<p>write N bytes for each revio process, the default is 1 GB. One can
specify the size as % of free space on the file system or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--revio-opts list</strong></dt>
<dd>
<p>specify various stress test options as a comma separated list.
Options are the same as --hdd-opts but without the iovec option.</p>
</dd>
<dt><strong>--revio-ops N</strong></dt>
<dd>
<p>stop revio stress workers after N bogo operations.</p>
</dd>
<dt><strong>--revio-write-size N</strong></dt>
<dd>
<p>specify size of each write in bytes. Size can be from 1 byte to
4MB.</p>
</dd>
</dl>
</dd>
<dt><strong>Ring pipes stressor</strong></dt>
<dd>
<p><strong>--ring-pipe N</strong> start N workers that move data around
a ring of pipes using poll to detect when data is ready to copy. By
default, 256 pipes are used with two 4096 byte items of data being
copied around the ring of pipes. Data is copied using read and write
system calls. If the splice system call is available then one can use
splice to use more efficient in-kernel data passing instead of buffer
copying.</p>
<dl>
<dt><strong>--ring-pipe-num N</strong></dt>
<dd>
<p>specify the number of pipes to use. Ranges from 4 to 262144, default
is 256.</p>
</dd>
<dt><strong>--ring-pipe-ops N</strong></dt>
<dd>
<p>stop after N pipe data transfers.</p>
</dd>
<dt><strong>--ring-pipe-size N</strong></dt>
<dd>
<p>specify the size of data being copied in bytes. Ranges from 1 to
4096, default is 4096.</p>
</dd>
<dt><strong>--ring-pipe-splice</strong></dt>
<dd>
<p>enable splice to move data between pipes (only if splice() is
available).</p>
</dd>
</dl>
</dd>
<dt><strong>Rlimit stressor</strong></dt>
<dd>
<p><strong>--rlimit N</strong> start N workers that exceed CPU and file
size resource imits, generating SIGXCPU and SIGXFSZ signals.</p>
<dl>
<dt><strong>--rlimit-ops N</strong></dt>
<dd>
<p>stop after N bogo resource limited SIGXCPU and SIGXFSZ signals have
been caught.</p>
</dd>
</dl>
</dd>
<dt><strong>VM reverse-mapping stressor</strong></dt>
<dd>
<p><strong>--rmap N</strong> start N workers that exercise the VM
reverse-mapping. This creates 16 processes per worker that write/read
multiple file-backed memory mappings. There are 64 lots of 4 page
mappings made onto the file, with each mapping overlapping the previous
by 3 pages and at least 1 page of non-mapped memory between each of the
mappings. Data is synchronously msync'd to the file 1 in every 256
iterations in a random manner.</p>
<dl>
<dt><strong>--rmap-ops N</strong></dt>
<dd>
<p>stop after N bogo rmap memory writes/reads.</p>
</dd>
</dl>
</dd>
<dt><strong>1 bit rotation stressor</strong></dt>
<dd>
<p><strong>--rotate N</strong> start N workers that exercise 1 bit
rotates left and right of unsigned integer variables. The default will
rotate four 8, 16, 32, 64 (and if supported 128) bit values 10000 times
in a loop per bogo-op.</p>
<dl>
<dt><strong>--rotate-method method</strong></dt>
<dd>
<p>specify the method of rotation to use. The 'all' method uses all the
methods and is the default.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">exercise with all the rotate stressor
methods (see below):</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rol8</td>
<td style="text-align: left;">8 bit unsigned rotate left by 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror8</td>
<td style="text-align: left;">8 bit unsigned rotate right by 1 bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rol16</td>
<td style="text-align: left;">16 bit unsigned rotate left by 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror16</td>
<td style="text-align: left;">16 bit unsigned rotate right by 1 bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rol32</td>
<td style="text-align: left;">32 bit unsigned rotate left by 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror32</td>
<td style="text-align: left;">32 bit unsigned rotate right by 1 bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rol64</td>
<td style="text-align: left;">64 bit unsigned rotate left by 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror64</td>
<td style="text-align: left;">64 bit unsigned rotate right by 1 bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rol128</td>
<td style="text-align: left;">128 bit unsigned rotate left by 1 bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror128</td>
<td style="text-align: left;">128 bit unsigned rotate right by 1
bit</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--rotate-ops N</strong></dt>
<dd>
<p>stop after N bogo rotate operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Restartable sequences (rseq) stressor (Linux)</strong></dt>
<dd>
<p><strong>--rseq N</strong> start N workers that exercise restartable
sequences via the rseq(2) system call. This loops over a long duration
critical section that is likely to be interrupted. A rseq abort handler
keeps count of the number of interruptions and a SIGSEV handler also
tracks any failed rseq aborts that can occur if there is a mismatch in a
rseq check signature. Linux only.</p>
<dl>
<dt><strong>--rseq-ops N</strong></dt>
<dd>
<p>stop after N bogo rseq operations. Each bogo rseq operation is
equivalent to 10000 iterations over a long duration rseq handled
critical section.</p>
</dd>
</dl>
</dd>
<dt><strong>Real-time clock stressor</strong></dt>
<dd>
<p><strong>--rtc N</strong> start N workers that exercise the real time
clock (RTC) interfaces via /dev/rtc and /sys/class/rtc/rtc0. No
destructive writes (modifications) are performed on the RTC. This is a
Linux only stressor.</p>
<dl>
<dt><strong>--rtc-ops N</strong></dt>
<dd>
<p>stop after N bogo RTC interface accesses.</p>
</dd>
</dl>
</dd>
<dt><strong>Fast process rescheduling stressor</strong></dt>
<dd>
<p><strong>--schedmix N</strong> start N workers that each start child
processes that repeatedly select random a scheduling policy and then
executes a short duration randomly chosen time consuming activity. This
exercises rapid re-scheduling of processes and generates a large amount
of scheduling timer interrupts.</p>
<dl>
<dt><strong>--schedmix-ops N</strong></dt>
<dd>
<p>stop after N scheduling mixed operations.</p>
</dd>
<dt><strong>--schedmix-procs N</strong></dt>
<dd>
<p>specify the number of chid processes to run for each stressor
instance, range from 1 to 64, default is 16.</p>
</dd>
</dl>
</dd>
<dt><strong>Scheduling policy stressor</strong></dt>
<dd>
<p><strong>--schedpolicy N</strong> start N workers that set the worker
to various available scheduling policies out of SCHED_OTHER,
SCHED_BATCH, SCHED_IDLE, SCHED_FIFO, SCHED_RR and SCHED_DEADLINE. For
the real time scheduling policies a random sched priority is selected
between the minimum and maximum scheduling priority settings.</p>
<dl>
<dt><strong>--schedpolicy-ops N</strong></dt>
<dd>
<p>stop after N bogo scheduling policy changes.</p>
</dd>
<dt><strong>--schedpolicy-rand</strong></dt>
<dd>
<p>Select scheduling policy randomly so that the new policy is always
different to the previous policy. The default is to work through the
scheduling policies sequentially.</p>
</dd>
</dl>
</dd>
<dt><strong>Stream control transmission protocol (SCTP)
stressor</strong></dt>
<dd>
<p><strong>--sctp N</strong> start N workers that perform network sctp
stress activity using the Stream Control Transmission Protocol (SCTP).
This involves client/server processes performing rapid connect,
send/receives and disconnects on the local host.</p>
<dl>
<dt><strong>--sctp-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is ipv4. Currently ipv4 and
ipv6 are supported.</p>
</dd>
<dt><strong>--sctp-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--sctp-ops N</strong></dt>
<dd>
<p>stop sctp workers after N bogo operations.</p>
</dd>
<dt><strong>--sctp-port P</strong></dt>
<dd>
<p>start at sctp port P. For N sctp worker processes, ports P to (P * 4)
- 1 are used for ipv4, ipv6 domains and ports P to P - 1 are used for
the unix domain.</p>
</dd>
<dt><strong>--sctp-sched [ fcfs | prio | rr ]</strong></dt>
<dd>
<p>specify SCTP scheduler, one of fcfs (default), prio (priority) or rr
(round-robin).</p>
</dd>
</dl>
</dd>
<dt><strong>File sealing (SEAL) stressor (Linux)</strong></dt>
<dd>
<p><strong>--seal N</strong> start N workers that exercise the fcntl(2)
SEAL commands on a small anonymous file created using memfd_create(2).
After each SEAL command is issued the stressor also sanity checks if the
seal operation has sealed the file correctly. (Linux only).</p>
<dl>
<dt><strong>--seal-ops N</strong></dt>
<dd>
<p>stop after N bogo seal operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Secure computing stressor</strong></dt>
<dd>
<p><strong>--seccomp N</strong> start N workers that exercise Secure
Computing system call filtering. Each worker creates child processes
that write a short message to /dev/null and then exits. 2% of the child
processes have a seccomp filter that disallows the write system call and
hence it is killed by seccomp with a SIGSYS. Note that this stressor can
generate many audit log messages each time the child is killed. Requires
CAP_SYS_ADMIN to run.</p>
<dl>
<dt><strong>--seccomp-ops N</strong></dt>
<dd>
<p>stop seccomp stress workers after N seccomp filter tests.</p>
</dd>
</dl>
</dd>
<dt><strong>Secret memory stressor (Linux &gt;= 5.11)</strong></dt>
<dd>
<p><strong>--secretmem N</strong> start N workers that mmap pages using
file mapping off a memfd_secret file descriptor. Each stress loop
iteration will expand the mappable region by 3 pages using ftruncate and
mmap and touches the pages. The pages are then fragmented by unmapping
the middle page and then umapping the first and last pages. This tries
to force page fragmentation and also trigger out of memory (OOM) kills
of the stressor when the secret memory is exhausted. Note this is a
Linux 5.11+ only stressor and the kernel needs to be booted with
"secretmem=" option to allocate a secret memory reservation.</p>
<dl>
<dt><strong>--secretmem-ops N</strong></dt>
<dd>
<p>stop secretmem stress workers after N stress loop iterations.</p>
</dd>
</dl>
</dd>
<dt><strong>IO seek stressor</strong></dt>
<dd>
<p><strong>--seek N</strong> start N workers that randomly seeks and
performs 512 byte read/write I/O operations on a file. The default file
size is 16 GB.</p>
<dl>
<dt><strong>--seek-ops N</strong></dt>
<dd>
<p>stop seek stress workers after N bogo seek operations.</p>
</dd>
<dt><strong>--seek-punch</strong></dt>
<dd>
<p>punch randomly located 8K holes into the file to cause more extents
to force a more demanding seek stressor, (Linux only).</p>
</dd>
<dt><strong>--seek-size N</strong></dt>
<dd>
<p>specify the size of the file in bytes. Small file sizes allow the I/O
to occur in the cache, causing greater CPU load. Large file sizes force
more I/O operations to drive causing more wait time and more I/O on the
drive. One can specify the size in units of Bytes, KBytes, MBytes and
GBytes using the suffix b, k, m or g.</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX semaphore stressor</strong></dt>
<dd>
<p><strong>--sem N</strong> start N workers that perform POSIX semaphore
wait and post operations. By default, a parent and 4 children are
started per worker to provide some contention on the semaphore. This
stresses fast semaphore operations and produces rapid context
switching.</p>
<dl>
<dt><strong>--sem-ops N</strong></dt>
<dd>
<p>stop semaphore stress workers after N bogo semaphore operations.</p>
</dd>
<dt><strong>--sem-procs N</strong></dt>
<dd>
<p>start N child workers per worker to provide contention on the
semaphore, the default is 4 and a maximum of 64 are allowed.</p>
</dd>
</dl>
</dd>
<dt><strong>System V semaphore stressor</strong></dt>
<dd>
<p><strong>--sem-sysv N</strong> start N workers that perform System V
semaphore wait and post operations. By default, a parent and 4 children
are started per worker to provide some contention on the semaphore. This
stresses fast semaphore operations and produces rapid context
switching.</p>
<dl>
<dt><strong>--sem-sysv-ops N</strong></dt>
<dd>
<p>stop semaphore stress workers after N bogo System V semaphore
operations.</p>
</dd>
<dt><strong>--sem-sysv-procs N</strong></dt>
<dd>
<p>start N child processes per worker to provide contention on the
System V semaphore, the default is 4 and a maximum of 64 are
allowed.</p>
</dd>
</dl>
</dd>
<dt><strong>Sendfile stressor</strong></dt>
<dd>
<p><strong>--sendfile N</strong> start N workers that send an empty file
to /dev/null. This operation spends nearly all the time in the kernel.
The default sendfile size is 4MB. The sendfile options are for Linux
only.</p>
<dl>
<dt><strong>--sendfile-ops N</strong></dt>
<dd>
<p>stop sendfile workers after N sendfile bogo operations.</p>
</dd>
<dt><strong>--sendfile-size S</strong></dt>
<dd>
<p>specify the size to be copied with each sendfile call. The default
size is 4MB. One can specify the size in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
</dl>
</dd>
<dt><strong>Sessions stressor</strong></dt>
<dd>
<p><strong>--session N</strong> start N workers that create child and
grandchild processes that set and get their session ids. 25% of the
grandchild processes are not waited for by the child to create orphaned
sessions that need to be reaped by init.</p>
<dl>
<dt><strong>--session-ops N</strong></dt>
<dd>
<p>stop session workers after N child processes are spawned and
reaped.</p>
</dd>
</dl>
</dd>
<dt><strong>Setting data in the Kernel stressor</strong></dt>
<dd>
<p><strong>--set N</strong> start N workers that call system calls that
try to set data in the kernel, currently these are: setgid, sethostname,
setpgid, setpgrp, setuid, setgroups, setreuid, setregid, setresuid,
setresgid and setrlimit. Some of these system calls are OS specific.</p>
<dl>
<dt><strong>--set-ops N</strong></dt>
<dd>
<p>stop set workers after N bogo set operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Shellsort stressor</strong></dt>
<dd>
<p><strong>--shellsort N</strong> start N workers that sort 32 bit
integers using shellsort.</p>
<dl>
<dt><strong>--shellsort-ops N</strong></dt>
<dd>
<p>stop shellsort stress workers after N bogo shellsorts.</p>
</dd>
<dt><strong>--shellsort-size N</strong></dt>
<dd>
<p>specify number of 32 bit integers to sort, default is 262144 (256 ×
1024).</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX shared memory stressor</strong></dt>
<dd>
<p><strong>--shm N</strong> start N workers that open and allocate
shared memory objects using the POSIX shared memory interfaces. By
default, the test will repeatedly create and destroy 32 shared memory
objects, each of which is 8MB in size.</p>
<dl>
<dt><strong>--shm-bytes N</strong></dt>
<dd>
<p>specify the size of the POSIX shared memory objects to be created.
One can specify the size as % of total available memory or in units of
Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--shm-mlock</strong></dt>
<dd>
<p>attempt to mlock shared memory objects into memory causing more
memory pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--shm-objs N</strong></dt>
<dd>
<p>specify the number of shared memory objects to be created.</p>
</dd>
<dt><strong>--shm-ops N</strong></dt>
<dd>
<p>stop after N POSIX shared memory create and destroy bogo operations
are complete.</p>
</dd>
<dt><strong>--shm-sysv N</strong></dt>
<dd>
<p>start N workers that allocate shared memory using the System V shared
memory interface. By default, the test will repeatedly create and
destroy 8 shared memory segments, each of which is 8MB in size.</p>
</dd>
<dt><strong>--shm-sysv-bytes N</strong></dt>
<dd>
<p>specify the size of the shared memory segment to be created. One can
specify the size as % of total available memory or in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--shm-sysv-mlock</strong></dt>
<dd>
<p>attempt to mlock shared memory segment into memory causing more
memory pressure by preventing pages from swapped out.</p>
</dd>
<dt><strong>--shm-sysv-ops N</strong></dt>
<dd>
<p>stop after N shared memory create and destroy bogo operations are
complete.</p>
</dd>
<dt><strong>--shm-sysv-segs N</strong></dt>
<dd>
<p>specify the number of shared memory segments to be created. The
default is 8 segments.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGABRT stressor</strong></dt>
<dd>
<p><strong>--sigabrt N</strong> start N workers that create children
that are killed by SIGABRT signals or by calling abort(3).</p>
<dl>
<dt><strong>--sigabrt-ops N</strong></dt>
<dd>
<p>stop the sigabrt workers after N SIGABRT signals are successfully
handled.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGBUS stressor</strong></dt>
<dd>
<p><strong>--sigbus N</strong> start N workers that rapidly create and
catch bus errors generated via misaligned access and accessing a file
backed memory mapping that does not have file storage to back the page
being accessed.</p>
<dl>
<dt><strong>--sigbus-ops N</strong></dt>
<dd>
<p>stop sigbus stress workers after N bogo bus errors.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGCHLD stressor</strong></dt>
<dd>
<p><strong>--sigchld N</strong> start N workers that create children to
generate SIGCHLD signals. This exercises children that exit
(CLD_EXITED), get killed (CLD_KILLED), get stopped (CLD_STOPPED) or
continued (CLD_CONTINUED).</p>
<dl>
<dt><strong>--sigchld-ops N</strong></dt>
<dd>
<p>stop the sigchld workers after N SIGCHLD signals are successfully
handled.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGFD stressor (Linux)</strong></dt>
<dd>
<p><strong>--sigfd N</strong> start N workers that generate SIGRT
signals and are handled by reads by a child process using a file
descriptor set up using signalfd(2). (Linux only). This will generate a
heavy context switch load when all CPUs are fully loaded.</p>
<dl>
<dt><strong>--sigfd-ops</strong></dt>
<dd>
<p>stop sigfd workers after N bogo SIGUSR1 signals are sent.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGFPE stressor</strong></dt>
<dd>
<p><strong>--sigfpe N</strong> start N workers that rapidly cause
division by zero SIGFPE faults.</p>
<dl>
<dt><strong>--sigfpe-ops N</strong></dt>
<dd>
<p>stop sigfpe stress workers after N bogo SIGFPE faults.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGIO stressor</strong></dt>
<dd>
<p><strong>--sigio N</strong> start N workers that read data from a
child process via a pipe and generate SIGIO signals. This exercises
asynchronous I/O via SIGIO.</p>
<dl>
<dt><strong>--sigio-ops N</strong></dt>
<dd>
<p>stop sigio stress workers after handling N SIGIO signals.</p>
</dd>
</dl>
</dd>
<dt><strong>System signals stressor</strong></dt>
<dd>
<p><strong>--signal N</strong> start N workers that exercise the signal
system call three different signal handlers, SIG_IGN (ignore), a SIGCHLD
handler and SIG_DFL (default action). For the SIGCHLD handler, the
stressor sends itself a SIGCHLD signal and checks if it has been
handled. For other handlers, the stressor checks that the SIGCHLD
handler has not been called. This stress test calls the signal system
call directly when possible and will try to avoid the C library attempt
to replace signal with the more modern sigaction system call.</p>
<dl>
<dt><strong>--signal-ops N</strong></dt>
<dd>
<p>stop signal stress workers after N rounds of signal handler
setting.</p>
</dd>
</dl>
</dd>
<dt><strong>Nested signal handling stressor</strong></dt>
<dd>
<p><strong>--signest N</strong> start N workers that exercise nested
signal handling. A signal is raised and inside the signal handler a
different signal is raised, working through a list of signals to
exercise. An alternative signal stack is used that is large enough to
handle all the nested signal calls. The -v option will log the
approximate size of the stack required and the average stack size per
nested call.</p>
<dl>
<dt><strong>--signest-ops N</strong></dt>
<dd>
<p>stop after handling N nested signals.</p>
</dd>
</dl>
</dd>
<dt><strong>Pending signals stressor</strong></dt>
<dd>
<p><strong>--sigpending N</strong> start N workers that check if SIGUSR1
signals are pending. This stressor masks SIGUSR1, generates a SIGUSR1
signal and uses sigpending(2) to see if the signal is pending. Then it
unmasks the signal and checks if the signal is no longer pending.</p>
<dl>
<dt><strong>--sigpending-ops N</strong></dt>
<dd>
<p>stop sigpending stress workers after N bogo sigpending
pending/unpending checks.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGPIPE stressor</strong></dt>
<dd>
<p><strong>--sigpipe N</strong> start N workers that repeatedly spawn
off child process that exits before a parent can complete a pipe write,
causing a SIGPIPE signal. The child process is either spawned using
clone(2) if it is available or use the slower fork(2) instead.</p>
<dl>
<dt><strong>--sigpipe-ops N</strong></dt>
<dd>
<p>stop N workers after N SIGPIPE signals have been caught and
handled.</p>
</dd>
</dl>
</dd>
<dt><strong>Signal queueing stressor</strong></dt>
<dd>
<p><strong>--sigq N</strong> start N workers that rapidly send SIGUSR1
signals using sigqueue(3) to child processes that wait for the signal
via sigwaitinfo(2).</p>
<dl>
<dt><strong>--sigq-ops N</strong></dt>
<dd>
<p>stop sigq stress workers after N bogo signal send operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Real-time signals stressor</strong></dt>
<dd>
<p><strong>--sigrt N</strong> start N workers that each create child
processes to handle SIGRTMIN to SIGRMAX real time signals. The parent
sends each child process a RT signal via siqueue(2) and the child
process waits for this via sigwaitinfo(2). When the child receives the
signal it then sends a RT signal to one of the other child processes
also via sigqueue(2).</p>
<dl>
<dt><strong>--sigrt-ops N</strong></dt>
<dd>
<p>stop sigrt stress workers after N bogo sigqueue signal send
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGSEV stressor</strong></dt>
<dd>
<p><strong>--sigsegv N</strong> start N workers that rapidly create and
catch segmentation faults generated via illegal memory access, illegal
vdso system calls, illegal port reads, illegal interrupts or access to
x86 time stamp counter.</p>
<dl>
<dt><strong>--sigsegv-ops N</strong></dt>
<dd>
<p>stop sigsegv stress workers after N bogo segmentation faults.</p>
</dd>
</dl>
</dd>
<dt><strong>Waiting for process signals stressor</strong></dt>
<dd>
<p><strong>--sigsuspend N</strong> start N workers that each spawn off 4
child processes that wait for a SIGUSR1 signal from the parent using
sigsuspend(2). The parent sends SIGUSR1 signals to each child in rapid
succession. Each sigsuspend wakeup is counted as one bogo operation.</p>
<dl>
<dt><strong>--sigsuspend-ops N</strong></dt>
<dd>
<p>stop sigsuspend stress workers after N bogo sigsuspend wakeups.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGTRAP stressor</strong></dt>
<dd>
<p><strong>--sigtrap N</strong> start N workers that exercise the
SIGTRAP signal. For systems that support SIGTRAP, the signal is
generated using raise(SIGTRAP). Only x86 Linux systems the SIGTRAP is
also generated by an int 3 instruction.</p>
<dl>
<dt><strong>--sigtrap-ops N</strong></dt>
<dd>
<p>stop sigtrap stress workers after N SIGTRAPs have been handled.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGXCPU stressor</strong></dt>
<dd>
<p><strong>--sigxcpu N</strong> start N workers that exercise the
SIGXCPU stressor. A busy loop generates SIGXCPU signals by setting a 0
second run time limit followed by a sched_yield call.</p>
<dl>
<dt><strong>--sigxcpu-ops N</strong></dt>
<dd>
<p>stop sigsxcpu stress workers after N bogo SIGXCPU signal
attempts.</p>
</dd>
</dl>
</dd>
<dt><strong>SIGXFSZ stressor</strong></dt>
<dd>
<p><strong>--sigxfsz N</strong> start N workers that exercise the
SIGXFSZ stressor. A random 32 bit file size limit is set and data is
written outside this size limit to generate a SIGXFSZ signal.</p>
<dl>
<dt><strong>--sigxfsz-ops N</strong></dt>
<dd>
<p>stop sigsxfsz stress workers after N bogo SIGXFSZ signal
attempts.</p>
</dd>
</dl>
</dd>
<dt><strong>Random memory and processor cache line stressor via a
skiplist</strong></dt>
<dd>
<p><strong>--skiplist N</strong> start N workers that store and then
search for integers using a skiplist. By default, 65536 integers are
added and searched. This is a useful method to exercise random access of
memory and processor cache.</p>
<dl>
<dt><strong>--skiplist-ops N</strong></dt>
<dd>
<p>stop the skiplist worker after N skiplist store and search cycles are
completed.</p>
</dd>
<dt><strong>--skiplist-size N</strong></dt>
<dd>
<p>specify the size (number of integers) to store and search in the
skiplist. Size can be from 1K to 4M.</p>
</dd>
</dl>
</dd>
<dt><strong>Time interrupts and context switches stressor</strong></dt>
<dd>
<p><strong>--sleep N</strong> start N workers that spawn off multiple
threads that each perform multiple sleeps of ranges 1us to 0.1s. This
creates multiple context switches and timer interrupts.</p>
<dl>
<dt><strong>--sleep-max P</strong></dt>
<dd>
<p>start P threads per worker. The default is 1024, the maximum allowed
is 30000.</p>
</dd>
<dt><strong>--sleep-ops N</strong></dt>
<dd>
<p>stop after N sleep bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>System management interrupts (SMI) stressor</strong></dt>
<dd>
<p><strong>--smi N</strong> start N workers that attempt to generate
system management interrupts (SMIs) into the x86 ring -2 system
management mode (SMM) by exercising the advanced power management (APM)
port 0xb2. This requires the --pathological option and root privilege
and is only implemented on x86 Linux platforms. This probably does not
work in a virtualized environment. The stressor will attempt to
determine the time stolen by SMIs with some naïve benchmarking.</p>
<dl>
<dt><strong>--smi-ops N</strong></dt>
<dd>
<p>stop after N attempts to trigger the SMI.</p>
</dd>
</dl>
</dd>
<dt><strong>Network socket stressor</strong></dt>
<dd>
<p><strong>-S N, --sock N</strong> start N workers that perform various
socket stress activity. This involves a pair of client/server processes
performing rapid connect, send and receives and disconnects on the local
host.</p>
<dl>
<dt><strong>--sock-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is ipv4. Currently ipv4, ipv6
and unix are supported.</p>
</dd>
<dt><strong>--sock-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--sock-msgs N</strong></dt>
<dd>
<p>send N messages per connect, send/receive, disconnect iteration. The
default is 1000 messages. If N is too small then the rate is throttled
back by the overhead of socket connect and disconnect (on Linux, one
needs to increase /proc/sys/net/netfilter/nf_conntrack_max to allow more
connections).</p>
</dd>
<dt><strong>--sock-nodelay</strong></dt>
<dd>
<p>This disables the TCP Nagle algorithm, so data segments are always
sent as soon as possible. This stops data from being buffered before
being transmitted, hence resulting in poorer network utilisation and
more context switches between the sender and receiver.</p>
</dd>
<dt><strong>--sock-ops N</strong></dt>
<dd>
<p>stop socket stress workers after N bogo operations.</p>
</dd>
<dt><strong>--sock-opts [ random | send | sendmsg | sendmmsg
]</strong></dt>
<dd>
<p>by default, messages are sent using send(2). This option allows one
to specify the sending method using send(2), sendmsg(2), sendmmsg(2) or
a random selection of one of these 3 on each iteration. Note that
sendmmsg is only available for Linux systems that support this system
call.</p>
</dd>
<dt><strong>--sock-port P</strong></dt>
<dd>
<p>start at socket port P. For N socket worker processes, ports P to P -
1 are used.</p>
</dd>
<dt><strong>--sock-protocol P</strong></dt>
<dd>
<p>Use the specified protocol P, default is tcp. Options are tcp and
mptcp (if supported by the operating system).</p>
</dd>
<dt><strong>--sock-type [ stream | seqpacket ]</strong></dt>
<dd>
<p>specify the socket type to use. The default type is stream. seqpacket
currently only works for the unix socket domain.</p>
</dd>
<dt><strong>--sock-zerocopy</strong></dt>
<dd>
<p>enable zerocopy for send and recv calls if the MSG_ZEROCOPY is
supported.</p>
</dd>
</dl>
</dd>
<dt><strong>Socket abusing stressor</strong></dt>
<dd>
<p><strong>--sockabuse N</strong> start N workers that abuse a socket
file descriptor with various file based system that don't normally act
on sockets. The kernel should handle these illegal and unexpected calls
gracefully.</p>
<dl>
<dt><strong>--sockabuse-ops N</strong></dt>
<dd>
<p>stop after N iterations of the socket abusing stressor loop.</p>
</dd>
<dt><strong>--sockabuse-port P</strong></dt>
<dd>
<p>start at socket port P. For N sockabuse worker processes, ports P to
P - 1 are used.</p>
</dd>
</dl>
</dd>
<dt><strong>Socket diagnostic stressor (Linux)</strong></dt>
<dd>
<p><strong>--sockdiag N</strong> start N workers that exercise the Linux
sock_diag netlink socket diagnostics (Linux only). This currently
requests diagnostics using UDIAG_SHOW_NAME, UDIAG_SHOW_VFS,
UDIAG_SHOW_PEER, UDIAG_SHOW_ICONS, UDIAG_SHOW_RQLEN and
UDIAG_SHOW_MEMINFO for the AF_UNIX family of socket connections.</p>
<dl>
<dt><strong>--sockdiag-ops N</strong></dt>
<dd>
<p>stop after receiving N sock_diag diagnostic messages.</p>
</dd>
</dl>
</dd>
<dt><strong>Socket file descriptor stressor</strong></dt>
<dd>
<p><strong>--sockfd N</strong> start N workers that pass file
descriptors over a UNIX domain socket using the CMSG(3) ancillary data
mechanism. For each worker, pair of client/server processes are created,
the server opens as many file descriptors on /dev/null as possible and
passing these over the socket to a client that reads these from the CMSG
data and immediately closes the files.</p>
<dl>
<dt><strong>--sockfd-ops N</strong></dt>
<dd>
<p>stop sockfd stress workers after N bogo operations.</p>
</dd>
<dt><strong>--sockfd-port P</strong></dt>
<dd>
<p>start at socket port P. For N socket worker processes, ports P to P -
1 are used.</p>
</dd>
</dl>
</dd>
<dt><strong>Opening network socket stressor</strong></dt>
<dd>
<p><strong>--sockmany N</strong> start N workers that use a client
process to attempt to open as many as 100000 TCP/IP socket connections
to a server on port 10000.</p>
<dl>
<dt><strong>--sockmany-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--sockmany-ops N</strong></dt>
<dd>
<p>stop after N connections.</p>
</dd>
<dt><strong>--sockmany-port P</strong></dt>
<dd>
<p>start at socket port P. For N sockmany worker processes, ports P to P
- 1 are used.</p>
</dd>
</dl>
</dd>
<dt><strong>Socket I/O stressor</strong></dt>
<dd>
<p><strong>--sockpair N</strong> start N workers that perform socket
pair I/O read/writes. This involves a pair of client/server processes
performing randomly sized socket I/O operations.</p>
<dl>
<dt><strong>--sockpair-ops N</strong></dt>
<dd>
<p>stop socket pair stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Softlockup stressor</strong></dt>
<dd>
<p><strong>--softlockup N</strong> start N workers that flip between
with the "real-time" SCHED_FIO and SCHED_RR scheduling policies at the
highest priority to force softlockups. This can only be run with
CAP_SYS_NICE capability and for best results the number of stressors
should be at least the number of online CPUs. Once running, this is
practically impossible to stop and it will force softlockup issues and
may trigger watchdog timeout reboots.</p>
<dl>
<dt><strong>--softlockup-ops N</strong></dt>
<dd>
<p>stop softlockup stress workers after N bogo scheduler policy
changes.</p>
</dd>
</dl>
</dd>
<dt><strong>Sparse matrix stressor</strong></dt>
<dd>
<p><strong>--sparsematrix N</strong> start N workers that exercise 3
different sparse matrix implementations based on hashing, Judy array
(for 64 bit systems), 2-d circular linked-lists, memory mapped 2-d
matrix (non-sparse), quick hashing (on preallocated nodes) and red-black
tree. The sparse matrix is populated with values, random values
potentially non-existing values are read, known existing values are read
and known existing values are marked as zero. This default 500 × 500
sparse matrix is used and 5000 items are put into the sparse matrix
making it 2% utilized.</p>
<dl>
<dt><strong>--sparsematrix-items N</strong></dt>
<dd>
<p>populate the sparse matrix with N items. If N is greater than the
number of elements in the sparse matrix than N will be capped to create
at 100% full sparse matrix.</p>
</dd>
<dt><strong>--sparsematrix-method [ all | hash | hashjudy | judy | list
| mmap | qhash | rb ]</strong></dt>
<dd>
<p>specify the type of sparse matrix implementation to use. The 'all'
method uses all the methods and is the default.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">exercise with all the sparsematrix
stressor methods (see below):</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hash</td>
<td style="text-align: left;">use a hash table and allocate nodes on the
heap for each unique value at a (x, y) matrix position.</td>
</tr>
<tr class="even">
<td style="text-align: left;">hashjudy</td>
<td style="text-align: left;">use a hash table for x coordinates and a
Judy array for y coordinates for values at a (x, y) matrix
position.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">judy</td>
<td style="text-align: left;">use a Judy array with a unique 1-to-1
mapping of (x, y) matrix position into the array.</td>
</tr>
<tr class="even">
<td style="text-align: left;">list</td>
<td style="text-align: left;">use a circular linked-list for sparse y
positions each with circular linked-lists for sparse x positions for the
(x, y) matrix coordinates.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mmap</td>
<td style="text-align: left;">use a non-sparse mmap the entire 2-d
matrix space. Only (x, y) matrix positions that are referenced will get
physically mapped. Note that large sparse matrices cannot be mmap'd due
to lack of virtual address limitations, and too many referenced pages
can trigger the out of memory killer on Linux.</td>
</tr>
<tr class="even">
<td style="text-align: left;">qhash</td>
<td style="text-align: left;">use a hash table with pre-allocated nodes
for each unique value. This is a quick hash table implementation, nodes
are not allocated each time with calloc and are allocated from a
pre-allocated pool leading to quicker hash table performance than the
hash method.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rb</td>
<td style="text-align: left;">use a red-black balanced tree using one
tree node for each unique value at a (x, y) matrix position.</td>
</tr>
<tr class="even">
<td style="text-align: left;">splay</td>
<td style="text-align: left;">use a splay tree using one tree node for
each unique value at a (x, y) matrix position.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--sparsematrix-ops N</strong></dt>
<dd>
<p>stop after N sparsematrix test iterations.</p>
</dd>
<dt><strong>--sparsematrix-size N</strong></dt>
<dd>
<p>use a N × N sized sparse matrix</p>
</dd>
</dl>
</dd>
<dt><strong>POSIX process spawn (posix_spawn) stressor
(Linux)</strong></dt>
<dd>
<p><strong>--spawn N</strong> start N workers continually spawn children
using posix_spawn(3) that exec stress-ng and then exit almost
immediately. Currently Linux only.</p>
<dl>
<dt><strong>--spawn-ops N</strong></dt>
<dd>
<p>stop spawn stress workers after N bogo spawns.</p>
</dd>
</dl>
</dd>
<dt><strong>Splice stressor (Linux)</strong></dt>
<dd>
<p><strong>--splice N</strong> move data from /dev/zero to /dev/null
through a pipe without any copying between kernel address space and user
address space using splice(2). This is only available for Linux.</p>
<dl>
<dt><strong>--splice-bytes N</strong></dt>
<dd>
<p>transfer N bytes per splice call, the default is 64K. One can specify
the size as % of total available memory or in units of Bytes, KBytes,
MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--splice-ops N</strong></dt>
<dd>
<p>stop after N bogo splice operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Stack stressor</strong></dt>
<dd>
<p><strong>--stack N</strong> start N workers that rapidly cause and
catch stack overflows by use of large recursive stack allocations. Much
like the brk stressor, this can eat up pages rapidly and may trigger the
kernel OOM killer on the process, however, the killed stressor is
respawned again by a monitoring parent process.</p>
<dl>
<dt><strong>--stack-fill</strong></dt>
<dd>
<p>the default action is to touch the lowest page on each stack
allocation. This option touches all the pages by filling the new stack
allocation with zeros which forces physical pages to be allocated and
hence is more aggressive.</p>
</dd>
<dt><strong>--stack-mlock</strong></dt>
<dd>
<p>attempt to mlock stack pages into memory causing more memory pressure
by preventing pages from swapped out.</p>
</dd>
<dt><strong>--stack-ops N</strong></dt>
<dd>
<p>stop stack stress workers after N bogo stack overflows.</p>
</dd>
<dt><strong>--stack-pageout</strong></dt>
<dd>
<p>force stack pages out to swap (available when madvise(2) supports
MADV_PAGEOUT).</p>
</dd>
<dt><strong>--stack-unmap</strong></dt>
<dd>
<p>unmap a single page in the middle of a large buffer allocated on the
stack on each stack allocation. This forces the stack mapping into
multiple separate allocation mappings.</p>
</dd>
</dl>
</dd>
<dt><strong>Dirty page and stack exception stressor</strong></dt>
<dd>
<p><strong>--stackmmap N</strong> start N workers that use a 2MB stack
that is memory mapped onto a temporary file. A recursive function works
down the stack and flushes dirty stack pages back to the memory mapped
file using msync(2) until the end of the stack is reached (stack
overflow). This exercises dirty page and stack exception handling.</p>
<dl>
<dt><strong>--stackmmap-ops N</strong></dt>
<dd>
<p>stop workers after N stack overflows have occurred.</p>
</dd>
</dl>
</dd>
<dt><strong>Libc string functions stressor</strong></dt>
<dd>
<p><strong>--str N</strong> start N workers that exercise various libc
string functions on random strings.</p>
<dl>
<dt><strong>--str-method strfunc</strong></dt>
<dd>
<p>select a specific libc string function to stress. Available string
functions to stress are: all, index, rindex, strcasecmp, strcat, strchr,
strcoll, strcmp, strcpy, strlen, strncasecmp, strncat, strncmp, strrchr
and strxfrm. See string(3) for more information on these string
functions. The 'all' method is the default and will exercise all the
string methods.</p>
</dd>
<dt><strong>--str-ops N</strong></dt>
<dd>
<p>stop after N bogo string operations.</p>
</dd>
</dl>
</dd>
<dt><strong>STREAM memory stressor</strong></dt>
<dd>
<p><strong>--stream N</strong> start N workers exercising a memory
bandwidth stressor very loosely based on the STREAM "Sustainable Memory
Bandwidth in High Performance Computers" benchmarking tool by John D.
McCalpin, Ph.D. This stressor allocates buffers that are at least 4
times the size of the CPU L2 cache and continually performs rounds of
following computations on large arrays of double precision floating
point numbers:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Operation</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">copy</td>
<td style="text-align: left;">c[i] = a[i]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scale</td>
<td style="text-align: left;">b[i] = scalar * c[i]</td>
</tr>
<tr class="even">
<td style="text-align: left;">add</td>
<td style="text-align: left;">c[i] = a[i] + b[i]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">triad</td>
<td style="text-align: left;">a[i] = b[i] + (c[i] * scalar)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Since this is loosely based on a variant of the STREAM benchmark
code, DO NOT submit results based on this as it is intended to in
stress-ng just to stress memory and compute and NOT intended for STREAM
accurate tuned or non-tuned benchmarking whatsoever. Use the official
STREAM benchmarking tool if you desire accurate and standardised STREAM
benchmarks.</p>
<p>The stressor calculates the memory read rate, memory write rate and
floating point operations rate. These will differ from the maximum
theoretical read/write/compute rates because of loop overheads and the
use of volatile pointers to ensure the compiler does not optimize out
stores.</p>
</blockquote>
<dl>
<dt><strong>--stream-index N</strong></dt>
<dd>
<p>specify number of stream indices used to index into the data arrays
a, b and c. This adds indirection into the data lookup by using randomly
shuffled indexing into the three data arrays. Level 0 (no indexing) is
the default, and 3 is where all 3 arrays are indexed via 3 different
randomly shuffled indexes. The higher the index setting the more impact
this has on L1, L2 and L3 caching and hence forces higher memory
read/write latencies.</p>
</dd>
<dt><strong>--stream-l3-size N</strong></dt>
<dd>
<p>Specify the CPU Level 3 cache size in bytes. One can specify the size
in units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or
g. If the L3 cache size is not provided, then stress-ng will attempt to
determine the cache size, and failing this, will default the size to
4MB.</p>
</dd>
<dt><strong>--stream-mlock</strong></dt>
<dd>
<p>attempt to mlock the stream buffers into memory to prevent them from
being swapped out.</p>
</dd>
<dt><strong>--stream-madvise [ collapse | hugepage | nohugepage | normal
]</strong></dt>
<dd>
<p>Specify the madvise options used on the memory mapped buffer used in
the stream stressor. Non-linux systems will only have the 'normal'
madvise advice. The default is 'normal'.</p>
</dd>
<dt><strong>--stream-ops N</strong></dt>
<dd>
<p>stop after N stream bogo operations, where a bogo operation is one
round of copy, scale, add and triad operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Swap partitions stressor (Linux)</strong></dt>
<dd>
<p><strong>--swap N</strong> start N workers that add and remove small
randomly sizes swap partitions (Linux only). Note that if too many swap
partitions are added then the stressors may exit with exit code 3 (not
enough resources). Requires CAP_SYS_ADMIN to run.</p>
<dl>
<dt><strong>--swap-ops N</strong></dt>
<dd>
<p>stop the swap workers after N swapon/swapoff iterations.</p>
</dd>
</dl>
</dd>
<dt><strong>Context switching between mutually tied processes
stressor</strong></dt>
<dd>
<p><strong>-s N, --switch N</strong> start N workers that force context
switching between two mutually blocking/unblocking tied processes. By
default message passing over a pipe is used, but different methods are
available.</p>
<dl>
<dt><strong>--switch-freq F</strong></dt>
<dd>
<p>run the context switching at the frequency of F context switches per
second. Note that the specified switch rate may not be achieved because
of CPU speed and memory bandwidth limitations.</p>
</dd>
<dt><strong>--switch-method [ mq | pipe | sem-sysv ]</strong></dt>
<dd>
<p>select the preferred context switch block/run synchronization method,
these are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">mq</td>
<td style="text-align: left;">use posix message queue with a 1 item
size. Messages are passed between a sender and receiver process.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pipe</td>
<td style="text-align: left;">single character messages are passed down
a single character sized pipe between a sender and receiver
process.</td>
</tr>
<tr class="even">
<td style="text-align: left;">sem-sysv</td>
<td style="text-align: left;">a SYSV semaphore is used to block/run two
processes.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--switch-ops N</strong></dt>
<dd>
<p>stop context switching workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Symlink stressor</strong></dt>
<dd>
<p><strong>--symlink N</strong> start N workers creating and removing
symbolic links.</p>
<dl>
<dt><strong>--symlink-ops N</strong></dt>
<dd>
<p>stop symlink stress workers after N bogo operations.</p>
</dd>
<dt><strong>--symlink-sync</strong></dt>
<dd>
<p>sync dirty data and metadata to disk.</p>
</dd>
</dl>
</dd>
<dt><strong>Partial file syncing (sync_file_range)
stressor</strong></dt>
<dd>
<p><strong>--sync-file N</strong> start N workers that perform a range
of data syncs across a file using sync_file_range(2). Three mixes of
syncs are performed, from start to the end of the file, from end of the
file to the start, and a random mix. A random selection of valid sync
types are used, covering the SYNC_FILE_RANGE_WAIT_BEFORE,
SYNC_FILE_RANGE_WRITE and SYNC_FILE_RANGE_WAIT_AFTER flag bits.</p>
<dl>
<dt><strong>--sync-file-bytes N</strong></dt>
<dd>
<p>specify the size of the file to be sync'd. One can specify the size
as % of free space on the file system in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--sync-file-ops N</strong></dt>
<dd>
<p>stop sync-file workers after N bogo sync operations.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU synchronized loads stressor</strong></dt>
<dd>
<p><strong>--syncload N</strong> start N workers that produce sporadic
short lived loads synchronized across N stressor processes. By default
repeated cycles of 125ms busy load followed by 62.5ms sleep occur across
all the workers in step to create bursts of load to exercise C state
transitions and CPU frequency scaling. The busy load and sleeps have
+/-10% jitter added to try exercising scheduling patterns.</p>
<dl>
<dt><strong>--syncload-msbusy M</strong></dt>
<dd>
<p>specify the busy load duration in milliseconds.</p>
</dd>
<dt><strong>--syncload-mssleep M</strong></dt>
<dd>
<p>specify the sleep duration in milliseconds.</p>
</dd>
<dt><strong>--syncload-ops N</strong></dt>
<dd>
<p>stop syncload workers after N load/sleep cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>System calls bad address and fault handling
stressor</strong></dt>
<dd>
<p><strong>--sysbadaddr N</strong> start N workers that pass bad
addresses to system calls to exercise bad address and fault handling.
The addresses used are null pointers, read only pages, write only pages,
unmapped addresses, text only pages, unaligned addresses and top of
memory addresses.</p>
<dl>
<dt><strong>--sysbadaddr-ops N</strong></dt>
<dd>
<p>stop the sysbadaddr stressors after N bogo system calls.</p>
</dd>
</dl>
</dd>
<dt><strong>System calls stressor</strong></dt>
<dd>
<p><strong>--syscall N</strong> start N workers that exercise a range of
available system calls. System calls that fail due to lack of
capabilities or errors are ignored. The stressor will try to maximize
the rate of system calls being executed based the entire time taken to
setup, run and cleanup after each system call.</p>
<dl>
<dt><strong>--syscall-method method</strong></dt>
<dd>
<p>select the choice of system calls to executed based on the fastest
test duration times. Note that this includes the time to setup, execute
the system call and cleanup afterwards. The available methods are as
follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">select all the available system calls</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast10</td>
<td style="text-align: left;">select the fastest 10% system call
tests</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast25</td>
<td style="text-align: left;">select the fastest 25% system call
tests</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast50</td>
<td style="text-align: left;">select the fastest 50% system call
tests</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast75</td>
<td style="text-align: left;">select the fastest 75% system call
tests</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast90</td>
<td style="text-align: left;">select the fastest 90% system call
tests</td>
</tr>
<tr class="even">
<td style="text-align: left;">geomean1</td>
<td style="text-align: left;">select tests that are less or equal to the
geometric mean of all the test times</td>
</tr>
<tr class="odd">
<td style="text-align: left;">geomean1</td>
<td style="text-align: left;">select tests that are less or equal to 2 ×
the geometric mean of all the test times</td>
</tr>
<tr class="even">
<td style="text-align: left;">geomean1</td>
<td style="text-align: left;">select tests that are less or equal to 3 ×
the geometric mean of all the test times</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--syscall-ops N</strong></dt>
<dd>
<p>stop after N system calls</p>
</dd>
<dt><strong>--sycsall-top N</strong></dt>
<dd>
<p>report the fastest top N system calls. Setting N to zero will report
all the system calls that could be exercised.</p>
</dd>
</dl>
</dd>
<dt><strong>System information stressor</strong></dt>
<dd>
<p><strong>--sysinfo N</strong> start N workers that continually read
system and process specific information. This reads the process user and
system times using the times(2) system call. For Linux systems, it also
reads overall system statistics using the sysinfo(2) system call and
also the file system statistics for all mounted file systems using
statfs(2).</p>
<dl>
<dt><strong>--sysinfo-ops N</strong></dt>
<dd>
<p>stop the sysinfo workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>System calls with invalid arguments stressor
(Linux)</strong></dt>
<dd>
<p><strong>--sysinval N</strong> start N workers that exercise system
calls in random order with permutations of invalid arguments to force
kernel error handling checks. The stress test autodetects system calls
that cause processes to crash or exit prematurely and will blocklist
these after several repeated breakages. System call arguments that cause
system calls to work successfully are also detected an blocklisted too.
Linux only.</p>
<dl>
<dt><strong>--sysinval-ops N</strong></dt>
<dd>
<p>stop sysinval workers after N system call attempts.</p>
</dd>
</dl>
</dd>
<dt><strong>/sys stressor (Linux)</strong></dt>
<dd>
<p><strong>--sysfs N</strong> start N workers that recursively read
files from /sys (Linux only). This may cause specific kernel drivers to
emit messages into the kernel log.</p>
<dl>
<dt><strong>--sysfs-ops N</strong></dt>
<dd>
<p>stop sysfs reading after N bogo read operations. Note, since the
number of entries may vary between kernels, this bogo ops metric is
probably very misleading.</p>
</dd>
</dl>
</dd>
<dt><strong>Tee stressor (Linux)</strong></dt>
<dd>
<p><strong>--tee N</strong> move data from a writer process to a reader
process through pipes and to /dev/null without any copying between
kernel address space and user address space using tee(2). This is only
available for Linux.</p>
<dl>
<dt><strong>--tee-ops N</strong></dt>
<dd>
<p>stop after N bogo tee operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Timer event stressor (Linux)</strong></dt>
<dd>
<p><strong>-T N, --timer N</strong> start N workers creating timer
events at a default rate of 1 MHz (Linux only); this can create a many
thousands of timer clock interrupts. Each timer event is caught by a
signal handler and counted as a bogo timer op.</p>
<dl>
<dt><strong>--timer-freq F</strong></dt>
<dd>
<p>run timers at F Hz; range from 1 to 1000000000 Hz (Linux only). By
selecting an appropriate frequency stress-ng can generate hundreds of
thousands of interrupts per second. Note: it is also worth using
--timer-slack 0 for high frequencies to stop the kernel from coalescing
timer events.</p>
</dd>
<dt><strong>--timer-ops N</strong></dt>
<dd>
<p>stop timer stress workers after N bogo timer events (Linux only).</p>
</dd>
<dt><strong>--timer-rand</strong></dt>
<dd>
<p>select a timer frequency based around the timer frequency +/- 12.5%
random jitter. This tries to force more variability in the timer
interval to make the scheduling less predictable.</p>
</dd>
</dl>
</dd>
<dt><strong>Timerfd stressor (Linux)</strong></dt>
<dd>
<p><strong>--timerfd N</strong> start N workers creating timerfd events
at a default rate of 1 MHz (Linux only); this can create a many
thousands of timer clock events. Timer events are waited for on the
timer file descriptor using select(2) and then read and counted as a
bogo timerfd op.</p>
<dl>
<dt><strong>--timerfs-fds N</strong></dt>
<dd>
<p>try to use a maximum of N timerfd file descriptors per stressor.</p>
</dd>
<dt><strong>--timerfd-freq F</strong></dt>
<dd>
<p>run timers at F Hz; range from 1 to 1000000000 Hz (Linux only). By
selecting an appropriate frequency stress-ng can generate hundreds of
thousands of interrupts per second.</p>
</dd>
<dt><strong>--timerfd-ops N</strong></dt>
<dd>
<p>stop timerfd stress workers after N bogo timerfd events (Linux
only).</p>
</dd>
<dt><strong>--timerfd-rand</strong></dt>
<dd>
<p>select a timerfd frequency based around the timer frequency +/- 12.5%
random jitter. This tries to force more variability in the timer
interval to make the scheduling less predictable.</p>
</dd>
</dl>
</dd>
<dt><strong>Time warp stressor</strong></dt>
<dd>
<p><strong>--time-warp N</strong> start N workers that read the system
time and where appropriate for monotonic clocks perform a check for
reverse time warping. At the end of the run there are time wrap-around
checks. This stressor exercises clock_gettime(2) on all available
clocks, gettimeofday(2), time(2) and getrusage(2) to check for
unexpected time behaviour. Note that only some clocks are reliably
monotonic.</p>
<dl>
<dt><strong>--time-warp-ops N</strong></dt>
<dd>
<p>stop after N rounds of checking all the available clocks and time
fetching system calls.</p>
</dd>
</dl>
</dd>
<dt><strong>Translation lookaside buffer shootdowns
stressor</strong></dt>
<dd>
<p><strong>--tlb-shootdown N</strong> start N workers that force
Translation Lookaside Buffer (TLB) shootdowns. This is achieved by
creating up to 16 child processes that all share a region of memory and
these processes are shared amongst the available CPUs. The processes
adjust the page mapping settings causing TLBs to be force flushed on the
other processors, causing the TLB shootdowns.</p>
<dl>
<dt><strong>--tlb-shootdown-ops N</strong></dt>
<dd>
<p>stop after N bogo TLB shootdown operations are completed.</p>
</dd>
</dl>
</dd>
<dt><strong>Tmpfs stressor</strong></dt>
<dd>
<p><strong>--tmpfs N</strong> start N workers that create a temporary
file on an available tmpfs file system and perform various file based
mmap operations upon it.</p>
<dl>
<dt><strong>--tmpfs-mmap-async</strong></dt>
<dd>
<p>enable file based memory mapping and use asynchronous msync'ing on
each page, see --tmpfs-mmap-file.</p>
</dd>
<dt><strong>--tmpfs-mmap-file</strong></dt>
<dd>
<p>enable tmpfs file based memory mapping and by default use synchronous
msync'ing on each page.</p>
</dd>
<dt><strong>--tmpfs-ops N</strong></dt>
<dd>
<p>stop tmpfs stressors after N bogo mmap operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Touching files stressor</strong></dt>
<dd>
<p><strong>--touch N</strong> touch files by using open(2) or creat(2)
and then closing and unlinking them. The filename contains the bogo-op
number and is incremented on each touch operation, hence this fills the
dentry cache. Note that the user time and system time may be very low as
most of the run time is waiting for file I/O and this produces very
large bogo-op rates for the very low CPU time used.</p>
<dl>
<dt><strong>--touch-method [ random | open | creat ]</strong></dt>
<dd>
<p>select the method the file is created, either randomly using open(2)
or create(2), just using open(2) with the O_CREAT open flag, or with
creat(2).</p>
</dd>
<dt><strong>--touch-ops N</strong></dt>
<dd>
<p>stop the touch workers after N file touches.</p>
</dd>
<dt><strong>--touch-opts all, direct, dsync, excl, noatime,
sync</strong></dt>
<dd>
<p>specify various file open options as a comma separated list. Options
are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Option</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">use all the open options, namely direct,
dsync, excl, noatime and sync</td>
</tr>
<tr class="odd">
<td style="text-align: left;">direct</td>
<td style="text-align: left;">try to minimize cache effects of the I/O
to and from this file, using the O_DIRECT open flag.</td>
</tr>
<tr class="even">
<td style="text-align: left;">dsync</td>
<td style="text-align: left;">ensure output has been transferred to
underlying hardware and file metadata has been updated using the O_DSYNC
open flag.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">excl</td>
<td style="text-align: left;">fail if file already exists (it should
not).</td>
</tr>
<tr class="even">
<td style="text-align: left;">noatime</td>
<td style="text-align: left;">do not update the file last access time if
the file is read.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sync</td>
<td style="text-align: left;">ensure output has been transferred to
underlying hardware using the O_SYNC open flag.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Tree data structures stressor</strong></dt>
<dd>
<p><strong>--tree N</strong> start N workers that exercise tree data
structures. The default is to add, find and remove 250,000 64 bit
integers into AVL (avl), Red-Black (rb), Splay (splay), btree and binary
trees. The intention of this stressor is to exercise memory and cache
with the various tree operations.</p>
<dl>
<dt><strong>--tree-method [ all | avl | binary | btree | rb | splay
]</strong></dt>
<dd>
<p>specify the tree to be used. By default, all the trees are used (the
'all' option).</p>
</dd>
<dt><strong>--tree-ops N</strong></dt>
<dd>
<p>stop tree stressors after N bogo ops. A bogo op covers the addition,
finding and removing all the items into the tree(s).</p>
</dd>
<dt><strong>--tree-size N</strong></dt>
<dd>
<p>specify the size of the tree, where N is the number of 64 bit
integers to be added into the tree.</p>
</dd>
</dl>
</dd>
<dt><strong>Trigonometric functions stressor</strong></dt>
<dd>
<p><strong>--trig N</strong> start N workers that exercise sin, cos,
sincos (where available) and tan trigonometric functions using float,
double and long double floating point variants. Each function is
exercised 10,000 times per bogo-operation.</p>
<dl>
<dt><strong>--trig-method function</strong></dt>
<dd>
<p>specify a trigonometric stress function. By default, all the
functions are exercised sequentially, however one can specify just one
function to be used if required. Available options are as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate through all of the following
trigonometric functions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cos</td>
<td style="text-align: left;">cosine (double precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">cosf</td>
<td style="text-align: left;">cosine (float precision)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cosl</td>
<td style="text-align: left;">cosine (long double precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">sin</td>
<td style="text-align: left;">sine (double precision)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sinf</td>
<td style="text-align: left;">sine (float precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">sinl</td>
<td style="text-align: left;">sine (long double precision)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sincos</td>
<td style="text-align: left;">sine and cosine (double precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">sincosf</td>
<td style="text-align: left;">sine and cosine (float precision)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sincosl</td>
<td style="text-align: left;">sine and cosine (long double
precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">tan</td>
<td style="text-align: left;">tangent (double precision)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tanf</td>
<td style="text-align: left;">tangent (float precision)</td>
</tr>
<tr class="even">
<td style="text-align: left;">tanl</td>
<td style="text-align: left;">tangent (long double precision)</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--trig-ops N</strong></dt>
<dd>
<p>stop after N bogo-operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Time stamp counter (TSC) stressor</strong></dt>
<dd>
<p><strong>--tsc N</strong> start N workers that read the Time Stamp
Counter (TSC) 256 times per loop iteration (bogo operation). This
exercises the tsc instruction for x86, the mftb instruction for ppc64,
the rdcycle instruction for RISC-V, the tick instruction on SPARC and
the rdtime.d instruction for Loong64.</p>
<dl>
<dt><strong>--tsc-lfence</strong></dt>
<dd>
<p>add lfence after each tsc read to force serialization (x86 only).</p>
</dd>
<dt><strong>--tsc-ops N</strong></dt>
<dd>
<p>stop the tsc workers after N bogo operations are completed.</p>
</dd>
<dt><strong>--tsc-rdtscp</strong></dt>
<dd>
<p>use the rdtscp instruction instead of rdtsc (x86 only). This also
disables the --tsc-lfence option.</p>
</dd>
</dl>
</dd>
<dt><strong>Binary tree stressor</strong></dt>
<dd>
<p><strong>--tsearch N</strong> start N workers that insert, search and
delete 32 bit integers on a binary tree using tsearch(3), tfind(3) and
tdelete(3). By default, there are 65536 randomized integers used in the
tree. This is a useful method to exercise random access of memory and
processor cache.</p>
<dl>
<dt><strong>--tsearch-ops N</strong></dt>
<dd>
<p>stop the tsearch workers after N bogo tree operations are
completed.</p>
</dd>
<dt><strong>--tsearch-size N</strong></dt>
<dd>
<p>specify the size (number of 32 bit integers) in the array to tsearch.
Size can be from 1K to 4M.</p>
</dd>
</dl>
</dd>
<dt><strong>Network tunnel stressor</strong></dt>
<dd>
<p><strong>--tun N</strong> start N workers that create a network tunnel
device and sends and receives packets over the tunnel using UDP and then
destroys it. A new random 192.168.*.* IPv4 address is used each time a
tunnel is created.</p>
<dl>
<dt><strong>--tun-ops N</strong></dt>
<dd>
<p>stop after N iterations of creating/sending/receiving/destroying a
tunnel.</p>
</dd>
<dt><strong>--tun-tap</strong></dt>
<dd>
<p>use network tap device using level 2 frames (bridging) rather than a
tun device for level 3 raw packets (tunnelling).</p>
</dd>
</dl>
</dd>
<dt><strong>UDP network stressor</strong></dt>
<dd>
<p><strong>--udp N</strong> start N workers that transmit data using
UDP. This involves a pair of client/server processes performing rapid
connect, send and receives and disconnects on the local host.</p>
<dl>
<dt><strong>--udp-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is ipv4. Currently ipv4 and
ipv6 are supported.</p>
</dd>
<dt><strong>--udp-gro</strong></dt>
<dd>
<p>enable UDP-GRO (Generic Receive Offload) if supported.</p>
</dd>
<dt><strong>--udp-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--udp-lite</strong></dt>
<dd>
<p>use the UDP-Lite (RFC 3828) protocol (only for ipv4 and ipv6
domains).</p>
</dd>
<dt><strong>--udp-ops N</strong></dt>
<dd>
<p>stop udp stress workers after N bogo operations.</p>
</dd>
<dt><strong>--udp-port P</strong></dt>
<dd>
<p>start at port P. For N udp worker processes, ports P to P - 1 are
used. By default, ports 7000 upwards are used.</p>
</dd>
</dl>
</dd>
<dt><strong>UDP flooding stressor</strong></dt>
<dd>
<p><strong>--udp-flood N</strong> start N workers that attempt to flood
the host with UDP packets to random ports. The IP address of the packets
are currently not spoofed. This is only available on systems that
support AF_PACKET.</p>
<dl>
<dt><strong>--udp-flood-domain D</strong></dt>
<dd>
<p>specify the domain to use, the default is ipv4. Currently ipv4 and
ipv6 are supported.</p>
</dd>
<dt><strong>--udp-flood-if NAME</strong></dt>
<dd>
<p>use network interface NAME. If the interface NAME does not exist, is
not up or does not support the domain then the loopback (lo) interface
is used as the default.</p>
</dd>
<dt><strong>--udp-flood-ops N</strong></dt>
<dd>
<p>stop udp-flood stress workers after N bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Umount stressor</strong></dt>
<dd>
<p><strong>--umount N</strong> start N workers that exercise mounting
and racying unmounting of small tmpfs and ramfs file systems. Three
child processes are invoked, one to mount, another to force umount and a
third to exercice /proc/mounts. Small random delays are used between
mount and umount calls to try to trigger race conditions on the umount
calls.</p>
<dl>
<dt><strong>--umount-ops N</strong></dt>
<dd>
<p>stop umount workers after N successful bogo mount/umount
operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Unshare stressor (Linux)</strong></dt>
<dd>
<p><strong>--unshare N</strong> start N workers that each fork off 32
child processes, each of which exercises the unshare(2) system call by
disassociating parts of the process execution context. (Linux only).</p>
<dl>
<dt><strong>--unshare-ops N</strong></dt>
<dd>
<p>stop after N bogo unshare operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Uprobe stressor (Linux)</strong></dt>
<dd>
<p><strong>--uprobe N</strong> start N workers that trace the entry to
libc function getpid() using the Linux uprobe kernel tracing mechanism.
This requires CAP_SYS_ADMIN capabilities and a modern Linux uprobe
capable kernel.</p>
<dl>
<dt><strong>--uprobe-ops N</strong></dt>
<dd>
<p>stop uprobe tracing after N trace events of the function that is
being traced.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev/urandom stressor (Linux)</strong></dt>
<dd>
<p><strong>-u N, --urandom N</strong> start N workers reading
/dev/urandom (Linux only). This will load the kernel random number
source.</p>
<dl>
<dt><strong>--urandom-ops N</strong></dt>
<dd>
<p>stop urandom stress workers after N urandom bogo read operations
(Linux only).</p>
</dd>
</dl>
</dd>
<dt><strong>Page faults stressor (Linux)</strong></dt>
<dd>
<p><strong>--userfaultfd N</strong> start N workers that generate write
page faults on a small anonymously mapped memory region and handle these
faults using the user space fault handling via the userfaultfd
mechanism. This will generate a large quantity of major page faults and
also context switches during the handling of the page faults. (Linux
only).</p>
<dl>
<dt><strong>--userfaultfd-bytes N</strong></dt>
<dd>
<p>mmap N bytes per userfaultfd worker to page fault on, the default is
16MB. One can specify the size as % of total available memory or in
units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or
g.</p>
</dd>
<dt><strong>--userfaultfd-ops N</strong></dt>
<dd>
<p>stop userfaultfd stress workers after N page faults.</p>
</dd>
</dl>
</dd>
<dt><strong>SYGSYS stressor</strong></dt>
<dd>
<p><strong>--usersyscall N</strong> start N workers that exercise the
Linux prctl userspace system call mechanism. A userspace system call is
handled by a SIGSYS signal handler and exercised with the system call
disabled (ENOSYS) and enabled (via SIGSYS) using prctl
PR_SET_SYSCALL_USER_DISPATCH.</p>
<dl>
<dt><strong>--usersyscall-ops N</strong></dt>
<dd>
<p>stop after N successful userspace syscalls via a SIGSYS signal
handler.</p>
</dd>
</dl>
</dd>
<dt><strong>File timestamp stressor</strong></dt>
<dd>
<p><strong>--utime N</strong> start N workers updating file timestamps.
This is mainly CPU bound when the default is used as the system flushes
metadata changes only periodically.</p>
<dl>
<dt><strong>--utime-fsync</strong></dt>
<dd>
<p>force metadata changes on each file timestamp update to be flushed to
disk. This forces the test to become I/O bound and will result in many
dirty metadata writes.</p>
</dd>
<dt><strong>--utime-ops N</strong></dt>
<dd>
<p>stop utime stress workers after N utime bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Virtual dynamic shared object stressor</strong></dt>
<dd>
<p><strong>--vdso N</strong> start N workers that repeatedly call each
of the system call functions in the vDSO (virtual dynamic shared
object). The vDSO is a shared library that the kernel maps into the
address space of all user-space applications to allow fast access to
kernel data to some system calls without the need of performing an
expensive system call.</p>
<dl>
<dt><strong>--vdso-func F</strong></dt>
<dd>
<p>Instead of calling all the vDSO functions, just call the vDSO
function F. The functions depend on the kernel being used, but are
typically clock_gettime, getcpu, gettimeofday and time.</p>
</dd>
<dt><strong>--vdso-ops N</strong></dt>
<dd>
<p>stop after N vDSO functions calls.</p>
</dd>
</dl>
</dd>
<dt><strong>Vector floating point operations stressor</strong></dt>
<dd>
<p><strong>--vecfp N</strong> start N workers that exericise floating
point (single and double precision) addition, multiplication, division
and negation on vectors of 128, 64, 32, 16 and 8 floating point values.
The -v option will show the approximate throughput in millions of
floating pointer operations per second for each operation. For x86, the
gcc/clang target clones attribute has been used to produced vector
optimizations for a range of mmx, sse, avx and processor features.</p>
<dl>
<dt><strong>--vecfp-method method</strong></dt>
<dd>
<p>specify a vecfp stress method. By default, all the stress methods are
exercised sequentially, however one can specify just one method to be
used if required.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate through all of the following
vector methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv128add</td>
<td style="text-align: left;">addition of a vector of 128 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv64add</td>
<td style="text-align: left;">addition of a vector of 64 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv32add</td>
<td style="text-align: left;">addition of a vector of 32 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv16add</td>
<td style="text-align: left;">addition of a vector of 16 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv8add</td>
<td style="text-align: left;">addition of a vector of 8 single precision
floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv128mul</td>
<td style="text-align: left;">multiplication of a vector of 128 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv64mul</td>
<td style="text-align: left;">multiplication of a vector of 64 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv32mul</td>
<td style="text-align: left;">multiplication of a vector of 32 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv16mul</td>
<td style="text-align: left;">multiplication of a vector of 16 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv8mul</td>
<td style="text-align: left;">multiplication of a vector of 8 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv128div</td>
<td style="text-align: left;">division of a vector of 128 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv64div</td>
<td style="text-align: left;">division of a vector of 64 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv32div</td>
<td style="text-align: left;">division of a vector of 32 single
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">floatv16div</td>
<td style="text-align: left;">division of a vector of 16 single
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">floatv8div</td>
<td style="text-align: left;">division of a vector of 8 single precision
floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev128add</td>
<td style="text-align: left;">addition of a vector of 128 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev64add</td>
<td style="text-align: left;">addition of a vector of 64 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev32add</td>
<td style="text-align: left;">addition of a vector of 32 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev16add</td>
<td style="text-align: left;">addition of a vector of 16 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev8add</td>
<td style="text-align: left;">addition of a vector of 8 double precision
floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev128mul</td>
<td style="text-align: left;">multiplication of a vector of 128 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev64mul</td>
<td style="text-align: left;">multiplication of a vector of 64 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev32mul</td>
<td style="text-align: left;">multiplication of a vector of 32 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev16mul</td>
<td style="text-align: left;">multiplication of a vector of 16 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev8mul</td>
<td style="text-align: left;">multiplication of a vector of 8 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev128div</td>
<td style="text-align: left;">division of a vector of 128 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev64div</td>
<td style="text-align: left;">division of a vector of 64 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev32div</td>
<td style="text-align: left;">division of a vector of 32 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev16div</td>
<td style="text-align: left;">division of a vector of 16 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev8div</td>
<td style="text-align: left;">division of a vector of 8 double precision
floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev128neg</td>
<td style="text-align: left;">negation of a vector of 128 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev64neg</td>
<td style="text-align: left;">negation of a vector of 64 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev32neg</td>
<td style="text-align: left;">negation of a vector of 32 double
precision floating point values</td>
</tr>
<tr class="even">
<td style="text-align: left;">doublev16neg</td>
<td style="text-align: left;">negation of a vector of 16 double
precision floating point values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">doublev8neg</td>
<td style="text-align: left;">negation of a vector of 8 double precision
floating point values</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--vecfp-ops N</strong></dt>
<dd>
<p>stop after N vector floating point bogo-operations. Each bogo-op is
equivalent to 65536 loops of 2 vector operations. For example, one
bogo-op on a 16 wide vector is equivalent to 65536 × 2 × 16 floating
point operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Vector math operations stressor</strong></dt>
<dd>
<p><strong>--vecmath N</strong> start N workers that perform various
unsigned integer math operations on various 128 bit vectors. A mix of
vector math operations are performed on the following vectors: 16 × 8
bits, 8 × 16 bits, 4 × 32 bits, 2 × 64 bits. The metrics produced by
this mix depend on the processor architecture and the vector math
optimisations produced by the compiler.</p>
<dl>
<dt><strong>--vecmath-ops N</strong></dt>
<dd>
<p>stop after N bogo vector integer math operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Shuffled vector math operations stressor</strong></dt>
<dd>
<p><strong>--vecshuf N</strong> start N workers that shuffle data on
various 64 byte vectors comprised of 8, 16, 32, 64 and 128 bit unsigned
integers. The integers are shuffled around the vector with 4 shuffle
operations per loop, 65536 loops make up one bogo-op of shuffling. The
data shuffling rates and shuffle operation rates are logged when using
the -v option. This stressor exercises vector load, shuffle/permute,
packing/unpacking and store operations.</p>
<dl>
<dt><strong>--vecshuf-method method</strong></dt>
<dd>
<p>specify a vector shuffling stress method. By default, all the stress
methods are exercised sequentially, however one can specify just one
method to be used if required.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate through all of the following
vector methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">u8x64</td>
<td style="text-align: left;">shuffle a vector of 64 unsigned 8 bit
integers</td>
</tr>
<tr class="even">
<td style="text-align: left;">u16x32</td>
<td style="text-align: left;">shuffle a vector of 32 unsigned 16 bit
integers</td>
</tr>
<tr class="odd">
<td style="text-align: left;">u32x16</td>
<td style="text-align: left;">shuffle a vector of 16 unsigned 32 bit
integers</td>
</tr>
<tr class="even">
<td style="text-align: left;">u64x8</td>
<td style="text-align: left;">shuffle a vector of 8 unsigned 64 bit
integers</td>
</tr>
<tr class="odd">
<td style="text-align: left;">u128x4</td>
<td style="text-align: left;">shuffle a vector of 4 unsigned 128 bit
integers (when supported)</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--vecshuf-ops N</strong></dt>
<dd>
<p>stop after N bogo vector shuffle ops. One bogo-op is equavlent of 4 ×
65536 vector shuffle operations on 64 bytes of vector data.</p>
</dd>
</dl>
</dd>
<dt><strong>Wide vector math operations stressor</strong></dt>
<dd>
<p><strong>--vecwide N</strong> start N workers that perform various 8
bit math operations on vectors of 4, 8, 16, 32, 64, 128, 256, 512, 1024
and 2048 bytes. With the -v option the relative compute performance vs
the expected compute performance based on total run time is shown for
the first vecwide worker. The vecwide stressor exercises various
processor vector instruction mixes and how well the compiler can map the
vector operations to the target instruction set.</p>
<dl>
<dt><strong>--vecwide-ops N</strong></dt>
<dd>
<p>stop after N bogo vector operations (2048 iterations of a mix of
vector instruction operations).</p>
</dd>
</dl>
</dd>
<dt><strong>File based authenticy protection (verity)
stressor</strong></dt>
<dd>
<p><strong>--verity N</strong> start N workers that exercise read-only
file based authenticy protection using the verity ioctls
FS_IOC_ENABLE_VERITY and FS_IOC_MEASURE_VERITY. This requires file
systems with verity support (currently ext4 and f2fs on Linux) with the
verity feature enabled. The test attempts to creates a small file with
multiple small extents and enables verity on the file and verifies it.
It also checks to see if the file has verity enabled with the
FS_VERITY_FL bit set on the file flags.</p>
<dl>
<dt><strong>--verity-ops N</strong></dt>
<dd>
<p>stop the verity workers after N file create, enable verity, check
verity and unlink cycles.</p>
</dd>
</dl>
</dd>
<dt><strong>vfork stressor</strong></dt>
<dd>
<p><strong>--vfork N</strong> start N workers continually vforking
children that immediately exit.</p>
<dl>
<dt><strong>--vfork-max P</strong></dt>
<dd>
<p>create P processes and then wait for them to exit per iteration. The
default is just 1; higher values will create many temporary zombie
processes that are waiting to be reaped. One can potentially fill up the
process table using high values for --vfork-max and --vfork.</p>
</dd>
<dt><strong>--vfork-ops N</strong></dt>
<dd>
<p>stop vfork stress workers after N bogo operations.</p>
</dd>
<dt><strong>--vfork-vm</strong></dt>
<dd>
<p>deprecated since stress-ng V0.14.03</p>
</dd>
</dl>
</dd>
<dt><strong>vfork processes as much as possible stressor</strong></dt>
<dd>
<p><strong>--vforkmany N</strong> start N workers that spawn off a chain
of vfork children until the process table fills up and/or vfork fails.
vfork can rapidly create child processes and the parent process has to
wait until the child dies, so this stressor rapidly fills up the process
table.</p>
<dl>
<dt><strong>--vforkmany-ops N</strong></dt>
<dd>
<p>stop vforkmany stressors after N vforks have been made.</p>
</dd>
<dt><strong>--vforkmany-vm</strong></dt>
<dd>
<p>enable detrimental performance virtual memory advice using madvise on
all pages of the vforked process. Where possible this will try to set
every page in the new process with using madvise MADV_MERGEABLE,
MADV_WILLNEED, MADV_HUGEPAGE and MADV_RANDOM flags. Linux only.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory allocate and write stressor</strong></dt>
<dd>
<p><strong>-m N, --vm N</strong> start N workers continuously calling
mmap(2)/munmap(2) and writing to the allocated memory. Note that this
can cause systems to trip the kernel OOM killer on Linux systems if not
enough physical memory and swap is not available.</p>
<dl>
<dt><strong>--vm-bytes N</strong></dt>
<dd>
<p>mmap N bytes per vm worker, the default is 256MB. One can specify the
size as % of total available memory or in units of Bytes, KBytes, MBytes
and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--vm-hang N</strong></dt>
<dd>
<p>sleep N seconds before unmapping memory, the default is zero seconds.
Specifying 0 will do an infinite wait.</p>
</dd>
<dt><strong>--vm-keep</strong></dt>
<dd>
<p>do not continually unmap and map memory, just keep on re-writing to
it.</p>
</dd>
<dt><strong>--vm-locked</strong></dt>
<dd>
<p>Lock the pages of the mapped region into memory using mmap MAP_LOCKED
(since Linux 2.5.37). This is similar to locking memory as described in
mlock(2).</p>
</dd>
<dt><strong>--vm-madvise advice</strong></dt>
<dd>
<p>Specify the madvise 'advice' option used on the memory mapped regions
used in the vm stressor. Non-linux systems will only have the 'normal'
madvise advice, linux systems support 'dontneed', 'hugepage',
'mergeable' , 'nohugepage', 'normal', 'random', 'sequential',
'unmergeable' and 'willneed' advice. If this option is not used then the
default is to pick random madvise advice for each mmap call. See
madvise(2) for more details.</p>
</dd>
<dt><strong>--vm-method method</strong></dt>
<dd>
<p>specify a vm stress method. By default, all the stress methods are
exercised sequentially, however one can specify just one method to be
used if required. Each of the vm workers have 3 phases:</p>
<p>1. Initialised. The anonymously memory mapped region is set to a
known pattern.</p>
<p>2. Exercised. Memory is modified in a known predictable way. Some vm
workers alter memory sequentially, some use small or large strides to
step along memory.</p>
<p>3. Checked. The modified memory is checked to see if it matches the
expected result.</p>
<p>The vm methods containing 'prime' in their name have a stride of the
largest prime less than 2↑64, allowing to them to thoroughly step
through memory and touch all locations just once while also doing
without touching memory cells next to each other. This strategy
exercises the cache and page non-locality.</p>
<p>Since the memory being exercised is virtually mapped then there is no
guarantee of touching page addresses in any particular physical order.
These workers should not be used to test that all the system's memory is
working correctly either, use tools such as memtest86 instead.</p>
<p>The vm stress methods are intended to exercise memory in ways to
possibly find memory issues and to try to force thermal errors.</p>
<p>Available vm stress methods are described as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the vm stress methods as
listed below.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cache-lines</td>
<td style="text-align: left;">work through memory in 64 byte cache sized
steps writing a single byte per cache line. Once the write is complete,
the memory is read to verify the values are written correctly.</td>
</tr>
<tr class="even">
<td style="text-align: left;">cache-stripe</td>
<td style="text-align: left;">work through memory in 64 byte cache sized
chunks, writing in ascending address order on even offsets and
descending address order on odd offsets.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">checkboard</td>
<td style="text-align: left;">work through memory writing alternative
zero/one bit values into memory in a mixed checkerboard pattern. Memory
is swapped around to ensure every bit is read, bit flipped and
re-written and then re-read for verification.</td>
</tr>
<tr class="even">
<td style="text-align: left;">flip</td>
<td style="text-align: left;">sequentially work through memory 8 times,
each time just one bit in memory flipped (inverted). This will
effectively invert each byte in 8 passes.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fwdrev</td>
<td style="text-align: left;">write to even addressed bytes in a forward
direction and odd addressed bytes in reverse direction. rhe contents are
sanity checked once all the addresses have been written to.</td>
</tr>
<tr class="even">
<td style="text-align: left;">galpat-0</td>
<td style="text-align: left;">galloping pattern zeros. This sets all
bits to 0 and flips just 1 in 4096 bits to 1. It then checks to see if
the 1s are pulled down to 0 by their neighbours or of the neighbours
have been pulled up to 1.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">galpat-1</td>
<td style="text-align: left;">galloping pattern ones. This sets all bits
to 1 and flips just 1 in 4096 bits to 0. It then checks to see if the 0s
are pulled up to 1 by their neighbours or of the neighbours have been
pulled down to 0.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gray</td>
<td style="text-align: left;">fill the memory with sequential gray codes
(these only change 1 bit at a time between adjacent bytes) and then
check if they are set correctly.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">grayflip</td>
<td style="text-align: left;">fill memory with adjacent bytes of gray
code and inverted gray code pairs to change as many bits at a time
between adjacent bytes and check if these are set correctly.</td>
</tr>
<tr class="even">
<td style="text-align: left;">incdec</td>
<td style="text-align: left;">work sequentially through memory twice,
the first pass increments each byte by a specific value and the second
pass decrements each byte back to the original start value. The
increment/decrement value changes on each invocation of the
stressor.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">inc-nybble</td>
<td style="text-align: left;">initialise memory to a set value (that
changes on each invocation of the stressor) and then sequentially work
through each byte incrementing the bottom 4 bits by 1 and the top 4 bits
by 15.</td>
</tr>
<tr class="even">
<td style="text-align: left;">lfsr32</td>
<td style="text-align: left;">fill memory with values generated from a
32 bit Galois linear feedback shift register using the polynomial x↑32 +
x↑31 + x↑29 + x + 1. This generates a ring of 2↑32 - 1 unique values
(all 32 bit values except for 0).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rand-set</td>
<td style="text-align: left;">sequentially work through memory in 64 bit
chunks setting bytes in the chunk to the same 8 bit random value. The
random value changes on each chunk. Check that the values have not
changed.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rand-sum</td>
<td style="text-align: left;">sequentially set all memory to random
values and then summate the number of bits that have changed from the
original set values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">read64</td>
<td style="text-align: left;">sequentially read memory using 32 × 64 bit
reads per bogo loop. Each loop equates to one bogo operation. This
exercises raw memory reads.</td>
</tr>
<tr class="even">
<td style="text-align: left;">ror</td>
<td style="text-align: left;">fill memory with a random pattern and then
sequentially rotate 64 bits of memory right by one bit, then check the
final load/rotate/stored values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">swap</td>
<td style="text-align: left;">fill memory in 64 byte chunks with random
patterns. Then swap each 64 chunk with a randomly chosen chunk. Finally,
reverse the swap to put the chunks back to their original place and
check if the data is correct. This exercises adjacent and random memory
load/stores.</td>
</tr>
<tr class="even">
<td style="text-align: left;">move-inv</td>
<td style="text-align: left;">sequentially fill memory 64 bits of memory
at a time with random values, and then check if the memory is set
correctly. Next, sequentially invert each 64 bit pattern and again check
if the memory is set as expected.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">modulo-x</td>
<td style="text-align: left;">fill memory over 23 iterations. Each
iteration starts one byte further along from the start of the memory and
steps along in 23 byte strides. In each stride, the first byte is set to
a random pattern and all other bytes are set to the inverse. Then it
checks see if the first byte contains the expected random pattern. This
exercises cache store/reads as well as seeing if neighbouring cells
influence each other.</td>
</tr>
<tr class="even">
<td style="text-align: left;">mscan</td>
<td style="text-align: left;">fill each bit in each byte with 1s then
check these are set, fill each bit in each byte with 0s and check these
are clear.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prime-0</td>
<td style="text-align: left;">iterate 8 times by stepping through memory
in very large prime strides clearing just on bit at a time in every
byte. Then check to see if all bits are set to zero.</td>
</tr>
<tr class="even">
<td style="text-align: left;">prime-1</td>
<td style="text-align: left;">iterate 8 times by stepping through memory
in very large prime strides setting just on bit at a time in every byte.
Then check to see if all bits are set to one.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prime-gray-0</td>
<td style="text-align: left;">first step through memory in very large
prime strides clearing just on bit (based on a gray code) in every byte.
Next, repeat this but clear the other 7 bits. Then check to see if all
bits are set to zero.</td>
</tr>
<tr class="even">
<td style="text-align: left;">prime-gray-1</td>
<td style="text-align: left;">first step through memory in very large
prime strides setting just on bit (based on a gray code) in every byte.
Next, repeat this but set the other 7 bits. Then check to see if all
bits are set to one.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rowhammer</td>
<td style="text-align: left;">try to force memory corruption using the
rowhammer memory stressor. This fetches two 32 bit integers from memory
and forces a cache flush on the two addresses multiple times. This has
been known to force bit flipping on some hardware, especially with lower
frequency memory refresh cycles.</td>
</tr>
<tr class="even">
<td style="text-align: left;">walk-0d</td>
<td style="text-align: left;">for each byte in memory, walk through each
data line setting them to low (and the others are set high) and check
that the written value is as expected. This checks if any data lines are
stuck.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">walk-1d</td>
<td style="text-align: left;">for each byte in memory, walk through each
data line setting them to high (and the others are set low) and check
that the written value is as expected. This checks if any data lines are
stuck.</td>
</tr>
<tr class="even">
<td style="text-align: left;">walk-0a</td>
<td style="text-align: left;">in the given memory mapping, work through
a range of specially chosen addresses working through address lines to
see if any address lines are stuck low. This works best with physical
memory addressing, however, exercising these virtual addresses has some
value too.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">walk-1a</td>
<td style="text-align: left;">in the given memory mapping, work through
a range of specially chosen addresses working through address lines to
see if any address lines are stuck high. This works best with physical
memory addressing, however, exercising these virtual addresses has some
value too.</td>
</tr>
<tr class="even">
<td style="text-align: left;">write64</td>
<td style="text-align: left;">sequentially write to memory using 32 × 64
bit writes per bogo loop. Each loop equates to one bogo operation. This
exercises raw memory writes. Note that memory writes are not checked at
the end of each test iteration.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">write64nt</td>
<td style="text-align: left;">sequentially write to memory using 32 × 64
bit non-temporal writes per bogo loop. Each loop equates to one bogo
operation. This exercises cacheless raw memory writes and is only
available on x86 sse2 capable systems built with gcc and clang
compilers. Note that memory writes are not checked at the end of each
test iteration.</td>
</tr>
<tr class="even">
<td style="text-align: left;">write1024v</td>
<td style="text-align: left;">sequentially write to memory using 1 ×
1024 bit vector write per bogo loop (only available if the compiler
supports vector types). Each loop equates to one bogo operation. This
exercises raw memory writes. Note that memory writes are not checked at
the end of each test iteration.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">wrrd128nt</td>
<td style="text-align: left;">write to memory in 128 bit chunks using
non-temporal writes (bypassing the cache). Each chunk is written 4 times
to hammer the memory. Then check to see if the data is correct using
non-temporal reads if they are available or normal memory reads if not.
Only available with processors that provide non-temporal 128 bit
writes.</td>
</tr>
<tr class="even">
<td style="text-align: left;">zero-one</td>
<td style="text-align: left;">set all memory bits to zero and then check
if any bits are not zero. Next, set all the memory bits to one and check
if any bits are not one.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>--vm-ops N</strong></dt>
<dd>
<p>stop vm workers after N bogo operations.</p>
</dd>
<dt><strong>--vm-populate</strong></dt>
<dd>
<p>populate (prefault) page tables for the memory mappings; this can
stress swapping. Only available on systems that support MAP_POPULATE
(since Linux 2.5.46).</p>
</dd>
</dl>
</dd>
<dt><strong>Virtual memory addressing stressor</strong></dt>
<dd>
<p><strong>--vm-addr N</strong> start N workers that exercise virtual
memory addressing using various methods to walk through a memory mapped
address range. This will exercise mapped private addresses from 8MB to
64MB per worker and try to generate cache and TLB inefficient addressing
patterns. Each method will set the memory to a random pattern in a write
phase and then sanity check this in a read phase.</p>
<dl>
<dt><strong>--vm-addr-method method</strong></dt>
<dd>
<p>specify a vm address stress method. By default, all the stress
methods are exercised sequentially, however one can specify just one
method to be used if required.</p>
<p>Available vm address stress methods are described as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">iterate over all the vm stress methods as
listed below.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bitposn</td>
<td style="text-align: left;">iteratively write to memory in powers of 2
strides of max_stride to 1 and then read check memory in powers of 2
strides 1 to max_stride where max_stride is half the size of the memory
mapped region. All bit positions of the memory address space are bit
flipped in the striding.</td>
</tr>
<tr class="even">
<td style="text-align: left;">dec</td>
<td style="text-align: left;">work through the address range backwards
sequentially, byte by byte.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">decinv</td>
<td style="text-align: left;">like dec, but with all the relevant
address bits inverted.</td>
</tr>
<tr class="even">
<td style="text-align: left;">flip</td>
<td style="text-align: left;">address memory using gray coded addresses
and their inverse to flip as many address bits per write/read
operation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gray</td>
<td style="text-align: left;">work through memory with gray coded
addresses so that each change of address just changes 1 bit compared to
the previous address.</td>
</tr>
<tr class="even">
<td style="text-align: left;">grayinv</td>
<td style="text-align: left;">like gray, but with the all relevant
address bits inverted, hence all bits change apart from 1 in the address
range.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">inc</td>
<td style="text-align: left;">work through the address range forwards
sequentially, byte by byte.</td>
</tr>
<tr class="even">
<td style="text-align: left;">incinv</td>
<td style="text-align: left;">like inc, but with all the relevant
address bits inverted.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pwr2</td>
<td style="text-align: left;">work through memory addresses in steps of
powers of two.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pwr2inv</td>
<td style="text-align: left;">like pwr2, but with the all relevant
address bits inverted.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rev</td>
<td style="text-align: left;">work through the address range with the
bits in the address range reversed.</td>
</tr>
<tr class="even">
<td style="text-align: left;">revinv</td>
<td style="text-align: left;">like rev, but with all the relevant
address bits inverted.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>--vm-addr-mlock</strong></dt>
<dd>
<p>attempt to mlock pages into memory causing more memory pressure by
preventing pages from swapped out.</p>
</dd>
<dt><strong>--vm-addr-ops N</strong></dt>
<dd>
<p>stop N workers after N bogo addressing passes.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory transfer between parent and child processes stressor
(Linux)</strong></dt>
<dd>
<p><strong>--vm-rw N</strong> start N workers that transfer memory
to/from a parent/child using process_vm_writev(2) and
process_vm_readv(2). This is feature is only supported on Linux. Memory
transfers are only verified if the --verify option is enabled.</p>
<dl>
<dt><strong>--vm-rw-bytes N</strong></dt>
<dd>
<p>mmap N bytes per vm-rw worker, the default is 16MB. One can specify
the size as % of total available memory or in units of Bytes, KBytes,
MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--vm-rw-ops N</strong></dt>
<dd>
<p>stop vm-rw workers after N memory read/writes.</p>
</dd>
</dl>
</dd>
<dt><strong>Memory unmap from a child process stressor</strong></dt>
<dd>
<p><strong>--vm-segv N</strong> start N workers that create a child
process that unmaps its address space causing a SIGSEGV on return from
the unmap.</p>
<dl>
<dt><strong>--vm-segv-ops N</strong></dt>
<dd>
<p>stop after N bogo vm-segv SIGSEGV faults.</p>
</dd>
</dl>
</dd>
<dt><strong>Vmsplice stressor (Linux)</strong></dt>
<dd>
<p><strong>--vm-splice N</strong> move data from memory to /dev/null
through a pipe without any copying between kernel address space and user
address space using vmsplice(2) and splice(2). This is only available
for Linux.</p>
<dl>
<dt><strong>--vm-splice-bytes N</strong></dt>
<dd>
<p>transfer N bytes per vmsplice call, the default is 64K. One can
specify the size as % of total available memory or in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.</p>
</dd>
<dt><strong>--vm-splice-ops N</strong></dt>
<dd>
<p>stop after N bogo vm-splice operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Virtual Memory Area (VMA) stressor</strong></dt>
<dd>
<p><strong>--vma N</strong> start M workers that create pthreads to
mmap, munmap, mlock, munlock, madvise, msync, mprotect, mincore and
access 16 pages in a randomly selected virtual memory address space.
This is designed to trip races on VMA page modifications. Every 15
seconds a different virtual address space is randonly chosen.</p>
<dl>
<dt><strong>--vma-ops N</strong></dt>
<dd>
<p>stop the vma stressors after N successful memory mappings.</p>
</dd>
</dl>
</dd>
<dt><strong>Vector neural network instructions stressor</strong></dt>
<dd>
<p><strong>--vnni N</strong> start N workers that exercise vector neural
network instructions (VNNI) used in convolutional neural network loops.
A 256 byte vector is operated upon using 8 bit multiply with 16 bit
summation, 16 bit multiply and 32 bit summation, and 8 bit summation.
When processor features allow, these operations using 512, 256 and 128
bit vector operations. Generic non-vectorized code variants also
provided (which may be vectorized by more advanced optimising
compilers).</p>
<dl>
<dt><strong>--vnni-intrinsic</strong></dt>
<dd>
<p>just use the vnni methods that use intrinsic VNNI instructions and
ignore the generic non-vectorized methods.</p>
</dd>
<dt><strong>--vnni-method N</strong></dt>
<dd>
<p>select the VNNI method to be exercised, may be one of:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">exercise all the following VNNI
methods</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpaddb512</td>
<td style="text-align: left;">8 bit vector addition using 512 bit vector
operations on 64 × 8 bit integers, (x86 vpaddb)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpaddb256</td>
<td style="text-align: left;">8 bit vector addition using 256 bit vector
operations on 32 × 8 bit integers, (x86 vpaddb)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpaddb128</td>
<td style="text-align: left;">8 bit vector addition using 128 bit
vectors operations on 32 × 8 bit integers, (x86 vpaddb)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpaddb</td>
<td style="text-align: left;">8 bit vector addition using 8 bit
sequential addition (may be vectorized by the compiler)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpdpbusd512</td>
<td style="text-align: left;">8 bit vector multiplication of unsigned
and signed 8 bit values followed by 16 bit summation using 512 bit
vector operations on 64 × 8 bit integers, (x86 vpdpbusd)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpdpbusd256</td>
<td style="text-align: left;">8 bit vector multiplication of unsigned
and signed 8 bit values followed by 16 bit summation using 256 bit
vector operations on 32 × 8 bit integers, (x86 vpdpbusd)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpdpbusd128</td>
<td style="text-align: left;">8 bit vector multiplication of unsigned
and signed 8 bit values followed by 16 bit summation using 128 bit
vector operations on 32 × 8 bit integers, (x86 vpdpbusd)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpdpbusd</td>
<td style="text-align: left;">8 bit vector multiplication of unsigned
and signed 8 bit values followed by 16 bit summation using sequential
operations (may be vectorized by the compiler)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpdpwssd512</td>
<td style="text-align: left;">16 bit vector multiplication of unsigned
and signed 16 bit values followed by 32 bit summation using 512 bit
vector operations on 64 × 8 bit integers, (x86 vpdpwssd)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpdpwssd256</td>
<td style="text-align: left;">16 bit vector multiplication of unsigned
and signed 16 bit values followed by 32 bit summation using 256 bit
vector operations on 64 × 8 bit integers, (x86 vpdpwssd)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vpdpwssd128</td>
<td style="text-align: left;">16 bit vector multiplication of unsigned
and signed 16 bit values followed by 32 bit summation using 128 bit
vector operations on 64 × 8 bit integers, (x86 vpdpwssd)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vpdpwssd</td>
<td style="text-align: left;">16 bit vector multiplication of unsigned
and signed 16 bit values followed by 32 bit summation using sequential
operations (may be vectorized by the compiler)</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--vnni-ops N</strong></dt>
<dd>
<p>stop after N bogo VNNI computation operations. 1 bogo-op is
equivalent to 1024 convolution loops operating on 256 bytes of data.</p>
</dd>
</dl>
</dd>
<dt><strong>Pausing and resuming threads stressor</strong></dt>
<dd>
<p><strong>--wait N</strong> start N workers that spawn off two
children; one spins in a pause(2) loop, the other continually stops and
continues the first. The controlling process waits on the first child to
be resumed by the delivery of SIGCONT using waitpid(2) and
waitid(2).</p>
<dl>
<dt><strong>--wait-ops N</strong></dt>
<dd>
<p>stop after N bogo wait operations.</p>
</dd>
</dl>
</dd>
<dt><strong>CPU wait instruction stressor</strong></dt>
<dd>
<p><strong>--waitcpu N</strong> start N workers that exercise processor
wait instructions. For x86 these are pause, tpause and umwait (when
available) and nop. For ARM the yield instruction is used. For other
architectures currently nop instructions are used.</p>
<dl>
<dt><strong>--waitcpu-ops N</strong></dt>
<dd>
<p>stop after N bogo processor wait operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Watchdog stressor</strong></dt>
<dd>
<p><strong>--watchdog N</strong> start N workers that exercising the
/dev/watchdog watchdog interface by opening it, perform various watchdog
specific ioctl(2) commands on the device and close it. Before closing
the special watchdog magic close message is written to the device to try
and force it to never trip a watchdog reboot after the stressor has been
run. Note that this stressor needs to be run as root with the
--pathological option and is only available on Linux.</p>
<dl>
<dt><strong>--watchdog-ops N</strong></dt>
<dd>
<p>stop after N bogo operations on the watchdog device.</p>
</dd>
</dl>
</dd>
<dt><strong>Libc wide characterstring function stressor</strong></dt>
<dd>
<p><strong>--wcs N</strong> start N workers that exercise various libc
wide character string functions on random strings.</p>
<dl>
<dt><strong>--wcs-method wcsfunc</strong></dt>
<dd>
<p>select a specific libc wide character string function to stress.
Available string functions to stress are: all, wcscasecmp, wcscat,
wcschr, wcscoll, wcscmp, wcscpy, wcslen, wcsncasecmp, wcsncat, wcsncmp,
wcsrchr and wcsxfrm. The 'all' method is the default and will exercise
all the string methods.</p>
</dd>
<dt><strong>--wcs-ops N</strong></dt>
<dd>
<p>stop after N bogo wide character string operations.</p>
</dd>
</dl>
</dd>
<dt><strong>scheduler workload stressor</strong></dt>
<dd>
<p><strong>--workload N</strong> start N workers that exercise the
scheduler with items of work that are started at random times with
random sleep delays between work items. By default a 100,000 microsecond
slice of time has 100 work items that start at random times during the
slice. The work items by default run for a quanta of 1000 microseconds
scaled by the percentage work load (default of 30%). For a slice of S
microseconds and a work item quanta duration of Q microseconds, S / Q
work items are executed per slice. For a work load of L percent, the run
time per item is the quanta Q × L / 100 microseconds. The --workload-
hreads option allows work items to be taken from a queue and run
concurrently if the scheduling run times overlap.<br />
If a work item is already running when a new work item is scheduled to
run then the new work item is delayed and starts directly after the
completion of the currently running work item when running with the
default of zero worker threads. This emulates bursty scheduled compute,
such as handling input packets where one may have lots of work items
bunched together or with random unpredictable delays between work
items.</p>
<dl>
<dt><strong>--workload-load L</strong></dt>
<dd>
<p>specify the percentage run time load of each work item with respect
to the run quanta duration. Essentially the run duration of each work
item is the quanta duration Q × L / 100.</p>
</dd>
<dt><strong>--workload-method method</strong></dt>
<dd>
<p>select the workload method. Each quanta of execution time is consumed
using a tight spin-loop executing a workload method. The available
methods are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method Description</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">all</td>
<td style="text-align: left;">randomly select any one of all the
following methods:</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fma</td>
<td style="text-align: left;">perform multiply-add operations, on modern
processors these may be compiled into fused-multiply-add
instructions.</td>
</tr>
<tr class="even">
<td style="text-align: left;">getpid</td>
<td style="text-align: left;">get the stressor's PID via getpid(2).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">time</td>
<td style="text-align: left;">get the current time via time(2).</td>
</tr>
<tr class="even">
<td style="text-align: left;">inc64</td>
<td style="text-align: left;">increment a 64 bit integer.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">memmove</td>
<td style="text-align: left;">copy (move) a 1MB buffer using
memmove(3).</td>
</tr>
<tr class="even">
<td style="text-align: left;">memread</td>
<td style="text-align: left;">read from a 1MB buffer using fast memory
reads.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">memset</td>
<td style="text-align: left;">write to a 1MB buffer using
memset(3).</td>
</tr>
<tr class="even">
<td style="text-align: left;">mcw64</td>
<td style="text-align: left;">compute 64 bit random numbers using a mwc
random generator.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">nop</td>
<td style="text-align: left;">waste cycles using no-op
instructions.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pause</td>
<td style="text-align: left;">stop execution using CPU pause/yield or
memory barrier instructions where available.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random</td>
<td style="text-align: left;">a random mix of all the workload methods,
changing the workload method on every spin-loop.</td>
</tr>
<tr class="even">
<td style="text-align: left;">sqrt</td>
<td style="text-align: left;">perform double precision floating point
sqrt(3) and hypot(3) math operations.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--workload-sched [ batch | deadline | idle | fifo | other |
rr ]</strong></dt>
<dd>
<p>select scheduling policy. Note that fifo and rr require root
privilege to set.</p>
</dd>
<dt><strong>--workload-slice-us S</strong></dt>
<dd>
<p>specify the duration of each scheduling slice in microseconds. The
default is 100,000 microseconds (0.1 seconds).</p>
</dd>
<dt><strong>--workload-quanta-us Q</strong></dt>
<dd>
<p>specify the duration of each work item in microseconds. The default
is 1000 microseconds (1 millisecond).</p>
</dd>
<dt><strong>--workload-threads N</strong></dt>
<dd>
<p>use N process threads to take scheduler work items of a workqueue and
run the work item. When N is 0 (default), no threads are used and the
work items are run back-to-back sequentially without using work queue.
Using more than 2 threads allows work items to be handled concurrently
if enough idle processors are available.</p>
</dd>
<dt><strong>--workload-dist [ cluster | even | poisson | random1 |
random2 | random3 ]</strong></dt>
<dd>
<p>specify the scheduling distribution of work items, the default is
cluster. The distribution methods are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">cluster</td>
<td style="text-align: left;">cluster 2/3 of the start times to try to
start at the random time during the time slice, with the other 1/3 of
start times evenly randomly distributed using a single random variable.
The clustered start times causes a burst of items to be scheduled in a
bunch with no delays between each clustered work item.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">even</td>
<td style="text-align: left;">evenly distribute scheduling start times
across the workload slice</td>
</tr>
<tr class="even">
<td style="text-align: left;">poisson</td>
<td style="text-align: left;">generate scheduling events that occur
individually at random moments, but which tend to occur at an average
rate (known as a Poisson process).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random1</td>
<td style="text-align: left;">evenly randomly distribute scheduling
start times using a single random variable.</td>
</tr>
<tr class="even">
<td style="text-align: left;">random2</td>
<td style="text-align: left;">randomly distribute scheduling start times
using a sum of two random variables, much like throwing 2 dice.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random3</td>
<td style="text-align: left;">randomly distribute scheduling start times
using a sum of three random variables, much like throwing 3 dice.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--workload-ops N</strong></dt>
<dd>
<p>stop the workload workers after N workload bogo-operations.</p>
</dd>
</dl>
</dd>
<dt><strong>x86 cpuid stressor</strong></dt>
<dd>
<p><strong>--x86cpuid N</strong> start N workers that exercise the x86
cpuid instruction with 18 different leaf types.</p>
<dl>
<dt><strong>--x86cpuid-ops N</strong></dt>
<dd>
<p>stop after N iterations that exercise the different cpuid leaf
types.</p>
</dd>
</dl>
</dd>
<dt><strong>x86-64 syscall stressor (Linux)</strong></dt>
<dd>
<p><strong>--x86syscall N</strong> start N workers that repeatedly
exercise the x86-64 syscall instruction to call the getcpu(2),
geteuid(2), getgid(2), getpid(2), gettimeofday(2) and time(2) system
calls using the Linux vsyscall handler. Only for Linux.</p>
<dl>
<dt><strong>--x86syscall-func F</strong></dt>
<dd>
<p>Instead of exercising the 6 syscall system calls, just call the
syscall function F. The function F must be one of getcpu, geteuid,
getgid, getpid, gettimeofday or time.</p>
</dd>
<dt><strong>--x86syscall-ops N</strong></dt>
<dd>
<p>stop after N x86syscall system calls.</p>
</dd>
</dl>
</dd>
<dt><strong>Extended file attributes stressor</strong></dt>
<dd>
<p><strong>--xattr N</strong> start N workers that create, update and
delete batches of extended attributes on a file.</p>
<dl>
<dt><strong>--xattr-ops N</strong></dt>
<dd>
<p>stop after N bogo extended attribute operations.</p>
</dd>
</dl>
</dd>
<dt><strong>Yield scheduling stressor</strong></dt>
<dd>
<p><strong>-y N, --yield N</strong> start N workers that call
sched_yield(2). This stressor ensures that at least 2 child processes
per CPU exercise shield_yield(2) no matter how many workers are
specified, thus always ensuring rapid context switching.</p>
<dl>
<dt><strong>--yield-ops N</strong></dt>
<dd>
<p>stop yield stress workers after N sched_yield(2) bogo operations.</p>
</dd>
</dl>
</dd>
<dt><strong>/dev/zero stressor</strong></dt>
<dd>
<p><strong>--zero N</strong> start N workers that exercise /dev/zero
with reads, lseeks, ioctls and mmaps. For just /dev/zero read
benchmarking use the --zero-read option.</p>
<dl>
<dt><strong>--zero-ops N</strong></dt>
<dd>
<p>stop zero stress workers after N /dev/zero bogo read operations.</p>
</dd>
<dt><strong>--zero-read</strong></dt>
<dd>
<p>just read /dev/zero with 4K reads with no additional exercising on
/dev/zero.</p>
</dd>
</dl>
</dd>
<dt><strong>Zlib stressor</strong></dt>
<dd>
<p><strong>--zlib N</strong> start N workers compressing and
decompressing random data using zlib. Each worker has two processes, one
that compresses random data and pipes it to another process that
decompresses the data. This stressor exercises CPU, cache and
memory.</p>
<dl>
<dt><strong>--zlib-level L</strong></dt>
<dd>
<p>specify the compression level (0..9), where 0 = no compression, 1 =
fastest compression and 9 = best compression.</p>
</dd>
<dt><strong>--zlib-mem-level L</strong></dt>
<dd>
<p>specify the reserved compression state memory for zlib. Default is
8.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Value</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: left;">minimum memory usage.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: left;">maximum memory usage.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--zlib-method method</strong></dt>
<dd>
<p>specify the type of random data to send to the zlib library. By
default, the data stream is created from a random selection of the
different data generation processes. However one can specify just one
method to be used if required. Available zlib data generation methods
are described as follows:</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;">00ff</td>
<td style="text-align: left;">randomly distributed 0x00 and 0xFF
values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ascii01</td>
<td style="text-align: left;">randomly distributed ASCII 0 and 1
characters.</td>
</tr>
<tr class="even">
<td style="text-align: left;">asciidigits</td>
<td style="text-align: left;">randomly distributed ASCII digits in the
range of 0 and 9.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bcd</td>
<td style="text-align: left;">packed binary coded decimals, 0..99 packed
into 2 4-bit nybbles.</td>
</tr>
<tr class="even">
<td style="text-align: left;">binary</td>
<td style="text-align: left;">32 bit random numbers.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">brown</td>
<td style="text-align: left;">8 bit brown noise (Brownian motion/Random
Walk noise).</td>
</tr>
<tr class="even">
<td style="text-align: left;">double</td>
<td style="text-align: left;">double precision floating point numbers
from sin(θ).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fixed</td>
<td style="text-align: left;">data stream is repeated 0x04030201.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gcr</td>
<td style="text-align: left;">random values as 4 × 4 bit data turned
into 4 × 5 bit group coded recording (GCR) patterns. Each 5 bit GCR
value starts or ends with at most one zero bit so that concatenated GCR
codes have no more than two zero bits in a row.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gray</td>
<td style="text-align: left;">16 bit gray codes generated from an
incrementing counter.</td>
</tr>
<tr class="even">
<td style="text-align: left;">inc16</td>
<td style="text-align: left;">16 bit incrementing values starting from a
random 16 bit value.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">latin</td>
<td style="text-align: left;">Random latin sentences from a sample of
Lorem Ipsum text.</td>
</tr>
<tr class="even">
<td style="text-align: left;">lehmer</td>
<td style="text-align: left;">Fast random values generated using
Lehmer's generator using a 128 bit multiply.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lfsr32</td>
<td style="text-align: left;">Values generated from a 32 bit Galois
linear feedback shift register using the polynomial x↑32 + x↑31 + x↑29 +
x + 1. This generates a ring of 2↑32 - 1 unique values (all 32 bit
values except for 0).</td>
</tr>
<tr class="even">
<td style="text-align: left;">logmap</td>
<td style="text-align: left;">Values generated from a logistical map of
the equation Χn+1 = r × Χn × (1 - Χn) where r &gt; ≈ 3.56994567 to
produce chaotic data. The values are scaled by a large arbitrary value
and the lower 8 bits of this value are compressed.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lrand48</td>
<td style="text-align: left;">Uniformly distributed pseudo-random 32 bit
values generated from lrand48(3).</td>
</tr>
<tr class="even">
<td style="text-align: left;">morse</td>
<td style="text-align: left;">Morse code generated from random latin
sentences from a sample of Lorem Ipsum text.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">nybble</td>
<td style="text-align: left;">randomly distributed bytes in the range of
0x00 to 0x0f.</td>
</tr>
<tr class="even">
<td style="text-align: left;">objcode</td>
<td style="text-align: left;">object code selected from a random start
point in the stress-ng text segment.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">parity</td>
<td style="text-align: left;">7 bit binary data with 1 parity bit.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pink</td>
<td style="text-align: left;">pink noise in the range 0..255 generated
using the Gardner method with the McCartney selection tree optimization.
Pink noise is where the power spectral density is inversely proportional
to the frequency of the signal and hence is slightly compressible.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">random</td>
<td style="text-align: left;">segments of the data stream are created by
randomly calling the different data generation methods.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rarely1</td>
<td style="text-align: left;">data that has a single 1 in every 32 bits,
randomly located.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rarely0</td>
<td style="text-align: left;">data that has a single 0 in every 32 bits,
randomly located.</td>
</tr>
<tr class="even">
<td style="text-align: left;">rdrand</td>
<td style="text-align: left;">generate random data using rdrand
instruction (x86) or use 64 bit mwc psuedo-random number generator for
non-x86 systems.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ror32</td>
<td style="text-align: left;">generate a 32 bit random value, rotate it
right 0 to 7 places and store the rotated value for each of the
rotations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">text</td>
<td style="text-align: left;">random ASCII text.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">utf8</td>
<td style="text-align: left;">random 8 bit data encoded to UTF-8.</td>
</tr>
<tr class="even">
<td style="text-align: left;">zero</td>
<td style="text-align: left;">all zeros, compresses very easily.</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--zlib-ops N</strong></dt>
<dd>
<p>stop after N bogo compression operations, each bogo compression
operation is a compression of 64K of random data at the highest
compression level.</p>
</dd>
<dt><strong>--zlib-strategy S</strong></dt>
<dd>
<p>specifies the strategy to use when deflating data. This is used to
tune the compression algorithm. Default is 0.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Value</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: left;">used for normal data
(Z_DEFAULT_STRATEGY).</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;">for data generated by a filter or
predictor (Z_FILTERED)</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;">forces huffman encoding
(Z_HUFFMAN_ONLY).</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;">Limit match distances to one
run-length-encoding (Z_RLE).</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: left;">prevents dynamic huffman codes
(Z_FIXED).</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--zlib-stream-bytes S</strong></dt>
<dd>
<p>specify the amount of bytes to deflate until deflate should finish
the block and return with Z_STREAM_END. One can specify the size in
units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.
Default is 0 which creates and endless stream until stressor ends.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Value</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: left;">creates an endless deflate stream until
stressor stops.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">n</td>
<td style="text-align: left;">creates an stream of n bytes over and over
again.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: left;">Each block will be closed with
Z_STREAM_END.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>--zlib-window-bits W</strong></dt>
<dd>
<p>specify the window bits used to specify the history buffer size. The
value is specified as the base two logarithm of the buffer size (e.g.
value 9 is 2↑9 = 512 bytes). Default is 15.</p>
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Value</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">-8-(-15)</td>
<td style="text-align: left;">raw deflate format.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">8-15</td>
<td style="text-align: left;">zlib format.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">24-31</td>
<td style="text-align: left;">gzip format.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">40-47</td>
<td style="text-align: left;">inflate auto format detection using zlib
deflate format.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Zombie processes stressor</strong></dt>
<dd>
<p><strong>--zombie N</strong> start N workers that create zombie
processes. This will rapidly try to create a default of 8192 child
processes that immediately die and wait in a zombie state until they are
reaped. Once the maximum number of processes is reached (or fork fails
because one has reached the maximum allowed number of children) the
oldest child is reaped and a new process is then created in a first-in
first-out manner, and then repeated.</p>
<dl>
<dt><strong>--zombie-max N</strong></dt>
<dd>
<p>try to create as many as N zombie processes. This may not be reached
if the system limit is less than N.</p>
</dd>
<dt><strong>--zombie-ops N</strong></dt>
<dd>
<p>stop zombie stress workers after N bogo zombie operations.</p>
</dd>
</dl>
</dd>
</dl>
<h1>EXAMPLES</h1>
<p><code>stress-ng --vm 8 --vm-bytes 80% -t 1h</code></p>
<blockquote>
<p>run 8 virtual memory stressors that combined use 80% of the available
memory for 1 hour. Thus each stressor uses 10% of the available
memory.</p>
</blockquote>
<p><code>stress-ng --cpu 4 --io 2 --vm 1 --vm-bytes 1G --timeout 60s</code></p>
<blockquote>
<p>runs for 60 seconds with 4 cpu stressors, 2 io stressors and 1 vm
stressor using 1GB of virtual memory.</p>
</blockquote>
<p><code>stress-ng --iomix 2 --iomix-bytes 10% -t 10m</code></p>
<blockquote>
<p>runs 2 instances of the mixed I/O stressors using a total of 10% of
the available file system space for 10 minutes. Each stressor will use
5% of the available file system space.</p>
</blockquote>
<p><code>stress-ng --with cpu,matrix,vecmath,fp --seq 8 -t 1m</code></p>
<blockquote>
<p>run 8 instances of cpu, matrix, vecmath and fp stressors sequentially
one after another, for 1 minute per stressor.</p>
</blockquote>
<p><code>stress-ng --with cpu,matrix,vecmath,fp --permute 5 -t 10s</code></p>
<blockquote>
<p>run permutations of 5 instances of cpu, matrix, vecmath and fp
stressors sequentially one after another, for 10 seconds per permutation
mix.</p>
</blockquote>
<p><code>stress-ng --cyclic 1 --cyclic-dist 2500 --cyclic-method clock_ns --cyclic-prio 100 --cyclic-sleep 10000 --hdd 0 -t 1m</code></p>
<blockquote>
<p>measures real time scheduling latencies created by the hdd stressor.
This uses the high resolution nanosecond clock to measure latencies
during sleeps of 10,000 nanoseconds. At the end of 1 minute of
stressing, the latency distribution with 2500 ns intervals will be
displayed. NOTE: this must be run with the CAP_SYS_NICE capability to
enable the real time scheduling to get accurate measurements.</p>
</blockquote>
<p><code>stress-ng --cpu 8 --cpu-ops 800000</code></p>
<blockquote>
<p>runs 8 cpu stressors and stops after 800000 bogo operations.</p>
</blockquote>
<p><code>stress-ng --sequential 2 --timeout 2m --metrics</code></p>
<blockquote>
<p>run 2 simultaneous instances of all the stressors sequentially one by
one, each for 2 minutes and summarise with performance metrics at the
end.</p>
</blockquote>
<p><code>stress-ng --cpu 4 --cpu-method fft --cpu-ops 10000 --metrics-brief</code></p>
<blockquote>
<p>run 4 FFT cpu stressors, stop after 10000 bogo operations and produce
a summary just for the FFT results.</p>
</blockquote>
<p><code>stress-ng --cpu -1 --cpu-method all -t 1h --cpu-load 90</code></p>
<blockquote>
<p>run cpu stressors on all online CPUs working through all the
available CPU stressors for 1 hour, loading the CPUs at 90% load
capacity.</p>
</blockquote>
<p><code>stress-ng --cpu 0 --cpu-method all -t 20m</code></p>
<blockquote>
<p>run cpu stressors on all configured CPUs working through all the
available CPU stressors for 20 minutes</p>
</blockquote>
<p><code>stress-ng --all 4 --timeout 5m</code></p>
<blockquote>
<p>run 4 instances of all the stressors for 5 minutes.</p>
</blockquote>
<p><code>stress-ng --random 64</code></p>
<blockquote>
<p>run 64 stressors that are randomly chosen from all the available
stressors.</p>
</blockquote>
<p><code>stress-ng --cpu 64 --cpu-method all --verify -t 10m --metrics-brief</code></p>
<blockquote>
<p>run 64 instances of all the different cpu stressors and verify that
the computations are correct for 10 minutes with a bogo operations
summary at the end.</p>
</blockquote>
<p><code>stress-ng --sequential -1 -t 10m</code></p>
<blockquote>
<p>run all the stressors one by one for 10 minutes, with the number of
instances of each stressor matching the number of online CPUs.</p>
</blockquote>
<p><code>stress-ng --sequential 8 --class io -t 5m --times</code></p>
<blockquote>
<p>run all the stressors in the io class one by one for 5 minutes each,
with 8 instances of each stressor running concurrently and show overall
time utilisation statistics at the end of the run.</p>
</blockquote>
<p><code>stress-ng --all -1 --maximize --aggressive</code></p>
<blockquote>
<p>run all the stressors (1 instance of each per online CPU)
simultaneously, maximize the settings (memory sizes, file allocations,
etc.) and select the most demanding/aggressive options.</p>
</blockquote>
<p><code>stress-ng --random 32 -x numa,hdd,key</code></p>
<blockquote>
<p>run 32 randomly selected stressors and exclude the numa, hdd and key
stressors</p>
</blockquote>
<p><code>stress-ng --sequential 4 --class vm --exclude bigheap,brk,stack</code></p>
<blockquote>
<p>run 4 instances of the VM stressors one after each other, excluding
the bigheap, brk and stack stressors</p>
</blockquote>
<p><code>stress-ng --taskset 0,2-3 --cpu 3</code></p>
<blockquote>
<p>run 3 instances of the CPU stressor and pin them to CPUs 0, 2 and
3.</p>
</blockquote>
<h1>EXIT STATUS</h1>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Status</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: left;">Success.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;">Error; incorrect user options or a fatal
resource issue in the stress-ng stressor harness (for example, out of
memory).</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;">One or more stressors failed.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;">One or more stressors failed to initialise
because of lack of resources, for example ENOMEM (no memory), ENOSPC (no
space on file system) or a missing or unimplemented system call.</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: left;">One or more stressors were not implemented
on a specific architecture or operating system.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: left;">A stressor has been killed by an
unexpected signal.</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: left;">A stressor exited by exit(2) which was not
expected and timing metrics could not be gathered.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: left;">The bogo ops metrics maybe untrustworthy.
This is most likely to occur when a stress test is terminated during the
update of a bogo-ops counter such as when it has been OOM killed. A less
likely reason is that the counter ready indicator has been
corrupted.</td>
</tr>
</tbody>
</table>
<h1>BUGS</h1>
<p>File bug reports at:
https://github.com/ColinIanKing/stress-ng/issues</p>
<h1>SEE ALSO</h1>
<p><strong>cpuburn</strong>(1), <strong>perf</strong>(1),
<strong>stress</strong>(1), <strong>taskset</strong>(1)<br />
<strong>https://github.com/ColinIanKing/stress-ng/blob/master/README.md</strong></p>
<h1>AUTHOR</h1>
<p>stress-ng was written by Colin Ian King
&lt;colin.i.king@gmail.com&gt; and is a clean room re-implementation and
extension of the original stress tool by Amos Waterland. Thanks also to
the many contributors to stress-ng. The README.md file in the source
contains a full list of the contributors.</p>
<h1>NOTES</h1>
<p>Sending a SIGALRM, SIGINT or SIGHUP to stress-ng causes it to
terminate all the stressor processes and ensures temporary files and
shared memory segments are removed cleanly.</p>
<p>Sending a SIGUSR2 to stress-ng will dump out the current load average
and memory statistics.</p>
<p>Note that the stress-ng cpu, io, vm and hdd tests are different
implementations of the original stress tests and hence may produce
different stress characteristics.</p>
<p>The bogo operations metrics may change with each release because of
bug fixes to the code, new features, compiler optimisations, changes in
support libraries or system call performance.</p>
<h1>COPYRIGHT</h1>
<p>Copyright © 2013-2021 Canonical Ltd, Copyright © 2021-2024 Colin Ian
King.<br />
This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.</p>
</body>
</html>
